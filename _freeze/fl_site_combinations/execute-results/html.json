{
  "hash": "0b246f15d46872fd121f9aaf16d22c49",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - pyodide\n---\n\n# Calculating combinations of sites\n\n\n::: {.cell}\n\n:::\n\n<style>\na.glossary {\n  color: #8A1E1E;\n  text-decoration: underline;\n  cursor: help;\n  position: relative;\n}\n\n/* only needed for popup = \"click\" */\n/* popup-definition */\na.glossary .def {\n  display: none;\n  position: absolute;\n  z-index: 1;\n  width: 200px;\n  bottom: 100%;\n  left: 50%;\n  margin-left: -100px;\n  background-color: #333;\n  color: white;\n  padding: 5px;\n  border-radius: 6px;\n}\n/* show on click */\na.glossary:active .def {\n  display: inline-block;\n}\n/* triangle arrow */\na.glossary:active .def::after {\n  content: ' ';\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  margin-left: -5px;\n  border-width: 5px;\n  border-style: solid;\n  border-color: #333 transparent transparent transparent;\n}\n</style>\n\n\nMuch of the time, you will start with a series of known locations for services.\n\nThese will either be:\n\n- Proposed locations for services\n    - Managers will often consider a range of possibilities based on buildings owned by the organisation, areas with buildings available for rent, and so on, before you receive a list of possibilities\n    - Alternatively, you can have more flexibility (e.g. allowing the centroid of each LSOA to be a possible location)\n- Locations of existing services\n- A mix of the two\n\nYou’ll also need a travel matrix, with\n\n- the sources of demand (where people will be travelling from) as rows\n- the destinations (all the possible clinic locations) as the columns\ntravel times or distances as the values.\n\nSound familiar…?\n\nYep - that sounds like the travel matrices from the last section!\n\n![](assets/2024-06-24-18-58-01.png)\n\nWhen we did our travel maps before, we just worked out the shortest possible distance\n\n![](assets/2024-06-24-18-58-18.png)\n\nBut now, we want to work out the shortest distance depending on which clinics are available\n\n![](assets/2024-06-24-18-58-41.png)\n\n## Representing possible combinations of sites\n\nWe then need to be able to represent these as an integer array\n\nLet’s say we currently have four locations we deliver routine health screenings from.\n\nDue to constraints, we’re going to have to cut it down to three.\n\n![](assets/2024-06-24-18-59-10.png)\n\n![](assets/2024-06-24-18-59-35.png)\n\n### Translating the problem for a computer\n\n![](assets/2024-06-24-18-59-52.png)\n\nIn our code, we will write this as a list of lists.\n\n![](assets/2024-06-24-19-00-07.png)\n\n### Using the itertools package for calculating combinations\n\nAnd in fact, we won’t actually write it ourselves at all…\n\nWe’ll get the combinations function from the itertools package to do that for us - via a custom function.\n\n```{pyodide-python}\nfrom itertools import combinations\n\ndef all_combinations(n_facilities, p):\n    facility = np.arange(n_facilities, dtype=np.uint8)\n    return [np.array(a) for a in combinations(facility, p)]\n```\n\n`n_facilities` is the number of candidate locations where you could place facilities (e.g. clinics).\n\n`p` is the number of clinics to place. This must be less than `n_facilities`.\n\nThis will return all possible combinations of clinic indices.\n\n:::{.callout-info}\n#### How is this function working?\n![](assets/2024-06-24-19-10-38.png)\n\n![](assets/2024-06-24-19-10-49.png)\n\n![](assets/2024-06-24-19-11-01.png)\n:::\n\n\n### Larger problems\n\nIt turns out someone forgot to tell us about one of the practices!\n\nBut they are still just looking to drop it down to 3 practices.\n\nSo how many combinations can we get now?\n\n![](assets/2024-06-24-19-11-28.png)\n\nWell, these are all of the possibilities.\n\n![](assets/2024-06-24-19-11-56.png)\n\nLet's add numeric indices to these for ease.\n\n![](assets/2024-06-24-19-12-16.png)\n\nThat was a bit of a pain to work out… so you can see why it’s really useful to have a function that will work this out for us when we get to bigger numbers of combinations!\n\nBut just how big can the number of combinations get?\n\n## Calculating the number of combinations\n\nWe can use the formula below to work out the total number of possible combinations in a scenario where the order of options doesn’t matter and you can’t repeat options in an answer.\n\n![](assets/2024-06-24-19-13-04.png)\n\n:::{.callout-tip}\nThe ! isn’t just emphasising things here.\n\nIt is the mathematical symbol for factorial.\n\nSo if we have 5 options, the top of our fraction is 5!, or 5 factorial.\n\nThis is 5 x 4 x 3 x 2 x 1\n\n2! = 2 x 1\n\n3! = 3 x 2 x 1\n\n10! = 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1\n:::\n\n![](assets/2024-06-24-19-13-37.png)\n\n## Limitations of brute-force problems\n\nThe key thing to note is that the number of combinations can get out of hand very quickly…\n\nIf you’re working at the level of a single trust, or with some fairly centralised services for an ICB, you’ll probably be ok.\n\n![](assets/2024-06-24-19-14-11.png)\n\n![](assets/2024-06-24-19-14-23.png)\n\n![](assets/2024-06-24-19-14-33.png)\n\n![](assets/2024-06-24-19-14-43.png)\n\n:::{.callout-tip}\nThere are ways to deal with situations where there are too many possibilities to ‘brute force’ - but it’s quite a tricky area to wrap your head around!\n\nWe’ll briefly cover this concept a bit later today, but we won’t cover how to do it in code or go into much detail about the process.\n\nHowever,\n- we will link additional materials if you want to dive into this further\n- there are some members of the HSMA community with experience in this area if this is a route you need to go down for your HSMA project\n\n:::\n\n## References\n\nIcons created by Pixel perfect - Flaticon: https://www.flaticon.com/packs/nature-46\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}