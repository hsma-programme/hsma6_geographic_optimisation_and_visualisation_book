{
  "hash": "634368585a79212c405d0f22c31689aa",
  "result": {
    "engine": "knitr",
    "markdown": "# Visualising Travel Times in Python\n\n\n::: {.cell}\n\n:::\n\n<style>\na.glossary {\n  color: #8A1E1E;\n  text-decoration: underline;\n  cursor: help;\n  position: relative;\n}\n\n/* only needed for popup = \"click\" */\n/* popup-definition */\na.glossary .def {\n  display: none;\n  position: absolute;\n  z-index: 1;\n  width: 200px;\n  bottom: 100%;\n  left: 50%;\n  margin-left: -100px;\n  background-color: #333;\n  color: white;\n  padding: 5px;\n  border-radius: 6px;\n}\n/* show on click */\na.glossary:active .def {\n  display: inline-block;\n}\n/* triangle arrow */\na.glossary:active .def::after {\n  content: ' ';\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  margin-left: -5px;\n  border-width: 5px;\n  border-style: solid;\n  border-color: #333 transparent transparent transparent;\n}\n</style>\n\n\n\n## Working with precalculated travel matrices\n\nYou may be able to find useful datasets that other people have created of common lookups you may need to do.\n\nThis is the travel time from every LSOA in the country to every hospital in the country (by car, assuming there is no traffic)\n\n:::{.callout-tip}\nYou’ll need to check whether the data is in hours, minutes or seconds! It may vary depending on the web service used and other processing.\n:::\n\n![](assets/2024-06-22-10-05-47.png)\n\nIn this dataset,\n\nRows = LSOA\n\nColumns = Postcodes of Hospital and Clinic Sites\n\nCell = travel time from LSOA to hospital/clinic (minutes)\n\n### Calculating the shortest travel time\n\nLet’s look at an example of how to take a matrix like this and calculate the shortest travel time to a site from each LSOA.\n\nWe’ve been given a dataset containing postcodes of hospitals with 24-hour A&E departments within 50 miles of the centre of Birmingham.\n\nLet's first import the packages we'll be needing.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport geopandas\nimport matplotlib.pyplot as plt\nimport requests\nimport contextily as cx\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nbirmingham_area_hospitals_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    postcode                                 name\n0    B18 7QH                        City Hospital\n1    B15 2TH  Queen Elizabeth Hospital Birmingham\n2     B9 5SS                 Heartlands Hospital \n3    B71 4HJ   Sandwell District General Hospital\n4    B75 7RR                   Good Hope Hospital\n5    WS2 9PS                       Manor Hospital\n6    DY1 2HQ               Russells Hall Hospital\n7   WV10 0QP                   New Cross Hospital\n8    B98 7UB                   Alexandra Hospital\n9   CV10 7DJ                George Eliot Hospital\n10  CV34 5BW                     Warwick Hospital\n11   CV2 2DX       University Hospital (Coventry)\n12   WR5 1DD        Worcestershire Royal Hospital\n13  ST16 3SA                    Stafford Hospital\n14   TF1 6TF              Princess Royal Hospital\n15   LE1 5WW            Leicester Royal Infirmary\n16  DE22 3NE                 Royal Derby Hospital\n17  OX16 9AL              Horton General Hospital\n18   ST4 6QG      Royal Stoke University Hospital\n19   SY3 8XQ            Royal Shrewsbury Hospital\n```\n\n\n:::\n:::\n\n\nWe know the extent we are interested in, and need to visualise the current areas with longer journey times.\n\nWe've got a precalculated travel matrix of car times available to us, showing the distance to any hospital in the UK from any LSOA in the UK.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_travel_time_lookup = pd.read_csv(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/travel_matrix_minutes.zip\")\n```\n:::\n\n\n:::{.callout-tip}\nWhen distances relate to LSOAs, MSOAs or postcodes, they will often relate to the **centroid** of that region (the centre point).\n\nRemember - MSOAs and LSOAs (and even some postcodes) can cover a fairly large area. Datasets exist of *population-weighted centroids*, which may be more appropriate to use.\n:::\n\nThe first thing we’re going to do is make a new dataframe that only contains the columns for the relevant hospitals.\n\n:::{.callout-warning}\nAlways be very careful with **boundary issues**\n\nIn this case we've been told to only visualise their shortest journey to any one of the hospitals in this list. But someone at the edge of the region showing a very short journey time could be just down the road from a different hospital not in our dataset!\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_travel_time_lookup_birmingham_hospitals = car_travel_time_lookup.loc[\n    # keep all of the rows\n    :,\n    # keep the LSOA column and columns for relevant hospitals\n    ['LSOA'] + birmingham_area_hospitals_df.postcode.to_list()\n    ]\n\ncar_travel_time_lookup_birmingham_hospitals.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   LSOA     B18 7QH  ...     ST4 6QG     SY3 8XQ\n0  Welwyn Hatfield 010F  122.066667  ...  158.966667  168.683334\n1  Welwyn Hatfield 012A  122.783334  ...  159.683334  169.400000\n2  Welwyn Hatfield 002F  123.533333  ...  160.433333  170.150000\n3  Welwyn Hatfield 002E  123.399999  ...  160.299999  170.000001\n4  Welwyn Hatfield 010A  122.100000  ...  159.000000  168.716667\n\n[5 rows x 21 columns]\n```\n\n\n:::\n:::\n\n\nNow, we want to return the shortest travel time to any of these hospitals.\n\nSo what we need is the smallest value in any of the columns - except the LSOA name!\n\nSo first, let’s change the LSOA name to be our index.\n\nThis means it will be ignored when we try to look for the minimum travel time.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_travel_time_lookup_birmingham_hospitals = car_travel_time_lookup_birmingham_hospitals.set_index('LSOA')\n\ncar_travel_time_lookup_birmingham_hospitals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         B18 7QH     B15 2TH  ...     ST4 6QG     SY3 8XQ\nLSOA                                          ...                        \nWelwyn Hatfield 010F  122.066667  129.000000  ...  158.966667  168.683334\nWelwyn Hatfield 012A  122.783334  129.716667  ...  159.683334  169.400000\nWelwyn Hatfield 002F  123.533333  130.466667  ...  160.433333  170.150000\nWelwyn Hatfield 002E  123.399999  130.316666  ...  160.299999  170.000001\nWelwyn Hatfield 010A  122.100000  129.033333  ...  159.000000  168.716667\n...                          ...         ...  ...         ...         ...\nSelby 009C            135.750000  142.783334  ...  130.416667  165.850000\nSelby 007D            139.116666  146.150001  ...  133.783334  170.050000\nSelby 007B            136.750000  143.766667  ...  133.633333  168.550000\nSelby 006A            138.550000  145.583333  ...  135.433333  170.350000\nSelby 007A            140.150000  147.166667  ...  137.033333  171.816667\n\n[32843 rows x 20 columns]\n```\n\n\n:::\n:::\n\n\nNow we can calculate the row-wise minimum\n(i.e. look across the columns and find the smallest value for that row)\nAnd turn this into a new column.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_travel_time_lookup_birmingham_hospitals['shortest'] = (\n    # axis = 1 means row-wise minimum (instead of columnwise)\n    car_travel_time_lookup_birmingham_hospitals.min(axis=1)\n)\n\ncar_travel_time_lookup_birmingham_hospitals.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                         B18 7QH     B15 2TH  ...     SY3 8XQ   shortest\nLSOA                                          ...                       \nWelwyn Hatfield 010F  122.066667  129.000000  ...  168.683334  90.516666\nWelwyn Hatfield 012A  122.783334  129.716667  ...  169.400000  91.233333\nWelwyn Hatfield 002F  123.533333  130.466667  ...  170.150000  91.983334\nWelwyn Hatfield 002E  123.399999  130.316666  ...  170.000001  91.850000\nWelwyn Hatfield 010A  122.100000  129.033333  ...  168.716667  90.549999\n\n[5 rows x 21 columns]\n```\n\n\n:::\n:::\n\n\nNow we need to join this to some kind of geometry - as at the moment we have the name of each LSOA, but no way of plotting them.\n\nWe don’t really know where they are until we import something like a geojson, geopkg or shapefile.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlsoa_geojson_path = 'https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson'\n\nlsoa_boundaries = geopandas.read_file(lsoa_geojson_path)\n```\n:::\n\n\nLet’s just plot this to check it’s what we’re expecting and what the CRS is.\n\nThis looks like it’s using the British National Grid system.\n\n(we can tell because the range is 0 to ~ 700,000 in each direction rather than numbers < 100 if it was latitude and longitude)\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlsoa_boundaries.plot()\n```\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/plot_boundary_file-1.png){width=672}\n:::\n:::\n\n\n### Joining the travel times to geometry data\n\nNow it’s time to join it to the travel time data per LSOA.\n\nWe use the pandas merge() function.\n\n:::{.callout-tip}\nNote that we pass in the lsoa boundaries geodataframe first out of the two dataframes - this ensures the output will be a geopandas file and not get converted to a standard dataframe.\n:::\n\n:::{.callout-tip}\nSide note: we are resetting the index of our travel time dataframe so that LSOA11NM is a column, not an index (i.e. our row identifiers are 0, 1, 2, 3 etc., not the names of the LSOAs).\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnearest_hospital_travel_bham_gdf = pd.merge(\n    lsoa_boundaries,\n    car_travel_time_lookup_birmingham_hospitals.reset_index(),\n    left_on=\"LSOA11NM\",\n    right_on=\"LSOA\",\n    how=\"right\"\n)\n```\n:::\n\n\nWe’re doing a right join, which means every row in the car_travel_time_lookup_birmingham_hospitals dataframe will be kept, even if there isn’t a match in the lsoa_boundaries file.\n\n![](assets/2024-06-22-10-34-10.png)\n\n### Plotting the travel times\n\nNow let’s try plotting this!\n\nIt looks like the travel times are shortest around Birmingham - which makes perfect sense as we’ve only been checking against the hospitals in Birmingham!\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnearest_hospital_travel_bham_gdf.plot(\n    column='shortest',\n    legend=True\n    )\n```\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/plot_gdf_nearest-3.png){width=672}\n:::\n:::\n\n\n### Refining the travel time plot\n\n#### Adjusting the plot boundaries\n\nLet’s zoom in a bit so we’re not giving misleading information.\n\n:::{.callout-warning}\nIf we just zoom, the scale of our output isn’t very helpful.\n\nThis is because the legend is based on the entire dataframe, which still includes those distant regions, even if they aren’t shown in the final plot.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nax = nearest_hospital_travel_bham_gdf.plot(\n    column='shortest',\n    legend=True\n    )\n\nax.set_xlim(xmin, xmax)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(370000.0, 420000.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nax.set_ylim(ymin, ymax)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(250000.0, 310000.0)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/zoom_bad-5.png){width=672}\n:::\n:::\n\n:::\n\nRemember the .cx method for filtering down to just those regions within a boundary box?\n\nIf we use that first, our plot becomes a lot more informative!\n\n\n::: {.cell}\n\n```{.python .cell-code}\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True\n    )\n```\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/plot_filter_gdf-7.png){width=672}\n:::\n:::\n\n\nWould it look better with some whitespace around the edge of the map to make it clear what area we are considering?\n\n#### Extending the plot extent back out\n\nWe can make the matplotlib limits slightly different to the boundary box to achieve this.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(350000.0, 440000.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nax.set_ylim(ymin-20000, ymax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(230000.0, 330000.0)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/filter_gdf-9.png){width=672}\n:::\n:::\n\n\n#### Changing the colourschemes\n\nLet’s experiment with a different colourscheme.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True,\n    cmap=\"Reds\"\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(350000.0, 440000.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nax.set_ylim(ymin-20000, ymax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(230000.0, 330000.0)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/colorscheme-11.png){width=672}\n:::\n:::\n\n\n#### Adding in points to show the possible destinations\n\nLet’s make use of the postcodes.io web API.\n\nWe import requests to help us interact with the API.\n\nWe pass a list of postcodes to the relevant web address.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\npostcode_lookup = requests.post(\n        \"https://api.postcodes.io/postcodes\",\n        json={\"postcodes\": birmingham_area_hospitals_df['postcode'].tolist()}\n    )\n\npostcode_lookup\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Response [200]>\n```\n\n\n:::\n:::\n\n\nThen we turn it into a dataframe and join it to our hospital df.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# label: convert_postocde_json_to_df\npostcode_lookup = pd.json_normalize(postcode_lookup.json()['result'], sep='_')\n\npostcode_lookup\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       query result_postcode  ...  result_codes_lau2  result_codes_pfa\n0    B18 7QH         B18 7QH  ...          E08000025         E23000014\n1    B15 2TH         B15 2TH  ...          E08000025         E23000014\n2     B9 5SS          B9 5SS  ...          E08000025         E23000014\n3    B71 4HJ         B71 4HJ  ...          E08000028         E23000014\n4    B75 7RR         B75 7RR  ...          E08000025         E23000014\n5    WS2 9PS         WS2 9PS  ...          E08000030         E23000014\n6    DY1 2HQ         DY1 2HQ  ...          E08000027         E23000014\n7   WV10 0QP        WV10 0QP  ...          E08000031         E23000014\n8    B98 7UB         B98 7UB  ...          E07000236         E23000016\n9   CV10 7DJ        CV10 7DJ  ...          E07000219         E23000017\n10  CV34 5BW        CV34 5BW  ...          E07000222         E23000017\n11   CV2 2DX         CV2 2DX  ...          E08000026         E23000014\n12   WR5 1DD         WR5 1DD  ...          E07000237         E23000016\n13  ST16 3SA        ST16 3SA  ...          E07000197         E23000015\n14   TF1 6TF         TF1 6TF  ...          E06000020         E23000016\n15   LE1 5WW         LE1 5WW  ...          E06000016         E23000021\n16  DE22 3NE        DE22 3NE  ...          E06000015         E23000018\n17  OX16 9AL        OX16 9AL  ...          E07000177         E23000029\n18   ST4 6QG         ST4 6QG  ...          E06000021         E23000015\n19   SY3 8XQ         SY3 8XQ  ...          E06000051         E23000016\n\n[20 rows x 41 columns]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nbirmingham_area_hospitals_df = pd.merge(\n    birmingham_area_hospitals_df,\n    postcode_lookup,\n    left_on=\"postcode\",\n    right_on=\"query\"\n)\n```\n:::\n\n\nThen we’ll turn the output into a geodataframe.\n\nBecause our original dataset was in eastings/northings, we can use those columns from our postcodes.io lookup result, and tell geopandas that we’re using EPSG:27700\n\n\n::: {.cell}\n\n```{.python .cell-code}\nbirmingham_area_hospitals_gdf = geopandas.GeoDataFrame(\n    birmingham_area_hospitals_df,\n    geometry = geopandas.points_from_xy(\n        birmingham_area_hospitals_df['result_eastings'],\n        birmingham_area_hospitals_df['result_northings']\n        ),\n    crs = 'EPSG:27700'\n    )\n```\n:::\n\n\nNow we can plot the points to check the results look roughly correct.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nax = birmingham_area_hospitals_gdf.plot()\n\ncx.add_basemap(\n    ax,\n    crs=birmingham_area_hospitals_gdf.crs.to_string(),\n    zoom=9\n    )\n```\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/add_basemap_point_plot-13.png){width=672}\n:::\n:::\n\n\nNow we can add these points to our map.\n\nFirst we plot the choropleth.\n\nBy passing the ax argument - remembering that we called our initial plot object ax - we make sure it plots these as an extra layer - not a totally new plot!\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# label: plot_points_and_choropleth\nxmin, xmax = 380000, 440000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    cmap=\"Reds\",\n    legend=True,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    alpha=0.6,\n    figsize=(12,12)\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(360000.0, 460000.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nax.set_ylim(ymin-20000, ymax+20000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(230000.0, 330000.0)\n```\n\n\n:::\n\n```{.python .cell-code}\nhospital_points = birmingham_area_hospitals_gdf.plot(\n    ax=ax,\n    color='black',\n    markersize=50\n    )\n\ncx.add_basemap(\n    ax,\n    crs=nearest_hospital_travel_bham_gdf.crs.to_string(),\n    zoom=10\n    )\n\nplt.title(\"Travel Time (minutes - by car) to Nearest Hospitals with A&E Department\\nBirmingham Area\")\nax.axis('off')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(360000.0, 460000.0, 230000.0, 330000.0)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](mtt_mapping_travel_times_python_files/figure-html/unnamed-chunk-23-15.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "mtt_mapping_travel_times_python_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}