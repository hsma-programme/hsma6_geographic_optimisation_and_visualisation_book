[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - Geographic Modelling and Visualisation",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Welcome!",
    "section": "",
    "text": "Welcome to this HSMA book on Geographic Modelling & Visualisation.\n\nLost Kermit GIFfrom Lost GIFs\n\n\nThis book accompanies module 3 of the 15 month HSMA programme.\nIt is aimed at people with some experience of Python who want to be able to work with geographic data.\nIt is particularly aimed at people in the UK working in the National Health Service (NHS), policing, social care, public health or local government.\nWe will cover topics including:\n\nprinciples and terminology needed when working with geographical data and maps\ncreating maps using a free and open source software package (QGIS)\nworking with geographic data in Python using the Geopandas library\ncreating static maps in Python with matplotlib\ncreating interactive maps in Python with Folium, Leaflet and Kepler\ninteracting with travel time APIs\nvisualising travel times to sites across regions\noptimizing the locations of facilities to minimize travel time across a region\noptimizing the locations of facilities to maximize performance against multiple objectives (e.g. minimizing average travel time while maximizing the percentage of people who can reach a service within 30 minuts)\n\n\n\n\n\n\n\nterm\ndefinition\n\n\n\n\nAPI\n&lt;b&gt;Application Programming Interface&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; A way for two or more programs to talk to one another. Designed for computer programmers to utilise when writing programs rather than being used by an end user.&lt;br/&gt;&lt;br/&gt; You will send a request to an API and it will send back a response. For example, you might request data on the postcode EX2 5AA from the postcodes.io API, and it will return a text string containing data like the latitude and longitu",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome!</span>"
    ]
  },
  {
    "objectID": "what_geographic_problems_health_etc.html",
    "href": "what_geographic_problems_health_etc.html",
    "title": "2  Types of Geographic Problems",
    "section": "",
    "text": "2.1 Simple Mapping Problems - Understanding the Geographical Distribution of a Variable\nTalk about disease distributions, IMD, etc.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Types of Geographic Problems</span>"
    ]
  },
  {
    "objectID": "what_geographic_problems_health_etc.html#location-optimization-facility-location-problems",
    "href": "what_geographic_problems_health_etc.html#location-optimization-facility-location-problems",
    "title": "2  Types of Geographic Problems",
    "section": "2.2 Location Optimization (Facility Location) Problems",
    "text": "2.2 Location Optimization (Facility Location) Problems\nTalk about simple location optimization, competing priorities, etc.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Types of Geographic Problems</span>"
    ]
  },
  {
    "objectID": "what_geographic_problems_health_etc.html#routing-and-scheduling-problems",
    "href": "what_geographic_problems_health_etc.html#routing-and-scheduling-problems",
    "title": "2  Types of Geographic Problems",
    "section": "2.3 Routing and Scheduling Problems",
    "text": "2.3 Routing and Scheduling Problems\nIf you’ve ordered an item for delivery in the past few years, you may have found yourself looking at a link sent to you by a delivery company, showing you where your delivery driver is and how many stops there are until they arrive with you.\nDelivery drivers can have hundreds of parcels to deliver in a day, and companies have tens of thousands of packages to coordinate delivering. They want to keep fuel costs down and use as few vehicles as possible - so optimizing the route of each vehicle is crucial.\nNow, while health systems certainly have inventory and delivery problems, there are other kinds of resources that are often travelling - nurses.\nCommunity nursing is a huge part of the NHS. In acute (physical) trusts, nurses may be visiting the homes of clients to change dressings, conduct health checks, administer medication, and more.\n\n\n\n\n\nflowchart LR\n    id1{{\"Beryl can’t do leg dressing changes for patients at the moment because she has a bad back\"}}\n\n    id2{{\"Mr H only wants male nurses for the catheter change\"}}\n\n    id3{{\"We need two nurses for that visit\"}}\n\n    id4{{\"There are roadworks on Quarry lane for the next three weeks so it’s taking 20 minutes extra to get between visits\"}}\n\n    id5{{\"Matt hasn’t done his insulin pump training yet\"}}\n\n\n\n\n\n\nCommunity transport problems are another class of routing problem in the NHS. Patients are sometimes unable to get themselves to crucial appointments by driving or public transport, meaning transport vehicles are necessary to ensure they can attend critical appointements such as dialysis.\n[PUT IN COVID DIALYSIS TRANSPORT EXAMPLE]\nIn other situations, such as mental health trusts, there may be a requirement to securely transport patients from their home to a ward for inpatient treatment, or between wards with different levels of security or treatment intensity.\nThis is before we start to consider things such as paramedic cars and ambulances, where the location and movement of vehicles is crucial.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Types of Geographic Problems</span>"
    ]
  },
  {
    "objectID": "concepts_and_terms.html",
    "href": "concepts_and_terms.html",
    "title": "3  Geographical Concepts and Terminology",
    "section": "",
    "text": "Before you get started with making your own maps, it’s helpful to understand a few key concepts and terms.",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geographical Concepts and Terminology</span>"
    ]
  },
  {
    "objectID": "ct_crs.html",
    "href": "ct_crs.html",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "",
    "text": "4.1 Projections\nIn summary, different projections are valuable for different reasons - but they can distort the sizes of countries quite significantly. Just how big these distortions are might surprise you…\nFor example, let’s look at Greenland and Africa on the world map you are probably familiar with.\nThis map uses the Mercator projection. Now, when our primary requirement for maps was trying to sail ships across the ocean, this map was fantastic. It allowed navigators to set a single constant bearing and get to where they needed to go, rather than constantly adjusting and risking huge errors if they made a single mistake along the way.\nActually, to be fair to the Mercator projection, it still has benefits today for navigation with things like Google maps - in fact, a special variant of the Mercator projection, known as Web Mercator (a.k.a. WGS 84 Web Mercator, WGS 84/Pseudo-Mercator, EPSG:3857) is used by almost every major web mapping service, such as Bing, OpenStreetMap, and others - so it’s worth knowing about as you’ll use it a lot when you’re making interactive maps later in the course.2\nHowever, all versions of the Mercator projection have the rather unfortunate side effect of significantly distorting the apparent sizes of different countries.\nCountries far from the equator - for example Northern Europe, Russia, the US, Canada, and the North and South Poles - appear on the map to be much bigger than they are in reality. If you don’t know it’s happening, it can be quite a surprise to learn that certain countries really aren’t as big as you might have thought!",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#projections",
    "href": "ct_crs.html#projections",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "",
    "text": "Click here to show an animation demonstrating the impact of the Mercator Projection on the relative size of different countries\n\n\n\n\n\n\n\n\nRelative Size of Countries - Mercator Projection Distortion\n\n\nBy Jakub Nowosad - Own Work;, CC BY-SA 4.0, Link3\n\n\n\n\nOptional Exercise\nA great way to get your head around the impact of the Mercator projection on our understanding of the world is to use the website the true size of.\nHead to that website and try the following out. Do the results surprise you? Does this change your sense of our world? Click ‘clear map’ after each exercise to get back to a blank map, or right click on the coloured shape of the country to remove it - Search for Russia and drag it onto the North of Africa. - Search for the United Kingdom and drag it onto Greenland. - Search for Canada and drag it onto Brazil.\n\n\nOptional Exercise\nYou can play around with some different projections at the metrocosm website.\nYou will notice that there are a large number of purple dots all over the maps on that website. Why are they there?\nOn a globe, all of those purple dots would be the same size. They are a good way of understanding how different projections distort the size or shape of different parts of the world.\nLook at each projection.",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#coordinate-reference-systems",
    "href": "ct_crs.html#coordinate-reference-systems",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "4.2 Coordinate Reference Systems",
    "text": "4.2 Coordinate Reference Systems\nThe next thing to understand is how we divide the world up so we can all talk about it using the same language and find the same point on the map.\nOne of the most common ways to do this is with latitude and longitude.\n\n4.2.1 Latitude and longitude\nLatitude looks at how far a point is from the equator - you can also think of it as how close a point is to the North or South Pole.\nLines of latitude run parallel with the equator.\n4\nLatitude has a value of 0 at the equator.\n‘Above’ the equator - towards the North Pole - latitude gradually gets bigger, written as, for example, 70N, reaching a maximum of 90 North at the North pole.\n‘Below’ the equator - towards the South Pole - latitude gradually gets bigger, but this time it is written as, for example, 45S reaching a maximum of 90 South at the South pole.\nHowever - when you are using latitude on a computer, latitude South of the equator is often entered as a negative number instead.\nLongitude is the horizontal distance of a point away from the prime Meridian - a particular line that runs from the North Pole to the South Pole through Greenwich, London.\n5\nLongitude has a value of 0 at the Prime Meridian (Greenwich).\nEast of the Prime Meridian, longitude gradually gets bigger and is written as, for example, 60E, reaching a maximum of 180 on directly the opposite side of Earth.\nWest of the Prime Meridian, longitude gradually gets bigger but this time it is written as, for example, 30W, reaching a maximum of 180 on directly the opposite side of Earth.\nHowever - when you are using longitude on a computer, a longitude to the West of Greenwich is often entered as a negative number instead.\nThe image below gives you a quick reference to how different points may be written.\n\n\n4.2.1.1 Writing coordinate pairs\nAny point in the world can be identified by providing a figure for both latitude and longitude.\nHowever - it’s important to write them in the correct order, else you will end up somewhere very different!\nNow, just to be confusing… it’s the opposite way around to a standard graph.\nIf you cast your mind back to school, you might remember being taught about writing a coordinate pair for a standard graph.\n\n\n\nA cartesian coordinate plane\n\n\nWhen we write this, we write the position of the horizontal point (x) first, and then the vertical (y) point - so we write coordinates as (x, y). So for the graph above, this means the coordinates are (2, 5). You might have been taught to remember this as going ‘along the corridor, then up the stairs’.\nNow… it’s the opposite for latitude and longitude!\nLet’s say we have a latitude (the position vertically in relation to the equator - sort of equivalent to our y value above) of 7, and a longitude (the position horizontally in relation to the prime meridian - sort of equivalent to our x value above) of 15.\nWe’d write this as (7, 15) - not (15, 7) as you might have expected!\nSo just remember - it’s the opposite order to a graph!\n\n\n4.2.1.2 How do lines of latitude and longitude appear on different projections?\n\nMercator Projection\nAs it’s the projection you’re still going to commonly see (and probably use for most of the maps you create), let’s go back to the Mercator map projection.\nThe lines of latitude and longitude are the white grid that’s overlaid on the map, with the horizontal red line being the equator. Notice that all of the lines are totally straight!\n\nAll of the lines of longitude (running top to bottom) are parallel to each other - that is they stay the same distance apart the whole time.\nAll of the lines of latitude (running left to right) are also parallel to each other.\nThe lines of latitude and longitude are at perfect right angles (also known as perpendicular) to each other.\nHere, each horizontal line represents a distance of 15 degrees north or south.\nHowever - if you look at the top of the map, you will notice that the lines get further and further apart - even though the gaps still represent 15 degrees.\nRemember what we said before about the Mercator projection making countries further from the equator appear bigger than they are? Well this is it in action!\n\n\nGall-Peters Projection\nIn the Gall-Peters projection, the sizes of each rectangle made by the latitude and longitude lines are quite different to the Mercator proejction.\nThe rectangles are tall near the equator and get shorter as you go towards the North and South Poles.\n\nHowever, like the Mercator projection, the lines of latitude are parallel to each other, and the same is true of the lines of longitude.\nThis means that the map can still be used to navigate with a constant bearing - unlike a projection where these lines are curved.\nGall-Peters maps are UNESCOs preferred map, and are quite common in UK schools.6\n\n\nWinkel Tripel\nFinally, let’s look at the lines on the Winkel tripel projection.\nNowadays, it’s generally agreed that the Winkel Tripel is a projection that provides a nice balance between not distorting the countries further from the equator too much while also ensuring the shapes of each country are not distorted. It’s used in a lot of textbooks and it’s the preferred projection for world maps made by the National Geographic Society.7\n\nBut notice that the lines of latitude and longitude are no longer straight!\n\n\n\n4.2.1.3 Exercise: Getting Comfortable with Latitude and Longitude\nIt’s helpful to get a bit of a feeling for how latitude and longitude is written, as you’ll be dealing with it quite a lot in the datasets we will use later in this book.\nSo let’s work through a couple of questions.\nIn each of the questions below - the dotted line running vertically (from the top to the bottom of the image) is the prime meridian - the line that runs through Greenwich in London, England and is a longitude of 0. - the dotted line running horizontally (from the left to the right of the image) is the equator - the line that is a latitude of 0.\n\nQuestion 1\n\n\n\nWhat are the correct coordinates for this national park in Brazil?\n\n\n\n -20.655, 49.205 20.655, -49.205 20.655, 49.205 -20.655, -49.205\n\n\n\nQuestion 2\n\n\n\nWhat are the correct coordinates for this national park in Japan?\n\n\n\n -35.943, -138.764 35.943, 138.764 138.764, 35.943 35.943, -138.764\n\n\n\nQuestion 3\n\n\n\nWhat are the correct coordinates for St Luke’s?\n\n\nSt Luke’s is part of the University of Exeter and is home to the PenCHORD team, who write the HSMA course!\n\n -3.51, -50.722 -50.722, 3.51 50.722, -3.51 50.722, 3.51 -3.51, 50.722",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#what-coordinate-reference-systems-are-in-use-in-the-uk",
    "href": "ct_crs.html#what-coordinate-reference-systems-are-in-use-in-the-uk",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "4.3 What coordinate reference systems are in use in the UK?",
    "text": "4.3 What coordinate reference systems are in use in the UK?\nThe UK government provides the following guidelines on the usage of coordinate reference systems:\n\n\nuse British or Irish National Grid for data related to the UK and Northern Ireland\nuse ETRS89 (EPSG::4258) for Europe\nuse WGS84 for worldwide geographic location points\n\n\n\nYou can also combine these standards and/or add other CRS to meet your organisation’s requirements, for example, when you need greater accuracy for precision engineering decisions.\n\n\n4.3.1 The British National Grid\nGiven the government’s recommendation to use the BNG - which is also sometimes referred to as the Ordnance Survey National Grid reference system (OSBG) - you may come across datasets which make use of it, so it’s worth knowing how it works!\nRather than latitude and longitude, BNG uses Northings and Eastings.\nNorthing sand Estings will be given as a series of digits without decimal places.\nFor example, the location of the St Luke’s University campus (the home of HSMA!) using the BNG is 29297, 92456\n\nIn this, the Easting is 29297 and the Northing is 92456.\n\n\n\n\n\n\nWarning\n\n\n\nIt’s important to note that we give the Easting (the across) first, and the Northing (the up) second.\nThis is the opposite of using latitude and longitude!",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#what-other-ways-do-we-determine-areas-within-the-uk",
    "href": "ct_crs.html#what-other-ways-do-we-determine-areas-within-the-uk",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "4.4 What other ways do we determine areas within the UK?",
    "text": "4.4 What other ways do we determine areas within the UK?\n\n4.4.1 Postcodes\nPostcodes are a well-known way of splitting the UK up.\nPostcodes can be used at several different levels of resolution.\n\nPostcode areas are often quite large, sometimes spanning whole counties.\n^https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/British_postcode_areas_map.svg/450px-British_postcode_areas_map.svg.png\nIn contrast, a single exact postcode may only cover a handful of houses, so they are often not used when analysing healthcare data as there is too much of a risk of being able to identify an individual patient from their postcode.\n\n\n\n\n\n\nWarning\n\n\n\nThere are a lot of valid formats for postcodes, so they are not always the easiest to validate!\nYou may also find that they are input into software with a mixture of gaps between the first and second half (known as the outward code and inward code), so you may need to clean and standardise them before joining them to other datasets.\n\n\n\n\n\n\n\n\nTip\n\n\n\npostcodes.io is a great website for getting up-to-date information about postcodes and using this to supplement your data.\nFor example, you can find out which LSOA - a grouping we will talk about shortly - a postcode belongs to, which can help with aggregating your data for a different level of detail.\n\n\n\n\n4.4.2 Output Areas\nOutput Areas (OA), Lower Layer Super Output Areas (LSOA) and Middle Layer Super Output Areas (MSOA) are standardised geographical units that differ in area but have a roughly similar number of people living in each one.\n^ https://ocsi.uk/2019/03/18/lsoas-leps-and-lookups-a-beginners-guide-to-statistical-geographies/, https://www.ons.gov.uk/methodology/geography/ukgeographies/censusgeographies/census2021\n\n4.4.2.1 OA\nOutput Areas (OA) are very small, with an average of circa 300 people per area.\nThey are so small that you will probably not work with them very often.\n\n\n4.4.2.2 LSOA\nLower Layer Super Output Areas (LSOA) are the medium size of area, with around 1500 people per LSOA.\n\n\n4.4.2.3 MSOA\nLower Layer Super Output Areas (LSOA) are the largest size of area, with around 8000 people per MSOA.\nThe map below shows MSOA boundaries (in red) overlaid over the LSOA boundaries (in blue).\n\nZooming in on a single MSOA, outlined in red, we can see that there are, in this case, four LSOAs within it - though this will not be exactly the same for each MSOA.\nYou can also wee here that one of the LSOAs is much larger than the other three, suggesting it is likely to be less densely populated.\n\nClick here to view an interactive map of MSOAs without leaving the book!\n\n\n\n4.4.3 Issues when working with output areas\n\n\n\n\n\n\nImportant\n\n\n\nDespite being somewhat standardised, there can still be very significant differences between areas in terms of the number of people living in them or the total land area covered.\nYou should always carefully consider whether you need to standardise the data in some way to account for this variation.\nYou can read more about this process in a later chapter.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIt’s also worth paying attention to which year of output areas you are working with.\nA lot of older data will use 2011 boundaries, but the boundaries were refreshed in 2021. If trying to join older data to a newer file of boundaries, or vice-versa, you may find that some areas appear to be missing - so check the dates!\n\n\n\n\n4.4.4 Other groupings\n\n4.4.4.1 Local Authorities\nThere are county councils, which are quite large, and then these are often (though not always) subdivided into multiple district councils.\n^https://en.wikipedia.org/wiki/Local_government_in_England\n\n\n4.4.4.2 Healthcare Regions\nHealthcare regions in the UK frequently change.\n&lt;1996: Regional Health Authorities\n1996-2002: Health Authorities\n2002-2013: Strategic health authorities + primary care trusts\n2013-2022: CCGs\n2022-now (February 2024): Integrated care systems (integrated care board plus integrated care partnership)\n^https://geoportal.statistics.gov.uk/documents/ons::integrated-care-boards-april-2023-map-in-england/explore\n\n\n4.4.4.3 Ambulance Trusts\n^https://www.bbc.co.uk/news/health-16052725\n\n\n4.4.4.4 Police Forces\n^https://assets-hmicfrs.justiceinspectorates.gov.uk/uploads/police-force-map.pdf",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#further-reading",
    "href": "ct_crs.html#further-reading",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "5.1 Further Reading",
    "text": "5.1 Further Reading\n\n5.1.1 Understanding the size of countries\nhttps://mapfight.xyz/\nhttps://www.thetruesize.com/\n\n\n5.1.2 Projections\nA discussion of alternatives to Web Mercator - while it’s geared towards options available in ArcGis, it’s a great demonstration of some options\n\n\n5.1.3 Coordinate Reference Systems\nA gentle Introduction to GIS - Coordinate Reference Systems",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_crs.html#footnotes",
    "href": "ct_crs.html#footnotes",
    "title": "4  Projections and Coordinate Reference Systems",
    "section": "",
    "text": "Video Credit - Vox, Terms of Licence Use↩︎\nhttps://en.wikipedia.org/wiki/Web_Mercator_projection↩︎\nBy Jakub Nowosad - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=73955926↩︎\nDjexplo, CC0, via Wikimedia Commons↩︎\nDjexplo, CC0, via Wikimedia Commons↩︎\nHiggins, Hannah B. The Grid Book. Cambridge, Massachusetts: MIT Press, 2009. ISBN 9780262512404 p.94. “Embroiled in controversy from the start, the map is nonetheless widely used in the British school system and is promoted by the United Nations Educational and Scientific Cultural Organization (UNESCO) because of its ability to communicate visually the actual relative sizes of the various regions of the planet.”, via Wikipedia - https://en.wikipedia.org/wiki/Gall%E2%80%93Peters_projection↩︎\nhttps://en.wikipedia.org/wiki/Winkel_tripel_projection↩︎",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Projections and Coordinate Reference Systems</span>"
    ]
  },
  {
    "objectID": "ct_filetypes.html",
    "href": "ct_filetypes.html",
    "title": "5  Geographic Data Filetypes",
    "section": "",
    "text": "When working with geometry filetypes, they can define the boundaries of an area by storing a series of latitude and longitude pairs within them. This defines a polygon.",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geographic Data Filetypes</span>"
    ]
  },
  {
    "objectID": "the_importance_of_standardisation.html",
    "href": "the_importance_of_standardisation.html",
    "title": "6  Standardisation",
    "section": "",
    "text": "We might initially work with a dataset that hasn’t been standardised.\nWhy might this be a problem?\nPatterns may be an artefact of population\nAreas with more people may just have higher values - but it may not be unusual given the number of people.\nBe careful with your interpretation!\nYou could get around this in a few ways depending on your dataset.\n\nYou could adjust by the size of an area - say, looking at the number of incidents per square kilometre\nYou could provide a rate per 1,000 occupants\nYou could provide a % of the total occupants\n\nEstimates of LSOA populations can be found online.\nUsing this information within SQL, Excel or (ideally) Python can help you to construct the most representative dataset and ensure you are not coming to incorrect conclusions.",
    "crumbs": [
      "Part 1 - Geographic Concepts and Terms",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Standardisation</span>"
    ]
  },
  {
    "objectID": "introduction_mapping_with_qgis.html",
    "href": "introduction_mapping_with_qgis.html",
    "title": "7  Mapping in QGIS",
    "section": "",
    "text": "8 References",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Mapping in QGIS</span>"
    ]
  },
  {
    "objectID": "introduction_mapping_with_qgis.html#footnotes",
    "href": "introduction_mapping_with_qgis.html#footnotes",
    "title": "7  Mapping in QGIS",
    "section": "",
    "text": "Ordnance Survey↩︎",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Mapping in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_setup.html",
    "href": "qgis_setup.html",
    "title": "8  Getting QGIS Ready to Use",
    "section": "",
    "text": "9.3 Selecting panels\nWhen you open up QGIS for the first time, a few of the different panels you will need to use are hidden by default.\nLet’s make sure we all have the same tools available\nClick “View” → “Panels”\nMake sure - “Browser”, - “Layer Styling” - and “Layers” all have a tick next to them\nNow our QGIS should look a bit like this, with the panels highlighted in orange (browser, layer styling and layers) all visible on the screen.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Getting QGIS Ready to Use</span>"
    ]
  },
  {
    "objectID": "qgis_setup.html#device-requirements",
    "href": "qgis_setup.html#device-requirements",
    "title": "8  Getting QGIS Ready to Use",
    "section": "9.1 Device Requirements",
    "text": "9.1 Device Requirements\nTo install QGIS, you will need a laptop or desktop computer running Windows, MacOS, or Linux.\nYou will not be able to install the software on a phone or tablet! While versions exist for these devices, they are aimed more at conducting fieldwork than doing the sort of task we’ll be covering in this course.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Getting QGIS Ready to Use</span>"
    ]
  },
  {
    "objectID": "qgis_setup.html#installing-qgis-1",
    "href": "qgis_setup.html#installing-qgis-1",
    "title": "8  Getting QGIS Ready to Use",
    "section": "9.2 Installing QGIS",
    "text": "9.2 Installing QGIS\nQGIS is widely used across the globe, and is totally free, with the code for the program also made available.\nQGIS is used by tens of thousands of users - some statistics can be viewed here if you are interested.\nIf your organisation has had someone on the HSMA programme in the last few years, they will have been required to download QGIS, so the software may already be available in your organisation’s software centre. If so, click here to jump to the section on checking your version to ensure that the version you are running is suitable for the workshop.\nIf you are installing QGIS for the first time without using a software centre, head to this page - https://qgis.org/en/site/forusers/download.html - and click on the appropriate box for your operating system. The box may open automatically.\n\nWe would recommend going directly to this page rather than searching Google or Bing for QGIS as we know the link above is correct and you won’t redirected to a third-party download site - using the link provided above ensures you are getting the software directly from the QGIS team.\nDon’t worry if the version number doesn’t exactly match the screenshots below - it will just automatically download the most recent release, which will be fine for the course.\nMore detailed instructions for Windows are given below.\n\n9.2.1 Windows\nNote that installing the software will require administrator rights. If you are on a personal device this will not be a problem.\nIf you are installing it on your work device, please make sure you have gone through the appropriate processes with your IT department.\nClick on the green banner to download the installer.\n\nThe download will take roughly 5 to 15 minutes, depending on the speed of your internet.\nWhen the installer has downloaded, find the file in the folder you saved it to, and double click on the file.\nFollow the instructions in the window that appears to install QGIS on your device.\nWhen you reach the step below, it may appear to pause for a long time with the progress bar not filling up.\n\nIf this happens, check your windows taskbar for the following icon:\n\nThis is a pop-up for Windows user account control. You may need to click this and authorize the installer.\nThe process should then take a maximum of 10 minutes to complete.\n\nClick ‘Finish’. You should now be able to run QGIS from your start menu or an icon on your desktop.\nChecking the version of an existing QGIS install\nIf you are using an older version your organisation has approved, you may wish to check the version number.\nIf the version number is lower than 3.0, you may find the layout is a bit different to the version we use in the workshop.\nTo check the version this, open QGIS up, hover over ‘Help’ in the top menu bar, and then click ‘About’.\n\nThe top line will tell you which version of QGIS you are currently running.\n\nYou can also choose ‘Check QGIS Version’ from the same menu, but this isn’t quite as reliable!",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Getting QGIS Ready to Use</span>"
    ]
  },
  {
    "objectID": "qgis_setup.html#moving-around-qgis",
    "href": "qgis_setup.html#moving-around-qgis",
    "title": "8  Getting QGIS Ready to Use",
    "section": "9.4 Moving around QGIS",
    "text": "9.4 Moving around QGIS\n\nTo move around your maps, you will need two key tools: move (pan) and zoom.\n\nHowever, if you’re using a mouse with a scroll wheel, you can use that instead of the zoom buttons. The zoom will be centred around the point your mouse is hovering over, which can be useful for getting to a certain point quickly!\nOr on a laptop trackpad, you can “pinch” outwards to zoom out, and inwards to zoom in.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Getting QGIS Ready to Use</span>"
    ]
  },
  {
    "objectID": "qgis_setup.html#starting-a-project",
    "href": "qgis_setup.html#starting-a-project",
    "title": "8  Getting QGIS Ready to Use",
    "section": "9.5 Starting a project",
    "text": "9.5 Starting a project\nNow you will want to start a new project.\nClick “Project” → “New”\n\nNow it’s time to add our basemap - so head to the next chapter to find out how to do that.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Getting QGIS Ready to Use</span>"
    ]
  },
  {
    "objectID": "qgis_basemaps.html",
    "href": "qgis_basemaps.html",
    "title": "9  Adding a basemap in QGIS",
    "section": "",
    "text": "9.1 The simplest way to get started\nQGIS has one basemap built in - so let’s load that in first.\nLook at the ‘Browser’ panel in QGIS, which will probably be on the left-hand side of your screen.\nClick on the arrow next to ‘XYZ Tiles’\nOR\nDouble click on the phrase ‘XYZ Tiles’\nNow double click on ‘OpenStreetMap’\nYou should now be presented with a zoomed-out map of the world - if you’ve been reading this book in order, you may recognise the Mercator projection! If you’re interested, you can go back and brush up on projections in Chapter 4.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Adding a basemap in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_basemaps.html#the-simplest-way-to-get-started",
    "href": "qgis_basemaps.html#the-simplest-way-to-get-started",
    "title": "9  Adding a basemap in QGIS",
    "section": "",
    "text": "Warning\n\n\n\nIt’s important that you credit OpenStreetMap when sharing this map in any way, in accordance with its licencing terms.\nThe licencing text you need to include is this:\n© OpenStreetMap contributors, licenced as CC BY-SA\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can stop reading here and move onto Chapter 10 if you like! There you will learn about importing a dataset of points.\nHowever, if you want to use a different basemap to the default one provided by QGIS or are interested in learning about an alternate, less ‘busy’ looking basemap, then you can carry on to the sections below.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Adding a basemap in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_basemaps.html#using-different-basemap-providers",
    "href": "qgis_basemaps.html#using-different-basemap-providers",
    "title": "9  Adding a basemap in QGIS",
    "section": "9.2 Using different basemap providers",
    "text": "9.2 Using different basemap providers\nBy default, QGIS only offers OpenStreetMap basemap tiles.\nHowever, you can easily load in additional tiles.\n\n\n\n\n\n\nWarning\n\n\n\nMake sure to appropriately credit the providers of any basemap services you use when sharing your maps, even internally!\n\n\nTo add new basemaps, right click on ‘XYZ Tiles’ in the Browser and select ‘New Connection…’.\n\nHere, you can give your new map tiles any name you like.\n\nUnder the URL setting, enter one of the following URLS^https://astro-geo-gis.com/liaison/qgis-tutorials/customizing-map-tiles-in-qgis/\nGoogle Maps: http://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}\n\nGoogle Hybrid (Satellite + Roads): https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}\nMore tiles can be obtained by some careful searching! But note that many tiles will require a API key and may require payment to use, so you will likely want to stick to the default OpenStreetMaps in most cases.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Adding a basemap in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_basemaps.html#loading-in-a-basic-world-map-instead",
    "href": "qgis_basemaps.html#loading-in-a-basic-world-map-instead",
    "title": "9  Adding a basemap in QGIS",
    "section": "9.3 Loading in a basic world map instead",
    "text": "9.3 Loading in a basic world map instead\nThere are a few situations in which you might want to use the approach below instead, which will give you a nice plain basemap at the end of it, like the image below. - you want your data to be the star of the show - you don’t have an internet connection available to download the OpenStreetMap tiles - you can’t use the OpenStreetMap tiles due to licencing restrictions\n\n\n\n\n\n\n\nWarning\n\n\n\nThis method gives you a map outline that isn’t of a very high resolution - i.e. the areas don’t follow the outline of the UK precisely. It’s fine if you’re using the map at a fairly zoomed-out level, but it might not be so much use if you want to really zoom in to your county or a particular city!\n\n\nStart a new project - you can either discard the changes to your previous project if you had a go at adding the OpenStreetMap basemap in, or you can save it somewhere for later.\nLook at the very bottom of your QGIS window. Down at the bottom you should see a box that says ‘Coordinate’.\n\nNormally this will show the coordinates of the point your mouse is hovering over.\nHowever, we can click on this box and do a neat trick!\nClick into the box and get rid of the coordinates - either by highlighting them and clicking ‘del’ or backspace to delete them all at once, or by clicking somewhere in the box and using a combination of those keys to get rid of any numbers and symbols.\n\nEnter ‘world’ into this box and click the ‘enter’ or ‘return’ key on your keyboard.\n\nVoila! Suddenly you have a world map.\n\n9.3.1 Cutting out unnecessary areas\nFor a lot of people on the HSMA course, you will only be interested in displaying data for the UK - or even just one nation within the UK.\nThis world map is split into different polygons.\nIf we click on the ‘select features by area’ button on the top toolbar, we can select individual polygons.\n\nHere I’ve selected only\n\nI can select additional areas by holding ‘shift’ and selecting an additional polygon. Here I’ve done this to select Ireland too.\n\nIf I click on Ireland again with shift held down, it will be deselected. However, if I click on a selected polygon without shift held down, I will lose all my prior selections, and only the most recently clicked on polygon will be highlighted.\nBut just selecting these doesn’t do much. We can see that other areas are still visible.\nIf we head over to the layers panel, which is probably on the left of your screen, you can see that it has a layer called ‘world map’.\nWith the polygon(s) you are interested in selected, right click on the ‘world map’ layer and select ‘Save Selected Features As’.\n\nThis will bring up the following dialog box.\n\nFrom the format box, you can select any of the options, but choosing ‘GeoPackage’ or ‘GeoJSON’ is a good idea as they output a single file that can be easily transferred into other software at a later date.\nYou can then enter a file name into the box below, which will be displayed in the next step, so make it something clear and useful. Clicking the three dots to the right of this box will open a standard operating system dialog box for saving the output file - but unusually, we don’t actually really care where it’s getting saved to! So you can really save it anywhere - though perhaps you might want to reuse this as a starting point in the future for different projects, so knowing where it’s gone could be handy.\nSo why aren’t we too worried about where it’s getting saved to? It’s because we’re interested in two other key things - the tickbox that says ‘Save only selected features’ and ‘Add saved file to map’.\nMake sure those are checked, and then click ‘Ok’.\nYou’ll now see a second layer - with the name you entered in the previous step and a new randomly-chosen colour. .\n\nWe can now untick the box next to the ‘World Map’ layer - or even right click and choose ‘Remove Layer’.\n\nNow we’ll just have a nice outline of the UK to work with, which will be nice and efficient and clear for our final output.\n\n\n\n9.3.2 Styling our custom map\nWith our new layer selected - you can tell it’s selected because the name will have a grey background in the ‘Layers’ panel, and if it’s not selected you can click on the name of it in the ‘Layers’ panel - we then want to take a look at it in the Layer Styling Panel.\n\n\n\n\n\n\nTip\n\n\n\nThis panel isn’t visible by default. If you followed the setup steps in the previous chapted, this should be on the right of your screen.\nIf you didn’t, you can make it show up by clicking the “View” button in the top menu, then “Panels” and click on “Layer Styling” - this should make a tick appear next it and the panel will open up on the right side of the screen.\n\n\nTo start with, let’s change the background colour of the map.\n\nClicking on the wide bar of colour with the label ‘Color’ brings up a colour picker.\n\nWe can drag the crosshair to a nice pale green - or any colour you like!\n\nThen click on the back arrow next to ‘Select Color’, near the top of the layer styling panel, to get back to the previous screen.\nNext, you’ll notice that we originally had ‘Fill’ selected. Click on ‘Simple Fill’ instead. It should show up by default, but if it doesn’t, click on the little black arrow to the left of the word ‘Fill’.\n\nYou can see thaat now we get some extra options available to us.\nFirst, let’s get rid of the black outline by clicking the dropdown next to ‘Stroke style’ and choosing ‘No Line’.\nNext, let’s add in a background colour.\nClick on the words ‘layer rendering’ towards the bottom of the layer styling panel.\n\nNext, tick the box ‘Draw effects’ and click on the yellow star to the right to change the options.\n\nTick ‘Outer Glow’ and set the following options.\nSpread = 200 Blur radius = 0 Single Color = Blue\n\nYou now have a a nice plain UK map to work from!",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Adding a basemap in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_point_data.html",
    "href": "qgis_point_data.html",
    "title": "10  Visualising Point Data in QGIS",
    "section": "",
    "text": "11 Importing point data from a .csv file\nOur data is stored in what’s called a ‘.csv’ file\nA csv has columns of data separated by commas, like this:\naccident_index,longitude,latitude,date\nA001,-0.198224,51.486454,2023/01/01\nA002,0.105042,1.49883,2023/01/02\nA002,0.173482,51.451924,2023/01/04\nWhen we load it into a program like Excel, it turns it into a table we can read\nSo we can say that our file is a text file that is split - or ‘delimited’ - by commas\nSo we need to tell QGIS that!\nSelect ‘Layer’ → ‘Add Layer’ → ‘Add Delimited Text Layer…’\nClick on the three dots to open up the file browser\nNavigate to where your file is located.\nIt will automatically show only files that are delimited text. When you reach the file, either\nDouble click on the file OR single click on it, then click ‘Open’",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Visualising Point Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_point_data.html#setting-the-crs-of-our-data",
    "href": "qgis_point_data.html#setting-the-crs-of-our-data",
    "title": "10  Visualising Point Data in QGIS",
    "section": "11.1 Setting the CRS of our data",
    "text": "11.1 Setting the CRS of our data\nNow we need to tell it what columns to use to determine the location of each point\nClick on ‘Geometry Definition’\n\nFirst, check that it has correctly picked up the ‘latitude’ and ‘longitude’ columns from the dataset\nIf our columns are named this in our input file, it should do this automatically.\n\nNow we need to select the correct geometry CRS.\nBut how do we know what is correct?\n\n\n\n\n\n\n\nTip\n\n\n\nWhat matters here is the CRS used in the data originally.\nIf it is different to the project CRS - which is explained below - then QGIS will reproject the data you import so it matches up with the project CRS.\nIf you are unsure what CRS has been used for your data, there are a few you can try, starting at the top of this list: - EPSG:4326 - WGS 84 - EPSG:3857 - WGS 84/Pseudo-Mercator - EPSG:32630 - WGS 84 / UTN zone 30N\nIt will usually be very obvious if it’s wrong, because your data will be in totally the wrong place!\nIf it’s wrong, then delete the layer by right clicking on it in the layers tab\n\n\n\n\n\n\n\n\nClick here to read more about selecting the right CRS for your project and the data you are importing\n\n\n\n\n\nThis seems like a bit of a boring topic - but I promise you it will save you some headaches down the line!\nIt doesn’t matter if you don’t fully understand all of this section right now - but if you import some data that keeps ending up in the wrong place, just think to yourself ’could this be because of the coordinate reference system? - and then come back and read this section again!\nHowever we start our project - whether that’s by using the OpenStreetMap basemap or doing something else - then there are a few things to note about the coordinate reference system of our QGIS project.\nWe can always look at the bottom-right corner of QGIS to see the coordinate reference system being used by our project.\n\nIf we click on that, it will bring up the project properties and open the ‘CRS’ part of the properties dialog automatically, which will look something like this.\n\nNow, here I’ve already imported the OpenStreetMap basemap as shown in the step above.\nNote that here what is selected is called EPSG:3857 - also known as WGS:84 / Pseudo-Mercator.\nIf we right click on ‘OpenStreetMap’ in the XYZ tiles and scroll down a bit, we can see that this is the CRS of the OpenStreetMap ‘tileset’ too.\n\nIt’s important to know what CRS your project is using as when you come to import data from other files, it may not be using the same reference system and the data will have to be transformed to ensure that the points or areas end up in the right place at the end!\n\nBut there’s a twist…\nIf I now create a new project and look at the CRS, we can see it’s different!\n\nAnd this is due to one of the default settings in QGIS.\nIf I go to “Settings” –&gt; “Options” –&gt; “CRS and Transforms” –&gt; “CRS Handling”, then you will spot some things about how QGIS deals with CRS options by default.\n\nWhat we can see is that the project CRS will be based on the CRS of the first layer added.\nSo if we load in the OpenStreetMap basemap first when we create a new project, our projection will be EPSG:3857 - also known as WGS:84 / Pseudo-Mercator.\nIf we load in some other data first - which you might decide to do once you’ve got a few projects under your belt, or you might do if you get started and only realise afterwards that you haven’t loaded your basemap in yet - then you might find that your project is not using the CRS you were expecting!\nNow - this isn’t a problem by itself - but it can cause confusion about what CRS you should use when you try and load in additional data!\nFor example, here I’ve loaded in a dataset relating to the United Kingdom. There should be some points on the UK… but where are they?\n\nWell, the only point I can see is in the sea off the coast of Africa!\nIf I zoom a really long way in, it turns out my points did load in - but they’re not anywhere near the UK on my basemap.\n\nSo what went wrong here?\nWhen I loaded this data in, I told QGIS to use the project CRS.\nBut that’s not what QGIS is expecting!\nIt wants me to tell it what the CRS is of the data I am loading in - it already knows what the project CRS is! It just needs to know what it’s loading in so it can work out how to translate between the two.\n\n\n\n\nOnce you’ve chosen the correct CRS, click ‘add’, then click ‘close’.\n\nOnce you’ve done this, your map should look something like this:\n\n\n\n\n\n\n\nExercise 1\n\n\n\nNow we’ve got a map, let’s take a few minutes to explore some of the patterns we can see.\nTry zooming in and moving around.\nMaybe explore an area you know, or look at the layout of roads in some of the areas with more or fewer accidents than others.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Visualising Point Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_point_data.html#styling-points",
    "href": "qgis_point_data.html#styling-points",
    "title": "10  Visualising Point Data in QGIS",
    "section": "11.2 Styling points",
    "text": "11.2 Styling points\nNow we have the accidents, but there’s so many that it’s hard to tell much.\nLet’s try splitting them out by severity.\nSelect your imported layer of points - if you’re following along with the dataset, this will be called stats19_collision_2022_minimal layer - in the layer panel by clicking it.\nClick on ‘Single Symbol’ in the layer styling panel.\n\nIn the dropdown menu that appears, select ‘Categorized’\n\nYour layer styling panel should now look something like the image on the right\n\n\n\n\n\n\n\nHINT\n\n\n\nYour layer styling panel might be too narrow by default, which cuts off some rather important buttons!\nHover over the left edge of the layer styling panel until your cursor changes to this icon: &lt;–&gt;\nThen drag it to the left until it takes up about a quarter to a third of the page and shows all the buttons below.\n\n\n\nNow we want to tell it to categorize by one of the columns in our data.\nSelect ‘accident_severity’ from the list.\n\nThen click ‘Classify’.\n\nOnce clicked, our points will have different colours (maybe not these exact ones).\nYou can see the categories it has created in our layer styling panel.\n\n\n11.2.1 Hiding points\nWe can hide some of these points by clicking the checkboxes (ticks) to the left of the symbol colour in the Layer Styling panel.\n\n\n\n\n\n\n\nExercise 2\n\n\n\nTry changing the selected value and click ‘classify’ again. Explore some of the different things we have in the dataset.\nWhich work well as things to colour our points by?\nExperiment with hiding certain values by unticking them in the layer styling panel.\nHint: you will need to click ‘yes’ when it asks you if existing classes should be deleted before classification, otherwise you will end up with categories in your legend that aren’t being used.\n\n\n\n\n\n\n\nClick here to see some example answers to this step\n\n\n\n\n\n\n\n\nAccidents at 20mph vs 70mph\n\n\n\n\n\nAccidents involving 1 vehicle vs Accidents involving more than 5 vehicles\n\n\n\n\n\n\n\n\n\n11.2.2 Colour and size\nWith the layer selected, look at the layer styling panel.\nClick on one of the categorised symbols in the section with the headers ‘symbol’, ‘value’ and ‘legend’, then click on the symbol itself (marked 1. in the image below) to load a new page with options for point colour, opacity and size.\n\nNext, you can change the colour, size or opacity using the options highlighted in the box marked ‘2.’\nYou can then click the arrow marked ‘3.’ to return to the previous page.\n\nYour changes will automatically apply if the small box labelled ‘Live update’, which is next to the ‘Apply’ button at the very bottom of the layer styling panel, has a tick in it.\n\nExercise 3\nTry changing the size, colour and opacity of some points to make the important information stand out more for a chosen category of information.\nYou can also choose to hide some categories.\nThink about the story you want to try to tell with your map. What important things do you want someone who looks at your map to take away from it? How can you use size, colour and opacity to support this?\n\n\n\n\n\n\nClick here to see some example answers to this step\n\n\n\n\n\nHere, for a map where the accidents have been classified by severity, we have - Reduced opacity of less severe accidents (so full accident patterns can still be seen - we can still spot areas with more accidents overall - while making them less obvious) - Increased size of fatal accidents (so they stand out to the viewer) - Changed severe accidents to a colour more traditionally associated with ‘bad’\n\n\n\n\n:::\n\n\n\n11.2.3 Custom Markers",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Visualising Point Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_point_data.html#adding-labels-to-points",
    "href": "qgis_point_data.html#adding-labels-to-points",
    "title": "10  Visualising Point Data in QGIS",
    "section": "11.3 Adding labels to points",
    "text": "11.3 Adding labels to points\nIn addition to changing the markers, we can add labels to our points.\nNow, simple labels can be a little hard to read, especially if we have a",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Visualising Point Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_point_data.html#next-steps",
    "href": "qgis_point_data.html#next-steps",
    "title": "10  Visualising Point Data in QGIS",
    "section": "11.4 Next Steps",
    "text": "11.4 Next Steps\nFor looking at individual roads, this approach is quite useful, but often there are so many accidents happening of a given type that it’s really hard to draw any conclusions about the country more widely.\nThis is where colouring regions of the map by some sort of count is quite useful - and this is what we will cover in the next chapter.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Visualising Point Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html",
    "href": "qgis_choropleth.html",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "",
    "text": "11.1 Reminder - what’s a choropleth?\nOr, in short, something a bit like this!\nAnd the great news is that we can create these in QGIS.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#reminder---whats-a-choropleth",
    "href": "qgis_choropleth.html#reminder---whats-a-choropleth",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "",
    "text": "“A choropleth map is a type of statistical thematic map… [where] color corresponding with an aggregate summary of a geographic characteristic … such as population density or per-capita income.\n\n\nChoropleth maps provide an easy way to visualize how a variable varies across a geographic area or show the level of variability within a region.\n\n\nA heat map or isarithmic map is similar but uses regions drawn according to the pattern of the variable, rather than the a priori geographic areas of choropleth maps.”\n\n\nhttps://en.wikipedia.org/wiki/Choropleth_map",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#importing-a-premade-geodataset",
    "href": "qgis_choropleth.html#importing-a-premade-geodataset",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.2 Importing a premade geodataset",
    "text": "11.2 Importing a premade geodataset\nSometimes we are lucky enough to have access to a dataset that contains a series of boundaries - so showing where the edges of a series of LSOAs, MSOAs, counties, or some other type of boundary are - as well as giving us some counts relating to those areas.\nUnlike our point data, which came in a csv (a type of delimited text file), when we’re working with data relating to areas, we’re going to be using a vector layer.\nVector layers can come in a range of formats: .shp (Shapefile) .geojson (Geo JSON) *.gpkg (Geopackage)\n(note: you can also get point data that’s a vector layer)\nFirst, we need to tell QGIS that we want to import a vector layer.\n\nNext, we click on the three small dots next to ‘source’ in the window that pops up to get our file picker.\n\nNotice there are no geometry settings here as the CRS is set within the file! So we can just click ‘Add’\nYou will now see a number of area boundaries, but at the moment, they are all the same colour - which isn’t much use!",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#adding-colour-to-our-choropleths",
    "href": "qgis_choropleth.html#adding-colour-to-our-choropleths",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.3 Adding colour to our choropleths",
    "text": "11.3 Adding colour to our choropleths\nPreviously we were working with data that had a certain number of categories per value.\nHowever, if we take a look at the attribute table for this layer, we can see we have numeric values - so instead we want a graduated symbology.\nThis means values will be grouped together rather than having a separate category per value.\nThis is just a quick overview of the dataset in this section, opened up within QGIS. Notice that there is a row per LSOA, and some relevant counts for that LSOA stored in the later columns.\n\nNow we need to head to our layer styling panel. Where it says ‘no symbol’, click in the box and choose ‘graduated’.\n\nLike before, we need to choose the value we want to colour our areas by.\nWe’ve got quite a lot to choose from in this dataset.\nLet’s start by looking at Shoplifting.\nTo do this, we need to click on the small arrow at the far right-hand side of the ‘values’ box.\n\nOnce we’ve selected this, click the ‘classify’ button (if it does not automatically populate the white box with a series of colours and category boundaries).\nWe now have our areas coloured by the number of shoplifting incidents. What do you notice about the categories it has set up for us?",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#adjusting-category-boundaries-and-the-number-of-categories-in-qgis",
    "href": "qgis_choropleth.html#adjusting-category-boundaries-and-the-number-of-categories-in-qgis",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.4 Adjusting category boundaries and the number of categories in QGIS",
    "text": "11.4 Adjusting category boundaries and the number of categories in QGIS\n\n11.4.1 Number of categories\nFirst, let’s experiment with the number of categories and see if that helps.\nWe can change this using the arrows next to the ‘classes’ box, or by typing in the number of classes we would like.\n\nThis can produce some odd behaviour when a lot of our groups have a very low number of values in!\nWe seem to have multiple categories for ‘0’, each with a slightly different colour. That’s not ideal behaviour - though depending on your dataset, this might not occur, and the default categorisation method may work fine, in which case you can just play around with the number of classes.\n\n\n11.4.2 Categorisation type\nLet’s now try changing the classification mode.\nThis adjusts the algorithm used by QGIS to work out the size of each category and where the boundary will be.\nClick in the ‘mode’ box.\nYou can see there are several options to choose from.\nLet’s try ‘equal interval’\n\n\nThis looks very different - is this a good option?\n\nHere, while our categories now are of consistent width (i.e. the number of values they encompass is the same), due to the way the values in this dataset are distributed - with a lot of low values and only a handful of higher ones - the map is quite hard to interpret again.\nSo a small change to the mode led to a large change in our legend!",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#hiding-categories",
    "href": "qgis_choropleth.html#hiding-categories",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.5 Hiding categories",
    "text": "11.5 Hiding categories\nLike with our categorised point data, we can untick layers in the layer styling panel to just show certain categories.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#changing-the-colourscheme",
    "href": "qgis_choropleth.html#changing-the-colourscheme",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.6 Changing the Colourscheme",
    "text": "11.6 Changing the Colourscheme",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleth.html#viewing-the-distribution",
    "href": "qgis_choropleth.html#viewing-the-distribution",
    "title": "11  Creating Choropleths in QGIS - Importing Boundaries",
    "section": "11.7 Viewing the Distribution",
    "text": "11.7 Viewing the Distribution\nIf you go to ‘histogram’ and click ‘load values’, you will see the distribution of the values in the column you’re visualising, along with vertical lines showing the boundary of each category.\nThis can be really helpful for understanding the distribution of your data…\n… but sometimes, like this, it’s really hard to see!",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Creating Choropleths in QGIS - Importing Boundaries</span>"
    ]
  },
  {
    "objectID": "qgis_choropleths_joining.html",
    "href": "qgis_choropleths_joining.html",
    "title": "12  Choropleths in QGIS - Joining Data",
    "section": "",
    "text": "“But the data in my organisation isn’t just sitting around in geopackage files…”\n\n\nLoad in a shapefile, geojson or geopkg of area boundaries (e.g. MSOA or LSOA boundaries) These can be downloaded from the ONS, the government, or other organisations.\nLoad in a .csv (delimited text layer) of counts using the same level of detail (e.g. if your shapefiles are for MSOA, you’ll need MSOA-level data at this point too)\n\n\nThis time, choose ‘No geometry’ in the geometry definition section.\n\n\nRight click on the MSOA shapefile layer in the layer tab and click ‘Properties…’\n\n\n\nChoose ‘Joins’ and then the plus button\n\n\n\nTell QGIS the layer to join to (our csv layer) and the names of the columns that should match in our two datasets\n\nIn this example the names are identical, but they can be different! It just matters whether the contents will have matching data.\n\nNow, when you select the layer that contains your area boundaries and head to the layer styling panel, you will be able to select the relevant value fields when creating a choropleth from this data (i.e. when you click into the ‘values’ dropdown).",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Choropleths in QGIS - Joining Data</span>"
    ]
  },
  {
    "objectID": "qgis_filtering.html",
    "href": "qgis_filtering.html",
    "title": "13  Filtering Data in QGIS",
    "section": "",
    "text": "13.1 Working out what we have available to filter by\nTo work out what you want to filter by, it might be helpful to look at the attribute table for your layer.\nRight click on the layer in the ‘layers’ panel and choose ‘open attribute table’.\nThis will show you the full dataset within QGIS.\nHowever, while you can build a filter from within here, it’s not the easiest way.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filtering Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_filtering.html#building-a-filter",
    "href": "qgis_filtering.html#building-a-filter",
    "title": "13  Filtering Data in QGIS",
    "section": "13.2 Building a filter",
    "text": "13.2 Building a filter\nRight click on the layer you are interested in in the ‘layers’ panel and choose ‘Filter’\n\nThis will bring up a ‘Query Builder’ page\n\nTo see what values exist for a column, click the column name in the ‘Fields’ list, then choose ‘All’ to see every category.\n\nYou can then build your filter clause\nDouble click on the column name in the ‘Fields’ to add that\nThen choose an operator\nThen choose a value from the ‘Values’ box by double clicking on it\n\nYou can click ‘test’ to see how many rows will remain in your dataset once the filter has been applied\n\nWhen you’re happy, click ‘OK’ and the dataset will be filtered.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filtering Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_filtering.html#spotting-filters",
    "href": "qgis_filtering.html#spotting-filters",
    "title": "13  Filtering Data in QGIS",
    "section": "13.3 Spotting filters",
    "text": "13.3 Spotting filters\nYou can tell if a layer has been filtered by the icon at the end of its name in the filter panel.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filtering Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_filtering.html#clearing-the-filter",
    "href": "qgis_filtering.html#clearing-the-filter",
    "title": "13  Filtering Data in QGIS",
    "section": "13.4 Clearing the filter",
    "text": "13.4 Clearing the filter\nTo remove the filter, open up the Filter options again (by right clicking on the layer in the layers panel and choosing ‘Filter’), choose ‘Clear’, then ‘OK’.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filtering Data in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html",
    "href": "qgis_print_layouts.html",
    "title": "14  Print Layouts in QGIS",
    "section": "",
    "text": "14.1 Simple exports\nOn Windows, you can use the snipping tool.\nYou can also export the in-view portion of the map as either an image or a PDF",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#simple-exports",
    "href": "qgis_print_layouts.html#simple-exports",
    "title": "14  Print Layouts in QGIS",
    "section": "",
    "text": "On windows 10, use 🪟+ Shift + S to open the snipping tool.\nOn windows 11, use the prt sc key",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#print-layouts---why-bother",
    "href": "qgis_print_layouts.html#print-layouts---why-bother",
    "title": "14  Print Layouts in QGIS",
    "section": "14.2 Print Layouts - why bother?",
    "text": "14.2 Print Layouts - why bother?\nIf you want to include a title, legends, or multiple maps on one page from within QGIS, you will need to create a print layout.\nWe can build up to a map that shows multiple useful things.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#creating-a-new-print-layout",
    "href": "qgis_print_layouts.html#creating-a-new-print-layout",
    "title": "14  Print Layouts in QGIS",
    "section": "14.3 Creating a new print layout",
    "text": "14.3 Creating a new print layout\nChoose project –&gt; New print layout.\n\nYou can have multiple print layouts per map, so it’s a good idea to give it a descriptive title\n\nThe print layout will open as a new window.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#adding-in-a-map",
    "href": "qgis_print_layouts.html#adding-in-a-map",
    "title": "14  Print Layouts in QGIS",
    "section": "14.4 Adding in a map",
    "text": "14.4 Adding in a map\nFirst you will want to add a map by clicking on this icon in the list down the side.\n\nThese icons are key for moving around in your map and selecting elements of your print layout.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#legends",
    "href": "qgis_print_layouts.html#legends",
    "title": "14  Print Layouts in QGIS",
    "section": "14.5 Legends",
    "text": "14.5 Legends\nYou may next want to add a legend.\n\nLike before, draw the legend onto the canvas.\n\n\n\n\n\n\nTip\n\n\n\nWith the legend selected on the canvas, you can choose ‘Only show items from inside linked maps’ to remove any parts of the legend that don’t relate to what is shown on the screen.\n\n\n\n14.5.1 Legend titles",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#labels-and-titles",
    "href": "qgis_print_layouts.html#labels-and-titles",
    "title": "14  Print Layouts in QGIS",
    "section": "14.6 Labels and Titles",
    "text": "14.6 Labels and Titles\nYou may want to add labels or titles.\n\nThe contents has to be edited using the label box in the ‘item properties’ section.\n\nYou can adjust the font size by clicking on the ‘Font’ box inside the ‘Appearance’ section.\nOnce you have one label, you can copy and paste this to speed up creating additional labels.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#attribution",
    "href": "qgis_print_layouts.html#attribution",
    "title": "14  Print Layouts in QGIS",
    "section": "14.7 Attribution",
    "text": "14.7 Attribution\nIf using the OpenStreetMap basemap that is built into QGIS, add a label like the following to comply with the licence:\n© OpenStreetMap contributors, licenced as CC BY-SA\nIt is also good practice to acknowledge the software with a label like Created in QGIS",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#extending-your-print-layouts-further",
    "href": "qgis_print_layouts.html#extending-your-print-layouts-further",
    "title": "14  Print Layouts in QGIS",
    "section": "14.8 Extending your print layouts further",
    "text": "14.8 Extending your print layouts further\nThere are a range of additional things you can add to your print layouts, like\n\nimages (perhaps the logo of your organisation)\ntables of relevant data",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_print_layouts.html#exporting-print-layouts",
    "href": "qgis_print_layouts.html#exporting-print-layouts",
    "title": "14  Print Layouts in QGIS",
    "section": "14.9 Exporting print layouts",
    "text": "14.9 Exporting print layouts\nFrom within the print layout window, we can choose the “Layout” dropdown menu to find several different formats we can export our print layout in.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Print Layouts in QGIS</span>"
    ]
  },
  {
    "objectID": "qgis_exercises.html",
    "href": "qgis_exercises.html",
    "title": "15  Exercises - QGIS",
    "section": "",
    "text": "16 QGIS Exercise 1\nCreate a new QGIS file\nLoad in a basemap\nLoad in the STATS19 dataset (stats19_collisions_point_data_2022.csv)\nFilter to one particular police force\nCreate one (or more) layers using point data, choosing the field(s) you find interesting\nRemember that you can hide certain categories of data, change icons, add labels, filter…\n\n\n17 QGIS Exercise 2\nCreate a new QGIS file\nLoad in a basemap\nLet’s try creating some more maps for the STATS19 dataset.\nWe’re just going to use a geojson file that already has some counts per MSOA joined in. stats_19_counts_by_msoa_3857.geojson\nCreate at least one choropleth (from this file)\nTry out different filters, colour schemes and categorisation modes.\n\n\n18 QGIS Exercise 3\nCreate a new QGIS file\nLoad in a basemap\nTo account for the range in size of MSOA, we now have a new csv of data with standardised values (number of collisions per square kilometre, number of casualties per 1000 occupants).\nImport this csv as delimited data.\nImport the vector file of MSOAs\nJoin these layers together\nCreate a print layout that shows two maps side-by-side for your region.",
    "crumbs": [
      "Part 2 - Mapping in QGIS",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Exercises - QGIS</span>"
    ]
  },
  {
    "objectID": "why_python_mapping.html",
    "href": "why_python_mapping.html",
    "title": "16  Why use python for maps?",
    "section": "",
    "text": "16.1 Wrangling and prep in one place\nBy doing your data wrangling and making your final maps all in one script, it’s a lot easier to adjust the calculations that feed into your map\nYou can use all of the useful techniques you’ve already learned for Pandas to filter your datasets, create additional columns, and more…",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Why use python for maps?</span>"
    ]
  },
  {
    "objectID": "why_python_mapping.html#same-code-multiple-maps",
    "href": "why_python_mapping.html#same-code-multiple-maps",
    "title": "16  Why use python for maps?",
    "section": "16.2 Same code, multiple maps",
    "text": "16.2 Same code, multiple maps\nBy using functions or loops, you can rapidly start to make maps to show different aspects of your data (6 lines of code actually made 25 maps here)\n\nYou can also use scripts (and reporting tools like Quarto, which we will cover in a later part of the course) to create large numbers of reports for different services or areas automatically",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Why use python for maps?</span>"
    ]
  },
  {
    "objectID": "why_python_mapping.html#interactivity-for-end-users",
    "href": "why_python_mapping.html#interactivity-for-end-users",
    "title": "16  Why use python for maps?",
    "section": "16.3 Interactivity for end users",
    "text": "16.3 Interactivity for end users\nBy using Python maps, you can build them into interactive web-based tools so they will be generated on-the-fly based on combinations your users choose\n(which we cover in a later module too!)",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Why use python for maps?</span>"
    ]
  },
  {
    "objectID": "why_python_mapping.html#examples",
    "href": "why_python_mapping.html#examples",
    "title": "16  Why use python for maps?",
    "section": "16.4 Examples",
    "text": "16.4 Examples\n\n\n\n\n\n\nClick here to take a look at a great example of an interactive healthcare map",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Why use python for maps?</span>"
    ]
  },
  {
    "objectID": "why_python_mapping.html#further-reading",
    "href": "why_python_mapping.html#further-reading",
    "title": "16  Why use python for maps?",
    "section": "16.5 Further reading",
    "text": "16.5 Further reading\nNHS Digital - Principles and Visual Guidelines for Maps",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Why use python for maps?</span>"
    ]
  },
  {
    "objectID": "python_geopandas.html",
    "href": "python_geopandas.html",
    "title": "17  Working With Travel Time Data in Python - the geopandas package",
    "section": "",
    "text": "17.1 The geometry column\nEvery Geopandas dataframe has a ‘geometry’ column (even if it’s not called that).\nVarious geopandas methods will then automatically apply to that geometry column without you having to specify that.\nFor example, the .plot() method of geopandas will plot the line, point or polygon data stored in the geometry column.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Working With Travel Time Data in Python - the geopandas package</span>"
    ]
  },
  {
    "objectID": "python_geopandas.html#the-geometry-column",
    "href": "python_geopandas.html#the-geometry-column",
    "title": "17  Working With Travel Time Data in Python - the geopandas package",
    "section": "",
    "text": "A reminder - types of data",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Working With Travel Time Data in Python - the geopandas package</span>"
    ]
  },
  {
    "objectID": "python_geopandas_reading_files.html",
    "href": "python_geopandas_reading_files.html",
    "title": "18  Reading files with Geopandas",
    "section": "",
    "text": "18.1 Importing geojsons, geopackages or shape files\nWhen working with prepackaged geographic data types, they will usually be stored in the GeoJSON format, the geopackage (gpkg) format, or as a .shp file.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Reading files with Geopandas</span>"
    ]
  },
  {
    "objectID": "python_geopandas_reading_files.html#importing-geojsons-geopackages-or-shape-files",
    "href": "python_geopandas_reading_files.html#importing-geojsons-geopackages-or-shape-files",
    "title": "18  Reading files with Geopandas",
    "section": "",
    "text": "Warning\n\n\n\nShapefiles are a little more complex as they are a number of files with different extensions that all need to be distributed together - even though it’s only the file with the extension ‘.shp’ that we read in.\nGeojson and geopackages are often easier to distribute and download!\n\n\n\n18.1.1 Files stored locally\nYou can refer to a range of geographic data file types stored locally.\n\ncountries_gdf = geopandas.read_file(\"package.gpkg\")\n\n\n\n18.1.2 Files stored on the web\nYou can also directly refer to files stored on the web.\n\ndf = geopandas.read_file(\"http://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_land.geojson\")\n\n\n\n18.1.3 Zipped files\nYou can also directly refer to files stored as zip files by prefixing the file path with zip:///.\n\nstates = geopandas.read_file(\"zip:///Users/name/Downloads/cb_2017_us_state_500k.zip\")\n\nYou can read more about file imports in the geopandas documentation, which is embedded below.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Reading files with Geopandas</span>"
    ]
  },
  {
    "objectID": "python_geopandas_reading_files.html#turning-existing-data-into-a-geodataframe",
    "href": "python_geopandas_reading_files.html#turning-existing-data-into-a-geodataframe",
    "title": "18  Reading files with Geopandas",
    "section": "19.1 Turning existing data into a GeoDataFrame",
    "text": "19.1 Turning existing data into a GeoDataFrame\nHowever - a lot of the time you may be extracting data from your data warehouse and turning this into a geodataframe.\nLet’s go back to our crime dataset from the QGIS section.\n\nimport pandas as pd\n\nsw_5forces_stop_and_search_df = pd.read_csv(\"https://raw.githubusercontent.com/hsma-programme/h6_3b_advanced_qgis_mapping_python/main/h6_3b_advanced_qgis_and_mapping_in_python/example_code/sw_5forces_stop_and_search.csv\")\n\n# view the first row\nsw_5forces_stop_and_search_df.head(1)\n\n\n\n\n\n\n\n\n\nType\nDate\nPart of a policing operation\nPolicing operation\nLatitude\nLongitude\nGender\nAge range\nSelf-defined ethnicity\nOfficer-defined ethnicity\nLegislation\nObject of search\nOutcome\nOutcome linked to object of search\nRemoval of more than just outer clothing\nUnnamed: 15\n\n\n\n\n0\nPerson search\n2019-06-01T00:02:00+00:00\nNaN\nNaN\n51.496817\n-2.580971\nMale\n25-34\nWhite - English/Welsh/Scottish/Northern Irish/...\nWhite\nPolice and Criminal Evidence Act 1984 (section 1)\nArticles for use in criminal damage\nArrest\nFalse\nFalse\nNaN\n\n\n\n\n\n\n\n\nHere we’ve imported it as a csv - but if we’d extracted data from a database and saved it as pandas dataframe, the following steps would be the same!\nSo let’s just check the type first.\n\ntype(sw_5forces_stop_and_search_df)\n\npandas.core.frame.DataFrame\n\n\nFirst, we need to know what the columns that identify the geometry are.\nIn this case, they are ‘Latitude’ and ‘Longitude’\nWe can now construct a geopandas geodataframe from this .csv file.\n\nsw_5forces_stop_and_search_gdf = geopandas.GeoDataFrame(\n    sw_5forces_stop_and_search_df, # Our pandas dataframe\n    geometry = geopandas.points_from_xy(\n        sw_5forces_stop_and_search_df['Longitude'], # Our 'x' column (horizontal position of points)\n        sw_5forces_stop_and_search_df['Latitude'] # Our 'y' column (vertical position of points)\n        ),\n    crs = 'EPSG:4326' # the coordinate reference system of the data - use EPSG:4326 if you are unsure\n    )\n\nLet’s view this new object.\n\nsw_5forces_stop_and_search_gdf.head()\n\n\n\n\n\n\n\n\n\nType\nDate\nPart of a policing operation\nPolicing operation\nLatitude\nLongitude\nGender\nAge range\nSelf-defined ethnicity\nOfficer-defined ethnicity\nLegislation\nObject of search\nOutcome\nOutcome linked to object of search\nRemoval of more than just outer clothing\nUnnamed: 15\ngeometry\n\n\n\n\n0\nPerson search\n2019-06-01T00:02:00+00:00\nNaN\nNaN\n51.496817\n-2.580971\nMale\n25-34\nWhite - English/Welsh/Scottish/Northern Irish/...\nWhite\nPolice and Criminal Evidence Act 1984 (section 1)\nArticles for use in criminal damage\nArrest\nFalse\nFalse\nNaN\nPOINT (-2.58097 51.49682)\n\n\n1\nPerson search\n2019-06-01T01:15:00+00:00\nNaN\nNaN\n51.454085\n-2.599742\nMale\n25-34\nOther ethnic group - Not stated\nWhite\nMisuse of Drugs Act 1971 (section 23)\nControlled drugs\nA no further action disposal\nTrue\nFalse\nNaN\nPOINT (-2.59974 51.45408)\n\n\n2\nPerson search\n2019-06-01T01:27:00+00:00\nNaN\nNaN\n50.983714\n-3.219592\nMale\n25-34\nWhite - English/Welsh/Scottish/Northern Irish/...\nWhite\nMisuse of Drugs Act 1971 (section 23)\nControlled drugs\nA no further action disposal\nNaN\nFalse\nNaN\nPOINT (-3.21959 50.98371)\n\n\n3\nPerson search\n2019-06-01T01:27:00+00:00\nNaN\nNaN\n50.983714\n-3.219592\nMale\nover 34\nWhite - English/Welsh/Scottish/Northern Irish/...\nWhite\nMisuse of Drugs Act 1971 (section 23)\nControlled drugs\nA no further action disposal\nNaN\nFalse\nNaN\nPOINT (-3.21959 50.98371)\n\n\n4\nPerson search\n2019-06-01T01:27:00+00:00\nNaN\nNaN\n50.983714\n-3.219592\nMale\nover 34\nWhite - English/Welsh/Scottish/Northern Irish/...\nWhite\nMisuse of Drugs Act 1971 (section 23)\nControlled drugs\nA no further action disposal\nNaN\nFalse\nNaN\nPOINT (-3.21959 50.98371)\n\n\n\n\n\n\n\n\nAnd let’s view the type of object it is.\n\ntype(sw_5forces_stop_and_search_gdf)\n\ngeopandas.geodataframe.GeoDataFrame",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Reading files with Geopandas</span>"
    ]
  },
  {
    "objectID": "python_geopandas_reading_files.html#joining-area-data-to-boundary-data",
    "href": "python_geopandas_reading_files.html#joining-area-data-to-boundary-data",
    "title": "18  Reading files with Geopandas",
    "section": "19.2 Joining area data to boundary data",
    "text": "19.2 Joining area data to boundary data\nWe can also combine pandas dataframes with geopandas dataframes.\nWhen might we want to do this?\nImagine we have a dataset of patients who are using a particular type of service.\nWe can use pandas to count the number of patients per LSOA.\nHowever - the LSOA code alone isn’t going to allow us to plot this dataset - it doesn’t contain the geometry.\nInstead, we\n\nimport a shapefile, geoJSON or geopackage of boundaries\njoin it to our pandas dataframe using a common column (like LSOA code)\n\nIf we join our dataframe to our geodataframe, the result will be a geodataframe - so you can make use of all the useful features of geodataframes.\n\nmy_lsoa_boundary_gdf = geopandas.read_file(\"lsoa_boundaries.gpkg\")\n\nmy_count_df = pd.read_csv(“counts_by_lsoa.csv”)\n\nLet’s imagine the geodataframe has a column called ‘LSOA11CD’\nThe count dataframe has a column called ‘LSOA’\n\nmy_final_df = pd.merge(\n    left=my_lsoa_boundary_gdf,\n    right=my_count_df,\n    left_on=”LSOA11CD”\n    right_on=”LSOA”\n    how=”right”\n)\n\n\n\n\n\n\n\nWarning\n\n\n\nWe need to be careful about the order we join things in to ensure we end up with the right type of object at the end.\n\n“The stand-alone merge function will work if the GeoDataFrame is in the left argument; if a DataFrame is in the left argument and a GeoDataFrame is in the right position, the result will no longer be a GeoDataFrame.” - https://geopandas.org/en/v0.8.0/mergingdata.html”\n\nThis would result in a geodataframe:\n\nmy_final_df = pd.merge(\n    left=my_lsoa_boundary_gdf,\n    right=my_count_df,\n    left_on=”LSOA11CD”\n    right_on=”LSOA”\n    how=”right”\n    )\n\nBut this would not.\n\nmy_final_df = pd.merge(\n    left=my_count_df,\n    left=my_lsoa_boundary_gdf,\n    left_on=”LSOA”\n    right_on=”LSOA11CD”\n    how=\"left\"\n)\n\n\n\n\n\n\n\n\n\nThe ‘how’ argument\n\n\n\nThe ‘how’ argument\nIf you set how = ‘left’, all of the rows from the geodataframe will be kept, even if there is no value in your dataframe of counts\nIf you set how = ‘right’, all of the rows from the counts dataframe will be kept, even if there is no value in your geodataframe Check you have no missing values in the ‘geometry’ column after this!\nIf you set how = ‘full’, all of the rows from both dataframes will be kept - so you may end up with empty geometry in some cases and/or empty counts in others",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Reading files with Geopandas</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html",
    "href": "python_geopandas_matplotlib.html",
    "title": "19  Static Maps with Matplotlib",
    "section": "",
    "text": "19.1 Simple plots with the geopandas plot method",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#simple-plots-with-the-geopandas-plot-method",
    "href": "python_geopandas_matplotlib.html#simple-plots-with-the-geopandas-plot-method",
    "title": "19  Static Maps with Matplotlib",
    "section": "",
    "text": "19.1.1 Choropleths\nGeopandas has a great built-in method for quickly plotting your data.\nJust call .plot() on your dataframe!\n\nlsoa_2011_crime_figures_df = geopandas.read_file(\"https://github.com/hsma-programme/h6_3b_advanced_qgis_mapping_python/raw/main/h6_3b_advanced_qgis_and_mapping_in_python/example_code/lsoa_2011_sw5forces_crime_figures.gpkg\")\n\nlsoa_2011_crime_figures_df.plot()\n\n\n\n\n\n\n\n\n\n\n19.1.2 Point data\nThe .plot method works for point data too.\n\nsw_5forces_stop_and_search_df = pd.read_csv(\"https://github.com/hsma-programme/h6_3b_advanced_qgis_mapping_python/raw/main/h6_3b_advanced_qgis_and_mapping_in_python/example_code/sw_5forces_stop_and_search.csv\")\n\nsw_5forces_stop_and_search_gdf = geopandas.GeoDataFrame(\n    sw_5forces_stop_and_search_df, # Our pandas dataframe\n    geometry = geopandas.points_from_xy(\n        sw_5forces_stop_and_search_df['Longitude'], # Our 'x' column (horizontal position of points)\n        sw_5forces_stop_and_search_df['Latitude'] # Our 'y' column (vertical position of points)\n        ),\n    crs = 'EPSG:4326' # the coordinate reference system of the data - use EPSG:4326 if you are unsure\n    )\n\nsw_5forces_stop_and_search_gdf.plot()",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#colouring-maps-by-a-column",
    "href": "python_geopandas_matplotlib.html#colouring-maps-by-a-column",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.2 Colouring maps by a column",
    "text": "19.2 Colouring maps by a column\n\n19.2.1 Choropleths\nYou can also pass a column name to colour the plot by the values in that column…\nLet’s see what columns we can choose from.\n\nlsoa_2011_crime_figures_df.columns\n\nIndex(['LSOA11CD', 'LSOA11NM', 'LSOA11NMW', 'Area',\n       'sw_5forces_street_by_lsoa_Anti-social behaviour',\n       'sw_5forces_street_by_lsoa_Bicycle theft',\n       'sw_5forces_street_by_lsoa_Burglary',\n       'sw_5forces_street_by_lsoa_Criminal damage and arson',\n       'sw_5forces_street_by_lsoa_Drugs',\n       'sw_5forces_street_by_lsoa_Other crime',\n       'sw_5forces_street_by_lsoa_Other theft',\n       'sw_5forces_street_by_lsoa_Possession of weapons',\n       'sw_5forces_street_by_lsoa_Public order',\n       'sw_5forces_street_by_lsoa_Robbery',\n       'sw_5forces_street_by_lsoa_Shoplifting',\n       'sw_5forces_street_by_lsoa_Theft from the person',\n       'sw_5forces_street_by_lsoa_Vehicle crime',\n       'sw_5forces_street_by_lsoa_Violence and sexual offences',\n       'sw_5forces_street_by_lsoa_Total number crimes', 'geometry'],\n      dtype='object')\n\n\nLet’s plot the ‘other crime’ counts by LSOA.\nThough depending on your dataset, you may struggle to see the impact!\n\nlsoa_2011_crime_figures_df.plot(column=\"sw_5forces_street_by_lsoa_Other crime\")\n\n\n\n\n\n\n\n\nYou can change the column name to explore different elements of your data.\n\n\n19.2.2 Point data\nPassing in a column name to the .plot method works for point data as well!\nNote that we can pass in column= before the column name, or we can just pass it in like in the cell below.\nAs long as it is the first argument we pass in, Geopandas will recognise that it is the column we want to colour our geometry data by.\n\nsw_5forces_stop_and_search_gdf.plot(\"Gender\")",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#basemaps",
    "href": "python_geopandas_matplotlib.html#basemaps",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.3 Basemaps",
    "text": "19.3 Basemaps\nA basemap - a recognisable map behind our points - will help our viewers understand what’s going on.\nFirst, we need to import an additional library called contextily.\nThe standard alias the documentation recommends is cx\n\nimport contextily as cx\n\nLet’s add our first basemap.\n\nax = sw_5forces_stop_and_search_gdf.plot()\n\ncx.add_basemap(\n    ax, # the figure we created using our plot method\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(), # we can pull the CRS out of the geodataframe!\n    zoom=8 # zoom level\n    )\n\n\n\n\n\n\n\n\n\n19.3.1 Zoom level in basemaps\nChanging the zoom level will increase the quality of the map - but at the cost of longer load times.\nZoom level: 4\n\nax = sw_5forces_stop_and_search_gdf.plot()\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(),\n    zoom=4 # zoom level\n    )\n\n\n\n\n\n\n\n\nZoom level: 10\n\nax = sw_5forces_stop_and_search_gdf.plot()\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(),\n    zoom=10 # zoom level\n    )",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#coordinate-reference-systems-and-plots",
    "href": "python_geopandas_matplotlib.html#coordinate-reference-systems-and-plots",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.4 Coordinate reference systems and plots",
    "text": "19.4 Coordinate reference systems and plots\n\nBut why does the UK look a bit wider than usual?\nIt’s because of our old friend the CRS.\nWe used EPSG:4326 to import our data.\nNow, when we look online, we’ll see lots of recommendations to use the British National Grid - EPSG:27700 - when plotting data concerning the uk.\nLet’s first try that by changing our import statement - will this work?\n\nsw_5forces_stop_and_search_gdf_27700 = geopandas.GeoDataFrame(\n    sw_5forces_stop_and_search_df, # Our pandas dataframe\n    geometry = geopandas.points_from_xy(\n        sw_5forces_stop_and_search_df['Longitude'], # Our 'x' column (horizontal position of points)\n        sw_5forces_stop_and_search_df['Latitude'] # Our 'y' column (vertical position of points)\n        ),\n    crs = 'EPSG:27700'\n    )\n\nsw_5forces_stop_and_search_gdf_27700.plot()\n\n\n\n\n\n\n\n\nNow our new map appears a bit… sea-y.\nWhich is fine if this is a map of crimes committed by pirates, but I’m pretty sure this isn’t.\nThis is because the BNSSG (EPSG:27700) expects coordinates in Northings and Eastings - not Latitude and Longitude!\nIf our dataset contains those as columns, we can go ahead and pass those in to the .points_from_xy() column and everything will be fine.\n\nmy_gdf = geopandas.GeoDataFrame(\n    my_df, # Our pandas dataframe\n    geometry = geopandas.points_from_xy(\n        my_df['Eastings'], # Our 'x' column (horizontal position of points)\n        my_df['Northings'] # Our 'y' column (vertical position of points)\n        ),\n    crs = 'EPSG:27700' # British National Grid\n)\n\nInstead, we will need to use the to_crs() method.\n\n\n19.4.1 Changing CRS\nIf our dataset only has latitude and longitude, but we want it in Northings and Eastings (and the relevant projection too), then we need to transform our dataset.\nWe could try and look them up - but the easiest option is to transform our existing geodataframe to use a different CRS.\nWe use the .to_crs() method for this.\n\nsw_5forces_stop_and_search_gdf = sw_5forces_stop_and_search_gdf.to_crs(\"EPSG:27700\")\n\nax = sw_5forces_stop_and_search_gdf.plot()\n\ncx.add_basemap(\n    ax, # the figure we created using our plot method\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(), # we can pull the CRS out of the geodataframe!\n    zoom=8 # zoom level\n    )\n\n\n\n\n\n\n\n\nThis now looks closer to the printed maps we are used to seeing.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#legends",
    "href": "python_geopandas_matplotlib.html#legends",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.5 Legends",
    "text": "19.5 Legends\nRemember that the point colours weren’t much use before? Well, we can fix that by asking the plot method for a legend.\n\nax = sw_5forces_stop_and_search_gdf.plot(column=\"Gender\", legend=True)\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(),\n    zoom=6\n    )",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#customising-your-plots-with-matplotlib",
    "href": "python_geopandas_matplotlib.html#customising-your-plots-with-matplotlib",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.6 Customising your plots with matplotlib",
    "text": "19.6 Customising your plots with matplotlib\nNow, when we use the .plot() method, geopandas is calling on our old friend matplotlib to do the plotting.\nThe benefit of this is that we can use lots of standard matplotlib techniques to make our plots shine!\n\n19.6.1 Turning off axis labels\nFirst, let’s turn off the axis labels.\n\nax = sw_5forces_stop_and_search_gdf.plot(column=\"Gender\", legend=True)\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(),\n    zoom=6\n    )\n\n# Turn off the numbers and axis tick marks around the edge of the map\nax.axis('off')\n\n(260632.38289470828, 604153.6141031217, 52383.152460906495, 442416.8273138181)\n\n\n\n\n\n\n\n\n\n\n\n19.6.2 Adjusting Map Size\nNow, it’s a bit tricky to see much here at the moment.\nHow can we make the plot bigger?\nWe just pass the ‘figsize’ argument to the original .plot() method.\nThis is a ‘tuple’ containing two numbers.\nThe horizontal width\nThe vertical height\n\nax = sw_5forces_stop_and_search_gdf.plot(\n    column=\"Gender\",\n    legend=True,\n    figsize=(10, 10)\n    )\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf.crs.to_string(),\n    zoom=7\n    )\n\n# Turn off the numbers and axis tick marks around the edge of the map\nax.axis('off')\n\n(260632.38289470828, 604153.6141031217, 52383.152460906495, 442416.8273138181)",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#adjusting-map-extent",
    "href": "python_geopandas_matplotlib.html#adjusting-map-extent",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.7 Adjusting map extent",
    "text": "19.7 Adjusting map extent\nIf we look really really closely, it looks like some areas of this map might not be purple…\n\nax = lsoa_2011_crime_figures_df.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True\n    )\n\n\n\n\n\n\n\n\n\n19.7.1 Zooming\nBy using the matplotlib methods for setting the x and y axis limits, we can zoom our map in to a particular region.\nIt’s helpful to start off with the axis ticks visible so you can work out the range you need to set.\nNote that the legend extends beyond what we’re seeing in this section of the map - it’s still based on this dataframe!\nIf this was a problem, we would filter the dataframe instead.\n\nax = lsoa_2011_crime_figures_df.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True\n    )\n\nax.set_xlim(285000,300000)\n\n(285000.0, 300000.0)\n\nax.set_ylim(85000,100000)\n\n(85000.0, 100000.0)\n\n\n\n\n\n\n\n\n\n\n\n19.7.2 Adjusting map extent (filtering a dataframe by coordinates)\nHere, we’ve used the same coordinates but applied it directly to the dataframe.\nOur legend and colourschemes are not based on the maximum values in the area of interest - not the whole dataset.\nBut notice we’ve lost the surrounding LSOAs that don’t intersect with or exist entirely inside the box we’ve specified!\nWe need to use the cx method from Geopandas. This stands for ‘coordinate indexer’.\n\n\n\n\n\n\nWarning\n\n\n\n.cx is not related to the contextily package - they just unfortunately have the same names!\n\n\n\nxmin, xmax = 285000,300000\nymin, ymax = 85000,100000\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[xmin:xmax, ymin:ymax]\n\nax = lsoa_2011_crime_figures_df_exeter.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe could pass our limits in directly to the cx method instead - it’s just a bit easier to keep track of them externally.\n\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[285000:300000, 85000:100000]\n\nax = lsoa_2011_crime_figures_df_exeter.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True\n    )",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#opacity-transparency",
    "href": "python_geopandas_matplotlib.html#opacity-transparency",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.8 Opacity (transparency)",
    "text": "19.8 Opacity (transparency)\nIt would be quite useful to have some context on our map of exactly where this subset is.\nBut if we just overlay it, it’s not that helpful.\n(Notice that I’ve turned the zoom value right up - because we’re looking at a smaller area now, this doesn’t impact the load time so much)\n\n19.8.1 Choropleths\n\nxmin, xmax = 290000,295000\nymin, ymax = 91000,95000\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[xmin:xmax, ymin:ymax]\n\nax = lsoa_2011_crime_figures_df_exeter.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True,\n    figsize=(10,7),\n    alpha=0.4 # Add this - max is 1, values closer to 0 are more transparent\n    )\n\ncx.add_basemap(\n    ax,\n    crs=lsoa_2011_crime_figures_df_exeter.crs.to_string(),\n    zoom=13\n    )\n\nax.axis('off')\n\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n\n\n\n\n\n\n\n\n\n\n\n19.8.2 Point data\nThe command is identical for point data.\n\nxmin, xmax = 300000,350000\nymin, ymax = 100000,150000\nsw_5forces_stop_and_search_gdf_subset = sw_5forces_stop_and_search_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = sw_5forces_stop_and_search_gdf_subset.plot(\n    column=\"Gender\",\n    legend=True,\n    figsize=(10, 7),\n    cmap=\"bwr\", # Set a colourmap here\n    alpha=0.3\n    )\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf_subset.crs.to_string(),\n    zoom=12\n    )\n\nax.axis('off')\n\n(298650.7467424413, 352424.2217003847, 98242.32626640763, 152376.6682640599)",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#colourschemes",
    "href": "python_geopandas_matplotlib.html#colourschemes",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.9 Colourschemes",
    "text": "19.9 Colourschemes\nThe cmap argument allows us to change the colourscheme that will be used for the plot.\n\nxmin, xmax = 290000,295000\nymin, ymax = 91000,95000\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[xmin:xmax, ymin:ymax]\n\nax = lsoa_2011_crime_figures_df_exeter.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True,\n    figsize=(10,7),\n    cmap=\"Reds\",\n    alpha=0.7\n    )\n\ncx.add_basemap(\n    ax,\n    crs=lsoa_2011_crime_figures_df_exeter.crs.to_string(),\n    zoom=15\n    )\n\nax.axis('off')\n\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n\n\n\n\n\n\n\n\n\n\n19.9.1 Point data\nOnce again, this is the same for point data.\nWe can see the different categories a lot more clearly now!\n\nxmin, xmax = 300000,350000\nymin, ymax = 100000,150000\nsw_5forces_stop_and_search_gdf_subset = sw_5forces_stop_and_search_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = sw_5forces_stop_and_search_gdf_subset.plot(\n    column=\"Gender\",\n    legend=True,\n    figsize=(10, 7),\n    cmap=\"bwr\", # Set a colourmap here\n    alpha=0.3\n    )\n\ncx.add_basemap(\n    ax,\n    crs=sw_5forces_stop_and_search_gdf_subset.crs.to_string(),\n    zoom=12\n    )\n\nax.axis('off')\n\n(298650.7467424413, 352424.2217003847, 98242.32626640763, 152376.6682640599)\n\n\n\n\n\n\n\n\n\n\n\n19.9.2 Finding colourscheme parameters\nA full list of colourmaps can be found in the matplotlib documentation:\nhttps://matplotlib.org/stable/users/explain/colors/colormaps.html\n\nQualitative colourmaps are good for categories.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#showing-polygon-boundaries",
    "href": "python_geopandas_matplotlib.html#showing-polygon-boundaries",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.10 Showing polygon boundaries",
    "text": "19.10 Showing polygon boundaries\nWe can set the edgecolor argument in the .plot() method to make the boundaries of each LSOA more distinct in this plot.\nYou can also pass the linewidth parameter to adjust this further.\n\nxmin, xmax = 290000,295000\nymin, ymax = 91000,95000\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[xmin:xmax, ymin:ymax]\n\nax = lsoa_2011_crime_figures_df_exeter.plot(\n    column=\"sw_5forces_street_by_lsoa_Total number crimes\",\n    legend=True,\n    figsize=(10,7),\n    edgecolor='black', # Let's add an edgecolour while we're at it!\n    cmap=\"Reds\",\n    linewidth=2,\n    alpha=0.7\n    )\n\ncx.add_basemap(\n    ax,\n    crs=lsoa_2011_crime_figures_df_exeter.crs.to_string(),\n    zoom=15\n    )\n\nax.axis('off')\n\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#point-sizes",
    "href": "python_geopandas_matplotlib.html#point-sizes",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.11 Point sizes",
    "text": "19.11 Point sizes\nWe can also adjust the size of different points.\nHere is a map with the default point size set.\nWe’re going to first load in a new dataset.\n\ngp_list = pd.read_csv(\"https://github.com/hsma-programme/h6_3b_advanced_qgis_mapping_python/raw/main/h6_3b_advanced_qgis_and_mapping_in_python/example_code/gp_surgery_locations_plus_patient_list_size.csv\")\n\ngp_list_gdf = geopandas.GeoDataFrame(\n    gp_list, # Our pandas dataframe\n    geometry = geopandas.points_from_xy(\n        gp_list['result_eastings'], # Our 'x' column (horizontal position of points)\n        gp_list['result_northings'] # Our 'y' column (vertical position of points)\n        ),\n    crs = 'EPSG:27700'\n    )\n\n\n19.11.1 Adjusting all markers to the same size\nWe can adjust the markersize parameter to adjust how big each marker is.\n\nax = gp_list_gdf.plot(\n    figsize=(11, 8),\n    markersize=5,\n    alpha=0.5\n    )\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf.crs.to_string(),\n    zoom=6\n    )\n\n\n\n\n\n\n\n\n\n\n19.11.2 Adjusting point sizes by a value in a dataframe\nWe can also pass in a column to have marker sizes that relate to a particular value.\nYou may need to divide or multiply the values in that column so that the marker sizes are reasonable for your map.\n\nax = gp_list_gdf.plot(\n    figsize=(11, 8),\n    markersize=gp_list_gdf['Total List Size']/1000,\n    alpha=0.5\n    )\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf.crs.to_string(),\n    zoom=6\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIf we didn’t adjust the markersizes by a factor here, our map would be unusable!\n\nax = gp_list_gdf.plot(\n    figsize=(11, 8),\n    markersize=gp_list_gdf['Total List Size'],\n    alpha=0.5\n    )\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf.crs.to_string(),\n    zoom=6\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n19.11.3 Adding a title\nIt’s easy to add a title to the plot as well.\nWe could use a format string with this to adjust it based on another value (e.g. titles for different regions in a for loop, or including an average or summary value per map)\n\nxmin, xmax = 80000,350000\nymin, ymax = 0,150000\ngp_list_gdf_sw = gp_list_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = gp_list_gdf_sw.plot(\n    figsize=(11, 8),\n    markersize=gp_list_gdf_sw['Total List Size']/500,\n    alpha=0.8\n    )\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf_sw.crs.to_string(),\n    zoom=9\n    )\n\n# Add a title to our map\nplt.title(\"GP Practices in the South West\\nMarker Size Reflects Total Practice List Size\")\n\nax.axis('off')\n\n(77832.45, 362546.55, 3326.8999999999996, 156339.1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn matplotlib plots, use the special character\nto put a line break in your title.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#point-labels",
    "href": "python_geopandas_matplotlib.html#point-labels",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.12 Point Labels",
    "text": "19.12 Point Labels\nLabels are a little more complex - we need to use a for loop to iterate through each row in our dataframe and look at the position and text.\n\n19.12.1 Basic labels\n\nxmin, xmax = 285000,298000\nymin, ymax = 62000,69000\ngp_list_gdf_torbay = gp_list_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = gp_list_gdf_torbay.plot(\n    figsize=(11, 8),\n    markersize=gp_list_gdf_torbay['Total List Size']/100,\n    alpha=0.8\n    )\n\nfor x, y, label in zip(gp_list_gdf_torbay.geometry.x, gp_list_gdf_torbay.geometry.y, gp_list_gdf_torbay.name):\n    ax.annotate(label, xy=(x, y), xytext=(-3, -3), textcoords=\"offset points\")\n\nax.set_xlim(xmin, xmax)\n\n(285000.0, 298000.0)\n\nax.set_ylim(ymin, ymax)\n\n(62000.0, 69000.0)\n\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf_torbay.crs.to_string(),\n    zoom=14\n    )\n\nplt.title(\"GP Practices in Torbay\")\n\n\n\n\n\n\n\n\n\n\n19.12.2 Wrapping labels to reduce overlap\nThe textwrap library can help us to make better labels.\n\nimport textwrap\n\nThe textwrap.fill method wraps the labels at the number of characters (letters/spaces/numbers etc) that we specify - here, 15.\n\nxmin, xmax = 285000,298000\nymin, ymax = 62000,69000\ngp_list_gdf_torbay = gp_list_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = gp_list_gdf_torbay.plot(\n    figsize=(11, 8),\n    markersize=gp_list_gdf_torbay['Total List Size']/100,\n    alpha=0.8\n    )\n\nfor x, y, label in zip(gp_list_gdf_torbay.geometry.x, gp_list_gdf_torbay.geometry.y, gp_list_gdf_torbay.name):\n    wrapped_label = textwrap.fill(label,15).title()\n    ax.annotate(wrapped_label, xy=(x, y), xytext=(-3, -3), textcoords=\"offset points\")\n\nax.set_xlim(xmin, xmax)\n\n(285000.0, 298000.0)\n\nax.set_ylim(ymin, ymax)\n\n(62000.0, 69000.0)\n\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf_torbay.crs.to_string(),\n    zoom=14\n    )\n\nplt.title(\"GP Practices in Torbay\")\n\n\n\n\n\n\n\n\n\n\n19.12.3 Intelligent placement of labels\nWe can take this even further with the adjustText library to automatically place labels that don’t overlap each other\n\nfrom adjustText import adjust_text\n\nNote that we are importing a single function from the adjustText library with the code above.\n\nxmin, xmax = 285000,298000\nymin, ymax = 62000,69000\ngp_list_gdf_torbay = gp_list_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = gp_list_gdf_torbay.plot(\n    figsize=(14, 9),\n    markersize=gp_list_gdf_torbay['Total List Size']/100,\n    alpha=0.8\n    )\n\ntexts = []\n\nfor x, y, label in zip(gp_list_gdf_torbay.geometry.x, gp_list_gdf_torbay.geometry.y, gp_list_gdf_torbay.name):\n    wrapped_label = textwrap.fill(label,15).title()\n    texts.append(plt.text(x, y, wrapped_label))\n\n# Add a title to our map\nplt.title(\"GP Practices in Torbay\")\n\nax.set_xlim(xmin, xmax)\n\n(285000.0, 298000.0)\n\nax.set_ylim(ymin, ymax)\n\n(62000.0, 69000.0)\n\n\ncx.add_basemap(\n    ax,\n    crs=gp_list_gdf_torbay.crs.to_string(),\n    zoom=13\n    )\n\nadjust_text(\n    texts,\n    force_explode=(0.05,0.05),\n    arrowprops=dict(arrowstyle=\"-\", color='k', lw=1),\n    time_lim=5\n    )\n\n\n\n\n\n\n\n\nIt won’t always be perfect - but it can be an improvement over not using this adjustment.\nYou can tweak various parameters within your adjust_text function call to change the outcome.\n\nforce_explode affects the force with which points will be pushed away from their origin\ntime_lim changes how long it will spend trying to avoid overlap\n\nMore parameters can be found in the documentation for the adjustText library.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#subplots",
    "href": "python_geopandas_matplotlib.html#subplots",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.13 Subplots",
    "text": "19.13 Subplots\nSubplots are a powerful way to map multiple columns at once.\nIf you haven’t already, make sure you import matplotlib with the following code.\n\nimport matplotlib.pyplot as plt\n\nFirst, we set up empty subplots using this standard line of matplotlib code.\nWe set the number of rows, the number of columns, and the overall figure size.,\n\nfig, axs = plt.subplots(2, 3, figsize=(20, 15))\n\n\n\n\n\n\n\n\n\nHow can we choose what we loop over?\nThe first round through will look like this\n\nThe second time like this\n\nand so on.\n\n19.13.1 Code to create subplots for a series of columns in a dataframe\n\nxmin, xmax = 290000,295000\nymin, ymax = 91000,95000\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df.cx[xmin:xmax, ymin:ymax]\n\nlsoa_2011_crime_figures_df_exeter = lsoa_2011_crime_figures_df_exeter.rename(columns=\n    {\n        'sw_5forces_street_by_lsoa_Anti-social behaviour': 'Anti-social behaviour',\n        'sw_5forces_street_by_lsoa_Bicycle theft': 'Bicycle theft',\n        'sw_5forces_street_by_lsoa_Burglary': 'Burglary',\n        'sw_5forces_street_by_lsoa_Criminal damage and arson': 'Criminal damage and arson',\n        'sw_5forces_street_by_lsoa_Drugs': 'Drugs',\n        'sw_5forces_street_by_lsoa_Total number crimes': 'Total number crimes'\n    }\n)\n\ncols = ['Anti-social behaviour', 'Bicycle theft', 'Burglary', 'Criminal damage and arson',\n        'Drugs', 'Total number crimes']\n\nfig, axs = plt.subplots(2, 3, figsize=(20, 15))\n\nfor i, ax in enumerate(fig.axes):\n    lsoa_2011_crime_figures_df_exeter.plot(cols[i], cmap=\"RdYlGn_r\", legend=True, ax=ax)\n\n    ax.axis('off')\n\n    ax.title.set_text(cols[i])\n\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)\n&lt;Axes: &gt;\n(288890.8320499536, 297274.4809500022, 89238.48039968988, 97217.69560001476)",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_matplotlib.html#saving-maps",
    "href": "python_geopandas_matplotlib.html#saving-maps",
    "title": "19  Static Maps with Matplotlib",
    "section": "19.14 Saving maps",
    "text": "19.14 Saving maps\nWhen you’re done working on your map, you can save this to an image file (e.g. jpg, png)\nYou could even do this in a loop and use the column name to determine the filename…\n\nplt.savefig(\"bike_theft_plot.jpg\")",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Static Maps with Matplotlib</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_intro.html",
    "href": "python_geopandas_folium_intro.html",
    "title": "20  Interactive Maps - Setting Up",
    "section": "",
    "text": "20.1 Why use interactive plots?\nVery often, a static plot is a really good way to display geographic data.\nYou have total control over the output and what to highlight to your stakeholders\n… but what if they’re interested in getting a closer look at those other areas with a higher rate that we haven’t provided a zoomed-in map for?\nIn the map below, we’ve provided an inset map for one of the more dense regions, but we can see at least two more that it would be valuable to interrogate further.\nIf you are doing a single report where you have time and space to craft it around what you are seeing in the data, a static map can really help direct and drive the narrative you want to tell.\nHowever, with regular reports and dashboards, this may not work so well. Here, interactive maps can really shine by allowing your end users to explore the regions or points of interest - no matter where or how densely-packed they may be.",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Interactive Maps - Setting Up</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_intro.html#why-use-interactive-plots",
    "href": "python_geopandas_folium_intro.html#why-use-interactive-plots",
    "title": "20  Interactive Maps - Setting Up",
    "section": "",
    "text": "20.1.1 Libraries for interactive mapping\nLeaflet.js is an open-source JavaScript library for maps.\nHowever, we don’t want to have to deal with writing things in JavaScript, or have to work out how to turn the output into something that Python can understand and display.\nInstead, we use the folium Python library, which acts as a bridge between Python and Leaflet.js.\nBefore making any interactive maps, we run\n\nimport folium",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Interactive Maps - Setting Up</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_intro.html#setting-up-a-base-map",
    "href": "python_geopandas_folium_intro.html#setting-up-a-base-map",
    "title": "20  Interactive Maps - Setting Up",
    "section": "20.2 Setting up a base map",
    "text": "20.2 Setting up a base map\nWe start by importing folium\nThen we set up a base map.\nNotice we’re using lat/long to determine where the map starts.\n\n# Create the blank map object\nbike_crime_map_interactive = folium.Map(\n    location=[55, -3.5],\n    zoom_start=5.25,\n    tiles='cartodbpositron'\n    )\n\n# Display the map object\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n20.2.1 Changing the zoom\nChanging the zoom parameter affects how zoomed in we are when the map initially loads.\n\n# Create the blank map object\nbike_crime_map_interactive = folium.Map(\n    location=[55, -3.5],\n    zoom_start=8,\n    tiles='cartodbpositron'\n    )\n\n# Display the map object\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n20.2.2 Changing the starting location\nChanging either the latitude or longitude changes where we are when we load the map.\n\n# Create the blank map object\nbike_crime_map_interactive = folium.Map(\n    location=[51.5, -3.5],\n    zoom_start=8,\n    tiles='cartodbpositron'\n    )\n\n# Display the map object\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n20.2.3 Basemap tiles\nWe can adjust the look of the basemap by changing the tile argument.\n\n# Create the blank map object\nbike_crime_map_interactive = folium.Map(\n    location=[51.5, -3.5],\n    zoom_start=8,\n    tiles='OpenStreetMap'\n    )\n\n# Display the map object\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n# Create the blank map object\nbike_crime_map_interactive = folium.Map(\n    location=[51.5, -3.5],\n    zoom_start=8,\n    tiles='cartodbdark_matter'\n    )\n\n# Display the map object\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Interactive Maps - Setting Up</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_point_data.html",
    "href": "python_geopandas_folium_point_data.html",
    "title": "21  Interactive Maps - Point Data",
    "section": "",
    "text": "21.1 Custom markers",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Interactive Maps - Point Data</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_point_data.html#custom-markers",
    "href": "python_geopandas_folium_point_data.html#custom-markers",
    "title": "21  Interactive Maps - Point Data",
    "section": "",
    "text": "21.1.1 Web markers\nWe can pass in a custom marker from the fontawesome library in the for loop.\n\ngp_map_web_icon = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor coordinates in geo_df_list:\n     gp_map_web_icon = gp_map_web_icon.add_child(\n        folium.Marker(\n            location=coordinates,\n            icon=folium.Icon(icon=\"user-md\", prefix='fa', color=\"black\")\n            )\n     )\n\ngp_map_web_icon\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAs of Feb 2024, this only supports fontawesome v4 - this link will show you all available icons: https://fontawesome.com/v4/icons/\n\n\n\n\n21.1.2 Markers stored locally\nIf we want to use an icon stored on our local machine, we have to do it slightly differently.\nWhile it seems inefficient to remake the icon each time inside the loop, it won’t work otherwise!\n\ngp_map_local_icon = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor coordinates in geo_df_list:\n    custom_icon = folium.features.CustomIcon(\n        \"resources/logos/hsma_logo_transparent_background_small.png\",\n        icon_size=(48,48)\n    )\n\n    gp_map_local_icon = gp_map_local_icon.add_child(\n        folium.Marker(\n            location=coordinates,\n            icon=custom_icon\n            )\n     )\n\ngp_map_local_icon\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Interactive Maps - Point Data</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_point_data.html#tooltips",
    "href": "python_geopandas_folium_point_data.html#tooltips",
    "title": "21  Interactive Maps - Point Data",
    "section": "21.2 Tooltips",
    "text": "21.2 Tooltips\nWe can also add in tooltips - here we need to use enumerate(our_list) instead of just our_list so that we get a counter as well.\nThe first time through the loop, i will be 0. This means in the tooltip we pull out the name column (the GP surgery name) and then pull back the 0th row of the dataframe, which will correspond to the 0th point in our geo_df list.\n\n\n\n\n\n\nTip\n\n\n\nRemember - Python starts counting from 0, not 1!\n\n\nWe then repeat this for the 1st, 2nd, 3rd and so on.\nTooltips will then appear when hovering over.\n\n\n\n\n\n\nWarning\n\n\n\nWe use the .values attribute of our column to return a list of values. Accessing the values directly could cause a problem in filtered dataframes as the index will not start from 0. Using .values will ensure we always have a list that we can iterate through as expected.\n\n\n\ngp_map_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_tooltip = gp_map_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=gp_list_gdf_sw['name'].values[i]\n            )\n     )\n\ngp_map_tooltip\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n21.2.1 More complex tooltips\nWe could use an f-string to create a more complex tooltip from multiple columns of our dataframe.\n\n\n\n\n\n\nTip\n\n\n\nUse &lt;br&gt; to get a line break. It’s sort of the web equivalent of \\n.\n\n\n\ngp_map_complex_tooltip = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nfor i, coordinates in enumerate(geo_df_list):\n\n    gp_map_complex_tooltip = gp_map_complex_tooltip.add_child(\n        folium.Marker(\n            location=coordinates,\n            tooltip=f\"{gp_list_gdf_sw['name'].values[i].title()}&lt;br&gt;List Size: {gp_list_gdf_sw['Total List Size'].values[i]:.0f}\"\n            )\n     )\n\ngp_map_complex_tooltip\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Interactive Maps - Point Data</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_point_data.html#heatmaps",
    "href": "python_geopandas_folium_point_data.html#heatmaps",
    "title": "21  Interactive Maps - Point Data",
    "section": "21.3 Heatmaps",
    "text": "21.3 Heatmaps\nBy using a Folium plugin, we can create a heatmap from point data.\n\nfrom folium import plugins\n\ngp_map_heatmap = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nheatmap_layer = plugins.HeatMap(\n    geo_df_list,\n    radius=15,\n    blur=5)\n\nheatmap_layer.add_to(gp_map_heatmap)\n\n&lt;folium.plugins.heat_map.HeatMap object at 0x7f16a2865ff0&gt;\n\ngp_map_heatmap\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n21.3.1 Radius and blur\nChanging the radius and blur parameters can have a significant impact on the display.\n\nfrom folium import plugins\n\ngp_map_heatmap_2 = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nheatmap_layer = plugins.HeatMap(\n    geo_df_list,\n    radius=10,\n    blur=5)\n\nheatmap_layer.add_to(gp_map_heatmap_2)\n\n&lt;folium.plugins.heat_map.HeatMap object at 0x7f16a26dfc10&gt;\n\ngp_map_heatmap_2\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\nfrom folium import plugins\n\ngp_map_heatmap_3 = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=8,\n    tiles='openstreetmap',\n    )\n\nheatmap_layer = plugins.HeatMap(\n    geo_df_list,\n    radius=10,\n    blur=10)\n\nheatmap_layer.add_to(gp_map_heatmap_3)\n\n&lt;folium.plugins.heat_map.HeatMap object at 0x7f16a2d275b0&gt;\n\ngp_map_heatmap_3\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n21.3.2 Initial zoom with heatmaps\nAnd zooming out a long way can turn it into a complete mess regardless of your settings!\n\nfrom folium import plugins\n\ngp_map_heatmap_4 = folium.Map(\n    location=[50.7, -4.2],\n    zoom_start=5,\n    tiles='openstreetmap',\n    )\n\nheatmap_layer = plugins.HeatMap(\n    geo_df_list,\n    radius=15,\n    blur=5)\n\nheatmap_layer.add_to(gp_map_heatmap_4)\n\n&lt;folium.plugins.heat_map.HeatMap object at 0x7f16a26d35e0&gt;\n\ngp_map_heatmap_4\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Interactive Maps - Point Data</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_choropleths.html",
    "href": "python_geopandas_folium_choropleths.html",
    "title": "22  Interactive Maps - Choropleths",
    "section": "",
    "text": "22.1 Creating choropleths\nWe can also create choropleths in Folium.\nAs with point data, we start by importing Folium and creating a basemap.\nWe then create a new choropleth layer and add this to the basemap.\nimport folium\n\n#create base map\nbike_crime_map_interactive = folium.Map(\n    location=[50.71671, -3.50668],\n    zoom_start=9,\n    tiles='cartodbpositron'\n    )\n\n# create and add choropleth map\nchoropleth = folium.Choropleth(\n    geo_data=lsoa_2011_crime_figures_df_devon, # dataframe with geometry in it\n    data=lsoa_2011_crime_figures_df_devon, # dataframe with data in - may be the same dataframe or a different one\n    columns=['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'], # [key (field for geometry), field to plot]\n    key_on='feature.properties.LSOA11NM'\n    )\n\nchoropleth = choropleth.add_to(bike_crime_map_interactive)\n\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Interactive Maps - Choropleths</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_choropleths.html#creating-choropleths",
    "href": "python_geopandas_folium_choropleths.html#creating-choropleths",
    "title": "22  Interactive Maps - Choropleths",
    "section": "",
    "text": "22.1.1 Adding complexity\nWe can pass in additional arguments to the folium.Choropleth() call to tweak the display further.\nfill_colour takes a matplotlib colourmap string to change the colours used for the scale.\nfill_opacity affects how see-through (transparent) the choropleth layer is. This is a value between 0 and 1, with 1 being totally opaque and 0 being totally see-through.\nline_weight affects the thickness of the outlines around different boundaries.\nlegend_name adjusts the label attached to the legend.\nhighlight highlights the LSOA shape when mouse pointer enters it if set to True; it defaults to False.\nsmooth_factor affects how simplified the boundaries of each region will be; 0 ensures no simplification occurs.\n\n#create base map\nbike_crime_map_interactive = folium.Map(\n    location=[50.71671, -3.50668],\n    zoom_start=9,\n    tiles='cartodbpositron'\n    )\n\n# create and add choropleth map\nchoropleth = folium.Choropleth(\n    geo_data=lsoa_2011_crime_figures_df_devon, # dataframe with geometry in it\n    data=lsoa_2011_crime_figures_df_devon, # dataframe with data in - may be the same dataframe or a different one\n    columns=['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'], # [key (field for geometry), field to plot]\n    key_on='feature.properties.LSOA11NM',\n    fill_color='OrRd',\n    fill_opacity=0.4,\n    line_weight=0.3,\n    legend_name='Bicycle Thefts',\n    highlight=True, # highlight the LSOA shape when mouse pointer enters it\n    smooth_factor=0\n    )\n\nchoropleth = choropleth.add_to(bike_crime_map_interactive)\n\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Interactive Maps - Choropleths</span>"
    ]
  },
  {
    "objectID": "python_geopandas_folium_choropleths.html#tooltips",
    "href": "python_geopandas_folium_choropleths.html#tooltips",
    "title": "22  Interactive Maps - Choropleths",
    "section": "22.2 Tooltips",
    "text": "22.2 Tooltips\nSimple tooltips can be added with this code, passing in the column of interest as well as the region label:\n\nchoropleth = choropleth.geojson.add_child(\n    folium.features.GeoJsonTooltip(\n        ['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'],\n        labels=True\n        )\n)\n\nHere is the full code.\n\n#create base map\nbike_crime_map_interactive = folium.Map(\n    location=[50.71671, -3.50668],\n    zoom_start=9,\n    tiles='cartodbpositron'\n    )\n\n# create and add choropleth map\nchoropleth = folium.Choropleth(\n    geo_data=lsoa_2011_crime_figures_df_devon, # dataframe with geometry in it\n    data=lsoa_2011_crime_figures_df_devon, # dataframe with data in - may be the same dataframe or a different one\n    columns=['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'], # [key (field for geometry), field to plot]\n    key_on='feature.properties.LSOA11NM',\n    fill_color='OrRd',\n    fill_opacity=0.4,\n    line_weight=0.3,\n    legend_name='Bicycle Thefts',\n    highlight=True, # highlight the LSOA shape when mouse pointer enters it\n    smooth_factor=0\n    )\n\nchoropleth = choropleth.add_to(bike_crime_map_interactive)\n\nchoropleth = choropleth.geojson.add_child(\n    folium.features.GeoJsonTooltip(\n        ['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'],\n        labels=True\n        )\n)\n\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n22.2.1 Adding additional columns to choropleths\nBy adding additional columns to the list we pass in to the folium.features.GeoJsonTooltip() function, we can include as many additional columns as we would like in our choropleth.\nFor example:\n\nchoropleth.geojson.add_child(\n    folium.features.GeoJsonTooltip(\n        ['LSOA11NM',\n        'sw_5forces_street_by_lsoa_Bicycle theft',\n        'sw_5forces_street_by_lsoa_Total number crimes'],\n        labels=True\n        )\n)\n\nHere is the full code.\n\n#create base map\nbike_crime_map_interactive = folium.Map(\n    location=[50.71671, -3.50668],\n    zoom_start=9,\n    tiles='cartodbpositron'\n    )\n\n# create and add choropleth map\nchoropleth = folium.Choropleth(\n    geo_data=lsoa_2011_crime_figures_df_devon, # dataframe with geometry in it\n    data=lsoa_2011_crime_figures_df_devon, # dataframe with data in - may be the same dataframe or a different one\n    columns=['LSOA11NM', 'sw_5forces_street_by_lsoa_Bicycle theft'], # [key (field for geometry), field to plot]\n    key_on='feature.properties.LSOA11NM',\n    fill_color='OrRd',\n    fill_opacity=0.4,\n    line_weight=0.3,\n    legend_name='Bicycle Thefts',\n    highlight=True, # highlight the LSOA shape when mouse pointer enters it\n    smooth_factor=0\n    )\n\nchoropleth = choropleth.add_to(bike_crime_map_interactive)\n\nchoropleth = choropleth.geojson.add_child(\n    folium.features.GeoJsonTooltip(\n        ['LSOA11NM',\n        'sw_5forces_street_by_lsoa_Bicycle theft',\n        'sw_5forces_street_by_lsoa_Total number crimes'],\n        labels=True\n        )\n)\n\nbike_crime_map_interactive\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook",
    "crumbs": [
      "Part 3 - Mapping in Python",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Interactive Maps - Choropleths</span>"
    ]
  },
  {
    "objectID": "mapping_travel_times.html",
    "href": "mapping_travel_times.html",
    "title": "23  What aspects can travel times help me with?",
    "section": "",
    "text": "23.0.1 Explore equity of access across regions",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>What aspects can travel times help me with?</span>"
    ]
  },
  {
    "objectID": "mapping_travel_times.html#considerations",
    "href": "mapping_travel_times.html#considerations",
    "title": "23  What aspects can travel times help me with?",
    "section": "23.1 Considerations",
    "text": "23.1 Considerations\nNow, it’s really important - especially when considering equity - to consider what kind of transport you are interested in.\n\nCars (free-flowing traffic)\nCars (in traffic)\nPublic transport\nWalking\nCycling\n\nYou might also want to consider how travel mode might be influenced by other factors - such as deprivation or age.",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>What aspects can travel times help me with?</span>"
    ]
  },
  {
    "objectID": "mapping_travel_times.html#difficulties-with-calculating-travel-times",
    "href": "mapping_travel_times.html#difficulties-with-calculating-travel-times",
    "title": "23  What aspects can travel times help me with?",
    "section": "23.2 Difficulties with calculating travel times",
    "text": "23.2 Difficulties with calculating travel times\nHowever - calculating travel times takes computational power.\nWe’re lucky to have services like Google Maps that allow us to do this for free (to us…) when we want to get somewhere.\nBut someone, somewhere, is paying for it!\nWhen you need to do this several hundred or thousand times - across different routes and travel methods, the cost will rack up.\nThis means you will often find that you are either\n\nLimited to a small number of requests on a free tier\nLimited to making requests slowly\n\nYou will need to carefully consider how to structure your code to minimize the number of times you need to look up the data from the web service!",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>What aspects can travel times help me with?</span>"
    ]
  },
  {
    "objectID": "mtt_mapping_travel_times_python.html",
    "href": "mtt_mapping_travel_times_python.html",
    "title": "24  Visualising Travel Times in Python",
    "section": "",
    "text": "24.1 Working with precalculated travel matrices\nYou may be able to find useful datasets that other people have created of common lookups you may need to do.\nThis is the travel time from every LSOA in the country to every hospital in the country (by car, assuming there is no traffic)\nIn this dataset,\nRows = LSOA\nColumns = Postcodes of Hospital and Clinic Sites\nCell = travel time from LSOA to hospital/clinic (minutes)",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Visualising Travel Times in Python</span>"
    ]
  },
  {
    "objectID": "mtt_mapping_travel_times_python.html#working-with-precalculated-travel-matrices",
    "href": "mtt_mapping_travel_times_python.html#working-with-precalculated-travel-matrices",
    "title": "24  Visualising Travel Times in Python",
    "section": "",
    "text": "Tip\n\n\n\nYou’ll need to check whether the data is in hours, minutes or seconds! It may vary depending on the web service used and other processing.\n\n\n\n\n\n\n\n\n24.1.1 Calculating the shortest travel time\nLet’s look at an example of how to take a matrix like this and calculate the shortest travel time to a site from each LSOA.\nWe’ve been given a dataset containing postcodes of hospitals with 24-hour A&E departments within 50 miles of the centre of Birmingham.\nLet’s first import the packages we’ll be needing.\n\nimport pandas as pd\nimport geopandas\nimport matplotlib.pyplot as plt\nimport requests\nimport contextily as cx\n\n\nbirmingham_area_hospitals_df\n\n    postcode                                 name\n0    B18 7QH                        City Hospital\n1    B15 2TH  Queen Elizabeth Hospital Birmingham\n2     B9 5SS                 Heartlands Hospital \n3    B71 4HJ   Sandwell District General Hospital\n4    B75 7RR                   Good Hope Hospital\n5    WS2 9PS                       Manor Hospital\n6    DY1 2HQ               Russells Hall Hospital\n7   WV10 0QP                   New Cross Hospital\n8    B98 7UB                   Alexandra Hospital\n9   CV10 7DJ                George Eliot Hospital\n10  CV34 5BW                     Warwick Hospital\n11   CV2 2DX       University Hospital (Coventry)\n12   WR5 1DD        Worcestershire Royal Hospital\n13  ST16 3SA                    Stafford Hospital\n14   TF1 6TF              Princess Royal Hospital\n15   LE1 5WW            Leicester Royal Infirmary\n16  DE22 3NE                 Royal Derby Hospital\n17  OX16 9AL              Horton General Hospital\n18   ST4 6QG      Royal Stoke University Hospital\n19   SY3 8XQ            Royal Shrewsbury Hospital\n\n\nWe know the extent we are interested in, and need to visualise the current areas with longer journey times.\nWe’ve got a precalculated travel matrix of car times available to us, showing the distance to any hospital in the UK from any LSOA in the UK.\n\ncar_travel_time_lookup = pd.read_csv(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/travel_matrix_minutes.zip\")\n\n\n\n\n\n\n\nTip\n\n\n\nWhen distances relate to LSOAs, MSOAs or postcodes, they will often relate to the centroid of that region (the centre point).\nRemember - MSOAs and LSOAs (and even some postcodes) can cover a fairly large area. Datasets exist of population-weighted centroids, which may be more appropriate to use.\n\n\nThe first thing we’re going to do is make a new dataframe that only contains the columns for the relevant hospitals.\n\n\n\n\n\n\nWarning\n\n\n\nAlways be very careful with boundary issues\nIn this case we’ve been told to only visualise their shortest journey to any one of the hospitals in this list. But someone at the edge of the region showing a very short journey time could be just down the road from a different hospital not in our dataset!\n\n\n\ncar_travel_time_lookup_birmingham_hospitals = car_travel_time_lookup.loc[\n    # keep all of the rows\n    :,\n    # keep the LSOA column and columns for relevant hospitals\n    ['LSOA'] + birmingham_area_hospitals_df.postcode.to_list()\n    ]\n\ncar_travel_time_lookup_birmingham_hospitals.head()\n\n                   LSOA     B18 7QH  ...     ST4 6QG     SY3 8XQ\n0  Welwyn Hatfield 010F  122.066667  ...  158.966667  168.683334\n1  Welwyn Hatfield 012A  122.783334  ...  159.683334  169.400000\n2  Welwyn Hatfield 002F  123.533333  ...  160.433333  170.150000\n3  Welwyn Hatfield 002E  123.399999  ...  160.299999  170.000001\n4  Welwyn Hatfield 010A  122.100000  ...  159.000000  168.716667\n\n[5 rows x 21 columns]\n\n\nNow, we want to return the shortest travel time to any of these hospitals.\nSo what we need is the smallest value in any of the columns - except the LSOA name!\nSo first, let’s change the LSOA name to be our index.\nThis means it will be ignored when we try to look for the minimum travel time.\n\ncar_travel_time_lookup_birmingham_hospitals = car_travel_time_lookup_birmingham_hospitals.set_index('LSOA')\n\ncar_travel_time_lookup_birmingham_hospitals\n\n                         B18 7QH     B15 2TH  ...     ST4 6QG     SY3 8XQ\nLSOA                                          ...                        \nWelwyn Hatfield 010F  122.066667  129.000000  ...  158.966667  168.683334\nWelwyn Hatfield 012A  122.783334  129.716667  ...  159.683334  169.400000\nWelwyn Hatfield 002F  123.533333  130.466667  ...  160.433333  170.150000\nWelwyn Hatfield 002E  123.399999  130.316666  ...  160.299999  170.000001\nWelwyn Hatfield 010A  122.100000  129.033333  ...  159.000000  168.716667\n...                          ...         ...  ...         ...         ...\nSelby 009C            135.750000  142.783334  ...  130.416667  165.850000\nSelby 007D            139.116666  146.150001  ...  133.783334  170.050000\nSelby 007B            136.750000  143.766667  ...  133.633333  168.550000\nSelby 006A            138.550000  145.583333  ...  135.433333  170.350000\nSelby 007A            140.150000  147.166667  ...  137.033333  171.816667\n\n[32843 rows x 20 columns]\n\n\nNow we can calculate the row-wise minimum (i.e. look across the columns and find the smallest value for that row) And turn this into a new column.\n\ncar_travel_time_lookup_birmingham_hospitals['shortest'] = (\n    # axis = 1 means row-wise minimum (instead of columnwise)\n    car_travel_time_lookup_birmingham_hospitals.min(axis=1)\n)\n\ncar_travel_time_lookup_birmingham_hospitals.head()\n\n                         B18 7QH     B15 2TH  ...     SY3 8XQ   shortest\nLSOA                                          ...                       \nWelwyn Hatfield 010F  122.066667  129.000000  ...  168.683334  90.516666\nWelwyn Hatfield 012A  122.783334  129.716667  ...  169.400000  91.233333\nWelwyn Hatfield 002F  123.533333  130.466667  ...  170.150000  91.983334\nWelwyn Hatfield 002E  123.399999  130.316666  ...  170.000001  91.850000\nWelwyn Hatfield 010A  122.100000  129.033333  ...  168.716667  90.549999\n\n[5 rows x 21 columns]\n\n\nNow we need to join this to some kind of geometry - as at the moment we have the name of each LSOA, but no way of plotting them.\nWe don’t really know where they are until we import something like a geojson, geopkg or shapefile.\n\nlsoa_geojson_path = 'https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson'\n\nlsoa_boundaries = geopandas.read_file(lsoa_geojson_path)\n\nLet’s just plot this to check it’s what we’re expecting and what the CRS is.\nThis looks like it’s using the British National Grid system.\n(we can tell because the range is 0 to ~ 700,000 in each direction rather than numbers &lt; 100 if it was latitude and longitude)\n\nlsoa_boundaries.plot()\n\n\n\n\n\n\n\n\n\n\n24.1.2 Joining the travel times to geometry data\nNow it’s time to join it to the travel time data per LSOA.\nWe use the pandas merge() function.\n\n\n\n\n\n\nTip\n\n\n\nNote that we pass in the lsoa boundaries geodataframe first out of the two dataframes - this ensures the output will be a geopandas file and not get converted to a standard dataframe.\n\n\n\n\n\n\n\n\nTip\n\n\n\nSide note: we are resetting the index of our travel time dataframe so that LSOA11NM is a column, not an index (i.e. our row identifiers are 0, 1, 2, 3 etc., not the names of the LSOAs).\n\n\n\nnearest_hospital_travel_bham_gdf = pd.merge(\n    lsoa_boundaries,\n    car_travel_time_lookup_birmingham_hospitals.reset_index(),\n    left_on=\"LSOA11NM\",\n    right_on=\"LSOA\",\n    how=\"right\"\n)\n\nWe’re doing a right join, which means every row in the car_travel_time_lookup_birmingham_hospitals dataframe will be kept, even if there isn’t a match in the lsoa_boundaries file.\n\n\n\n24.1.3 Plotting the travel times\nNow let’s try plotting this!\nIt looks like the travel times are shortest around Birmingham - which makes perfect sense as we’ve only been checking against the hospitals in Birmingham!\n\nnearest_hospital_travel_bham_gdf.plot(\n    column='shortest',\n    legend=True\n    )\n\n\n\n\n\n\n\n\n\n\n24.1.4 Refining the travel time plot\n\n24.1.4.1 Adjusting the plot boundaries\nLet’s zoom in a bit so we’re not giving misleading information.\n\n\n\n\n\n\nWarning\n\n\n\nIf we just zoom, the scale of our output isn’t very helpful.\nThis is because the legend is based on the entire dataframe, which still includes those distant regions, even if they aren’t shown in the final plot.\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nax = nearest_hospital_travel_bham_gdf.plot(\n    column='shortest',\n    legend=True\n    )\n\nax.set_xlim(xmin, xmax)\n\n(370000.0, 420000.0)\n\nax.set_ylim(ymin, ymax)\n\n(250000.0, 310000.0)\n\n\n\n\n\n\n\n\n\n\n\nRemember the .cx method for filtering down to just those regions within a boundary box?\nIf we use that first, our plot becomes a lot more informative!\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True\n    )\n\n\n\n\n\n\n\n\nWould it look better with some whitespace around the edge of the map to make it clear what area we are considering?\n\n\n24.1.4.2 Extending the plot extent back out\nWe can make the matplotlib limits slightly different to the boundary box to achieve this.\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n\n(350000.0, 440000.0)\n\nax.set_ylim(ymin-20000, ymax+20000)\n\n(230000.0, 330000.0)\n\n\n\n\n\n\n\n\n\n\n\n24.1.4.3 Changing the colourschemes\nLet’s experiment with a different colourscheme.\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    legend=True,\n    cmap=\"Reds\"\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n\n(350000.0, 440000.0)\n\nax.set_ylim(ymin-20000, ymax+20000)\n\n(230000.0, 330000.0)\n\n\n\n\n\n\n\n\n\n\n\n24.1.4.4 Adding in points to show the possible destinations\nLet’s make use of the postcodes.io web API.\nWe import requests to help us interact with the API.\nWe pass a list of postcodes to the relevant web address.\n\npostcode_lookup = requests.post(\n        \"https://api.postcodes.io/postcodes\",\n        json={\"postcodes\": birmingham_area_hospitals_df['postcode'].tolist()}\n    )\n\npostcode_lookup\n\n&lt;Response [200]&gt;\n\n\nThen we turn it into a dataframe and join it to our hospital df.\n\n# label: convert_postocde_json_to_df\npostcode_lookup = pd.json_normalize(postcode_lookup.json()['result'], sep='_')\n\npostcode_lookup\n\n       query result_postcode  ...  result_codes_lau2  result_codes_pfa\n0    B18 7QH         B18 7QH  ...          E08000025         E23000014\n1    B15 2TH         B15 2TH  ...          E08000025         E23000014\n2     B9 5SS          B9 5SS  ...          E08000025         E23000014\n3    B71 4HJ         B71 4HJ  ...          E08000028         E23000014\n4    B75 7RR         B75 7RR  ...          E08000025         E23000014\n5    WS2 9PS         WS2 9PS  ...          E08000030         E23000014\n6    DY1 2HQ         DY1 2HQ  ...          E08000027         E23000014\n7   WV10 0QP        WV10 0QP  ...          E08000031         E23000014\n8    B98 7UB         B98 7UB  ...          E07000236         E23000016\n9   CV10 7DJ        CV10 7DJ  ...          E07000219         E23000017\n10  CV34 5BW        CV34 5BW  ...          E07000222         E23000017\n11   CV2 2DX         CV2 2DX  ...          E08000026         E23000014\n12   WR5 1DD         WR5 1DD  ...          E07000237         E23000016\n13  ST16 3SA        ST16 3SA  ...          E07000197         E23000015\n14   TF1 6TF         TF1 6TF  ...          E06000020         E23000016\n15   LE1 5WW         LE1 5WW  ...          E06000016         E23000021\n16  DE22 3NE        DE22 3NE  ...          E06000015         E23000018\n17  OX16 9AL        OX16 9AL  ...          E07000177         E23000029\n18   ST4 6QG         ST4 6QG  ...          E06000021         E23000015\n19   SY3 8XQ         SY3 8XQ  ...          E06000051         E23000016\n\n[20 rows x 41 columns]\n\n\n\nbirmingham_area_hospitals_df = pd.merge(\n    birmingham_area_hospitals_df,\n    postcode_lookup,\n    left_on=\"postcode\",\n    right_on=\"query\"\n)\n\nThen we’ll turn the output into a geodataframe.\nBecause our original dataset was in eastings/northings, we can use those columns from our postcodes.io lookup result, and tell geopandas that we’re using EPSG:27700\n\nbirmingham_area_hospitals_gdf = geopandas.GeoDataFrame(\n    birmingham_area_hospitals_df,\n    geometry = geopandas.points_from_xy(\n        birmingham_area_hospitals_df['result_eastings'],\n        birmingham_area_hospitals_df['result_northings']\n        ),\n    crs = 'EPSG:27700'\n    )\n\nNow we can plot the points to check the results look roughly correct.\n\nax = birmingham_area_hospitals_gdf.plot()\n\ncx.add_basemap(\n    ax,\n    crs=birmingham_area_hospitals_gdf.crs.to_string(),\n    zoom=9\n    )\n\n\n\n\n\n\n\n\nNow we can add these points to our map.\nFirst we plot the choropleth.\nBy passing the ax argument - remembering that we called our initial plot object ax - we make sure it plots these as an extra layer - not a totally new plot!\n\n# label: plot_points_and_choropleth\nxmin, xmax = 380000, 440000\nymin, ymax = 250000, 310000\n\nnearest_hospital_travel_bham_gdf_filter = nearest_hospital_travel_bham_gdf.cx[xmin:xmax, ymin:ymax]\n\nax = nearest_hospital_travel_bham_gdf_filter.plot(\n    column='shortest',\n    cmap=\"Reds\",\n    legend=True,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    alpha=0.6,\n    figsize=(12,12)\n    )\n\nax.set_xlim(xmin-20000, xmax+20000)\n\n(360000.0, 460000.0)\n\nax.set_ylim(ymin-20000, ymax+20000)\n\n(230000.0, 330000.0)\n\nhospital_points = birmingham_area_hospitals_gdf.plot(\n    ax=ax,\n    color='black',\n    markersize=50\n    )\n\ncx.add_basemap(\n    ax,\n    crs=nearest_hospital_travel_bham_gdf.crs.to_string(),\n    zoom=10\n    )\n\nplt.title(\"Travel Time (minutes - by car) to Nearest Hospitals with A&E Department\\nBirmingham Area\")\nax.axis('off')\n\n(360000.0, 460000.0, 230000.0, 330000.0)",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Visualising Travel Times in Python</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html",
    "href": "mtt_travel_time_apis.html",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "",
    "text": "25.1 the routingpy library\n“routingpy enables easy and consistent access to third-party spatial webservices to request…”\nhttps://pypi.org/project/routingpy/",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#the-routingpy-library",
    "href": "mtt_travel_time_apis.html#the-routingpy-library",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "",
    "text": "route directions The time taken from one point to another point\n\n\n\nisochrones The distance from a given point that can be reached within different periods of time\n\n\n\nor time-distance matrices The time/distance from a range of points to a range of other points\n\n\n\n\n25.1.1 Services supported by routingpy\nroutingpy currently includes support for the following services:\n\nMapbox, either Valhalla or OSRM\nOpenrouteservice\nHere Maps\nGoogle Maps\nGraphhopper\nOpenTripPlannerV2\nLocal Valhalla\nLocal OSRM",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#openrouteservice",
    "href": "mtt_travel_time_apis.html#openrouteservice",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.2 Openrouteservice",
    "text": "25.2 Openrouteservice\nThe free openrouteservice tier allows us to fetch large numbers of travel time source-destination pairs for free.\n\n\n25.2.1 Setting up an account\nYou will need to set up an account with the openrouteservice.\nNo billing details are required! If you run out of daily requests, you just won’t be able to make any more requests until it resets.\nWhen you have signed up, you will need to request a token.\nChoose ‘standard’ from the dropdown and give it any name you like - perhaps “HSMA Training Token”.\n\nFrom your dashboard you will then need your key.",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#setting-up-a-routingpy-instance",
    "href": "mtt_travel_time_apis.html#setting-up-a-routingpy-instance",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.3 Setting up a routingpy instance",
    "text": "25.3 Setting up a routingpy instance\nNow we can set up a routingpy OpenRouteService (ORS) object that we can then use.\nAPI = Application Programming Interface\nImport routingpy using the alias rp\n\nimport routingpy as rp\n\nStore your key from the dashboard as a string.\nWe’ll then create an instance of the ORS API using our API key so we can retrieve travel times.\n\nors_api_key = \"abc123myreallylongapikey\"\nors_api = rp.ORS(api_key=ors_api_key)\n\n\n25.3.1 Getting a matrix with routingpy\nWe will often want to get a travel matrix out of our calls.\nThis is the sort of thing we were using in the first half of this session - rows of locations people will travel from and columns of places they are travelling to.\nThis is the most efficient way to gather the data we want for visualising travel times - and working out the optimal configuration for service locations, like we will be doing in the next session.\n\nWe will use the matrix method of our ors_api object.\n\n\n\n\n\n\nTip\n\n\n\nWe need to pass it a series of long/lat pairs\n(yes - that IS the opposite to normal!)\n\n\n\n\n\nOur call to routingpy will look something like this.\n\nimport routingpy as rp\n\nors_api = rp.ORS(api_key=ors_api_key)\n\nexample_matrix = ors_api.matrix(\n    locations = [[-0.195439, 50.845107],\n                [-0.133654, 50.844345],\n                [-0.107633, 50.83347],\n                [-0.176522, 50.83075],\n                [-0.119614, 50.865971],\n                [-0.172591, 50.857582],\n                [-0.141603, 50.825428],\n                [-0.138366, 50.826784],\n                [-0.144071, 50.822038],\n                [-0.151026, 50.823046]],\n\n    profile='driving-car',\n\n    sources=[0, 1, 2, 3, 4, 5, 6, 7],\n\n    destinations=[8, 9]\n)\n\nThis says the first 8 lists in the list of lists we’ve passed in as our locations should be treated as sources (where someone will start travelling from)\nThe last two should be treated as destinations (where people end up)\nWe’ve said we want to pull back driving times for a car (as opposed to heavy vehicles like lorries, which may need to take a different route and will drive slower).\nAnd our output is a matrix of travel times in seconds.\n\n\n\n\n\n\nTip\n\n\n\nKeep an eye on what time unit the output from the different routing services may be in.\nOutputs from the OpenRouteService will be in seconds.",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#constructing-a-routingpy-request-from-scratch",
    "href": "mtt_travel_time_apis.html#constructing-a-routingpy-request-from-scratch",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.4 Constructing a routingpy request from scratch",
    "text": "25.4 Constructing a routingpy request from scratch\nBut if you’re constructing your list of start and end points from scratch…\n\nHow do you go about getting those start and end points from the kind of datasets you’ll have on hand?\nAnd how do you then turn the matrix into a nice reusable dataframe like the one we’ve worked with before?\n\n\n\n25.4.1 Getting midpoints for our sources\nWhat we’ll usually be starting with is a list of LSOA or MSOA objects.\nHowever, routingpy can’t use LSOA names.\nI need to have a lat/long coordinate pair for routingpy to work from…\nYou can get a csv from the ONS that contains the Northing/Easting midpoint of each LSOA.\nThe ONS like to work in Northings/Eastings (the British National Grid standard)\n\n\nlsoa_centroids = pd.read_csv(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/england_lsoa_2011_centroids.csv\")\n\n# filter lsoa centroid file to just those with 'Brighton and Hove' in the name\nbrighton_lsoas_with_coords = lsoa_centroids[lsoa_centroids[\"name\"].str.contains(\"Brighton and Hove\")]\n\nAnd this is the output we get.\nx and y are still Northings and Eastings.\nBut the ‘Geometry’ column is now in lat/long - which we can pull out when we get our list of coordinates for routingpy.\n\nSo let’s get that list for routingpy!\n\n\n\n\n\n\nTip\n\n\n\nlist(zip()) is a handy way of joining two lists into a list of tuples.\nThere’s a great explanation of zip here if you are interested: W3schools\n\n\nWe may want to also import some additional libraries at this point for our maps and dataframes.\n\nimport pandas as pd\nimport geopandas\nimport matplotlib.pyplot as plt\nimport contextily as cx\n\n\n\n\n\n\n\nClick here to view the code up to now in a code cell\n\n\n\n\n\n\nlsoa_boundaries = geopandas.read_file(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson\")\n\nlsoa_centroids = pd.read_csv(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/england_lsoa_2011_centroids.csv\")\n\n# filter lsoa centroid file to just those with 'Brighton and Hove' in the name\nbrighton_lsoas_with_coords = lsoa_centroids[lsoa_centroids[\"name\"].str.contains(\"Brighton and Hove\")]\n\n# Turn this into a geodataframe\nbrighton_lsoas_with_coords_gdf = geopandas.GeoDataFrame(\n    brighton_lsoas_with_coords,\n    geometry = geopandas.points_from_xy(\n        brighton_lsoas_with_coords['x'],\n        brighton_lsoas_with_coords['y']\n        ),\n    crs = 'EPSG:27700' # as our current dataset is in BNG (northings/eastings)\n    )\n\n# Convert to lat/long from northings/eastings\nbrighton_lsoas_with_coords_gdf = brighton_lsoas_with_coords_gdf.to_crs('EPSG:4326')\n\n\n\n\n\nbrighton_lsoas_with_coords_gdf.head()\n\n                         name       code  ...           y                   geometry\n24582  Brighton and Hove 031E  E01016944  ...  103842.343  POINT (-0.12486 50.81905)\n24584  Brighton and Hove 030B  E01016945  ...  103974.651  POINT (-0.13056 50.82033)\n24585  Brighton and Hove 031C  E01016942  ...  104013.859  POINT (-0.12589 50.82061)\n24587  Brighton and Hove 031D  E01016943  ...  104356.378  POINT (-0.12009 50.82359)\n24588  Brighton and Hove 010E  E01016940  ...  106559.960  POINT (-0.14192 50.84376)\n\n[5 rows x 5 columns]\n\n\n\nsource_coord_pairs = list(zip(\n   brighton_lsoas_with_coords_gdf.geometry.x,\n   brighton_lsoas_with_coords_gdf.geometry.y\n   ))\n\nsource_coord_pairs\n\n[(-0.12485753823882006, 50.819048361662844), (-0.13056244100324238, 50.82032983017193), (-0.12589355194632887, 50.82060753580127), (-0.12009009473097138, 50.82359460031993), (-0.1419226336322493, 50.84376216375269), (-0.13409304502020875, 50.821248647505946), (-0.1290923926268217, 50.825355308679825), (-0.12915413208995294, 50.82256816013763), (-0.06564658076883807, 50.82731305218065), (-0.0695024769329264, 50.8347318636462), (-0.059976211111144935, 50.83371488216074), (-0.12150138635379837, 50.82708101914926), (-0.1329495713758475, 50.82658850015205), (-0.09380238573178772, 50.84246429285842), (-0.18625900848163274, 50.83173641138352), (-0.11041719307402319, 50.8460760186744), (-0.18423523397145875, 50.82772977430711), (-0.12499824404508408, 50.842150940496325), (-0.1809502905047801, 50.847575173276056), (-0.12998190143087965, 50.840993772681244), (-0.16694242806106377, 50.846370039697376), (-0.12774777216725813, 50.84683643921986), (-0.17235580860764851, 50.85233110433831), (-0.13328719041625697, 50.84386834824081), (-0.17756331066974929, 50.84955116935465), (-0.11872874726801329, 50.84697681712633), (-0.16169805560774958, 50.8402143730416), (-0.1312199504612789, 50.8455493353371), (-0.17757727172317433, 50.841058880238464), (-0.10437944234132293, 50.85001672615681), (-0.18818108975876502, 50.827982021285216), (-0.11692778513528355, 50.842328834481535), (-0.18040233413328052, 50.83078925327021), (-0.10479626231873412, 50.82518809249197), (-0.11519685506058701, 50.82492870417449), (-0.1045745075649748, 50.83024530861581), (-0.12062039633327991, 50.81913927275517), (-0.11375207341006413, 50.81981626934199), (-0.17620279381881954, 50.83093615156643), (-0.1168360026433402, 50.817217346598), (-0.10660185370496056, 50.822675740443074), (-0.10654889450049333, 50.81921770717978), (-0.1253224359592905, 50.862614997857996), (-0.1341006949383844, 50.8637470936446), (-0.14395840433814644, 50.865334991000644), (-0.13262909366231845, 50.859362700395025), (-0.2218169523091122, 50.84602324144285), (-0.14938968057770885, 50.85805064205624), (-0.21891243327611368, 50.84833699101388), (-0.22569755461984312, 50.845653627240445), (-0.15071013534462616, 50.86284636948684), (-0.13961713173009138, 50.86001270650739), (-0.1277800972954319, 50.827615387488734), (-0.1281733570103867, 50.8295438896145), (-0.11767678918673502, 50.829435931206625), (-0.13065510488793108, 50.829966586206034), (-0.12314615691606148, 50.83000374006614), (-0.11854279358177934, 50.832431695722136), (-0.12324997536405718, 50.83593607100806), (-0.09004907533046928, 50.86947325784627), (-0.11210881397095855, 50.862709219996766), (-0.14607192019670698, 50.83478192989951), (-0.1400194332402897, 50.83596708448222), (-0.1377442889265768, 50.8429814450985), (-0.15043816756535106, 50.837839062076064), (-0.13614322459397413, 50.83945848371998), (-0.14084171671240953, 50.84015814748126), (-0.1398688844145735, 50.85606173061376), (-0.13636113241693637, 50.86775440644423), (-0.13738225259303458, 50.84594148578621), (-0.13836638268346113, 50.82678444028228), (-0.13976740002593266, 50.830671509590694), (-0.16523988983178853, 50.82550837839054), (-0.1541458987787279, 50.842853164516704), (-0.07127602539520848, 50.83826668958224), (-0.1470049379066287, 50.84518370787048), (-0.15710663294655672, 50.8431088280078), (-0.15507241265994365, 50.84835035770212), (-0.14512602792408524, 50.8473802039127), (-0.15860355391796555, 50.85458661919309), (-0.14719180100274945, 50.85165367327501), (-0.08226888889284063, 50.83668950364974), (-0.06490073343400923, 50.831788644975504), (-0.21067754046477774, 50.84141841897066), (-0.21332559373895793, 50.844659752151884), (-0.20912033985866324, 50.83381821430973), (-0.21488412497133563, 50.83368286705304), (-0.13658589021898626, 50.834890992293474), (-0.2207561690852315, 50.83878689101863), (-0.13180556089914922, 50.83608134639778), (-0.1276909146042563, 50.83543175901762), (-0.2167958508937541, 50.83760451122914), (-0.1826228150721126, 50.83795592893849), (-0.03314876914313422, 50.8106163637634), (-0.09747639385128438, 50.81215377012625), (-0.1538395486126238, 50.82369601528257), (-0.15102553259903334, 50.82304610152032), (-0.14407110422243075, 50.82203777681994), (-0.1498098597853527, 50.82613760910196), (-0.14923588240998484, 50.82846975142959), (-0.15201365161116284, 50.82732802479011), (-0.0414115135472561, 50.80835103080172), (-0.05018363226526975, 50.80459403277461), (-0.19929997052537266, 50.84648434983594), (-0.19362474649421155, 50.84811057116212), (-0.18919111627132676, 50.84810596589646), (-0.2027911637068509, 50.85113061699807), (-0.19667231146543004, 50.85253880137066), (-0.20109216750445794, 50.837787636953465), (-0.20007399386610988, 50.84101644942148), (-0.1235595937846924, 50.8334577846224), (-0.18860295777704653, 50.84370153729166), (-0.20145524120533262, 50.83379028804791), (-0.22494475331372493, 50.85439772552727), (-0.18737808391420763, 50.83533997516628), (-0.09689997606037115, 50.85645725742448), (-0.19289785984690608, 50.829743640978904), (-0.10502126697851809, 50.855039142997335), (-0.20607731873540647, 50.83103878204193), (-0.12045162915958503, 50.83900523613201), (-0.19402011405488123, 50.834791752779175), (-0.11572816373268986, 50.83919950975929), (-0.19984255061159545, 50.83031251299731), (-0.10861409970949898, 50.83964576640172), (-0.18052998912682677, 50.83371232148406), (-0.10300706900458345, 50.8413040862398), (-0.18087222834260502, 50.835218432648546), (-0.22804642218966026, 50.85090148176861), (-0.16749696305231418, 50.85875352556211), (-0.2125704583424967, 50.848689873904426), (-0.15958602593600418, 50.860218296290725), (-0.1522095361040432, 50.83091175861888), (-0.15712269909513552, 50.82863707305795), (-0.16185567328040282, 50.83158202772631), (-0.1536076433241225, 50.83295041951072), (-0.17409365307199323, 50.833107709797915), (-0.17118678987193864, 50.83388974720125), (-0.1615981234090788, 50.834367074501536), (-0.16757520950966337, 50.83205311227117), (-0.16897371372585, 50.8366789880835), (-0.19442343822678076, 50.84212541092397), (-0.13075822516255037, 50.83371069624895), (-0.14508837802001426, 50.830545916493584), (-0.13627164976828943, 50.831433871997056), (-0.06930394672138267, 50.81603184836857), (-0.1086372179189491, 50.81650429326761), (-0.038047624123997176, 50.803033758905315), (-0.14480656160477587, 50.828193057007276), (-0.14160291691485832, 50.82542830359792), (-0.168009968317264, 50.82877126910706), (-0.1773142548216743, 50.826228459697255), (-0.15665452413268832, 50.82639904292135), (-0.17154629986708017, 50.82938260986213), (-0.1598564230473934, 50.82675855881046), (-0.1635688622682595, 50.82799041870145), (-0.15681699404823815, 50.82413221338321), (-0.1606505763941083, 50.824573930908855), (-0.17434501313128775, 50.826482755868454), (-0.1698931054952474, 50.825644796237015), (-0.12429761878745428, 50.8323333636199), (-0.10617957465183359, 50.829518888937386), (-0.18876303149867757, 50.85162688392382), (-0.14765029084568077, 50.83373193254114), (-0.23091080420813107, 50.8536760009853), (-0.05824225196323413, 50.80743951288308)]\n\n\nThis gives us a list of tuples.\nBut we want a list of lists…\nSo let’s just quickly convert that with a list comprehension.\n\nsource_coord_pairs_list = [list(coord_tuple) for coord_tuple in source_coord_pairs]\nsource_coord_pairs_list\n\n[[-0.12485753823882006, 50.819048361662844], [-0.13056244100324238, 50.82032983017193], [-0.12589355194632887, 50.82060753580127], [-0.12009009473097138, 50.82359460031993], [-0.1419226336322493, 50.84376216375269], [-0.13409304502020875, 50.821248647505946], [-0.1290923926268217, 50.825355308679825], [-0.12915413208995294, 50.82256816013763], [-0.06564658076883807, 50.82731305218065], [-0.0695024769329264, 50.8347318636462], [-0.059976211111144935, 50.83371488216074], [-0.12150138635379837, 50.82708101914926], [-0.1329495713758475, 50.82658850015205], [-0.09380238573178772, 50.84246429285842], [-0.18625900848163274, 50.83173641138352], [-0.11041719307402319, 50.8460760186744], [-0.18423523397145875, 50.82772977430711], [-0.12499824404508408, 50.842150940496325], [-0.1809502905047801, 50.847575173276056], [-0.12998190143087965, 50.840993772681244], [-0.16694242806106377, 50.846370039697376], [-0.12774777216725813, 50.84683643921986], [-0.17235580860764851, 50.85233110433831], [-0.13328719041625697, 50.84386834824081], [-0.17756331066974929, 50.84955116935465], [-0.11872874726801329, 50.84697681712633], [-0.16169805560774958, 50.8402143730416], [-0.1312199504612789, 50.8455493353371], [-0.17757727172317433, 50.841058880238464], [-0.10437944234132293, 50.85001672615681], [-0.18818108975876502, 50.827982021285216], [-0.11692778513528355, 50.842328834481535], [-0.18040233413328052, 50.83078925327021], [-0.10479626231873412, 50.82518809249197], [-0.11519685506058701, 50.82492870417449], [-0.1045745075649748, 50.83024530861581], [-0.12062039633327991, 50.81913927275517], [-0.11375207341006413, 50.81981626934199], [-0.17620279381881954, 50.83093615156643], [-0.1168360026433402, 50.817217346598], [-0.10660185370496056, 50.822675740443074], [-0.10654889450049333, 50.81921770717978], [-0.1253224359592905, 50.862614997857996], [-0.1341006949383844, 50.8637470936446], [-0.14395840433814644, 50.865334991000644], [-0.13262909366231845, 50.859362700395025], [-0.2218169523091122, 50.84602324144285], [-0.14938968057770885, 50.85805064205624], [-0.21891243327611368, 50.84833699101388], [-0.22569755461984312, 50.845653627240445], [-0.15071013534462616, 50.86284636948684], [-0.13961713173009138, 50.86001270650739], [-0.1277800972954319, 50.827615387488734], [-0.1281733570103867, 50.8295438896145], [-0.11767678918673502, 50.829435931206625], [-0.13065510488793108, 50.829966586206034], [-0.12314615691606148, 50.83000374006614], [-0.11854279358177934, 50.832431695722136], [-0.12324997536405718, 50.83593607100806], [-0.09004907533046928, 50.86947325784627], [-0.11210881397095855, 50.862709219996766], [-0.14607192019670698, 50.83478192989951], [-0.1400194332402897, 50.83596708448222], [-0.1377442889265768, 50.8429814450985], [-0.15043816756535106, 50.837839062076064], [-0.13614322459397413, 50.83945848371998], [-0.14084171671240953, 50.84015814748126], [-0.1398688844145735, 50.85606173061376], [-0.13636113241693637, 50.86775440644423], [-0.13738225259303458, 50.84594148578621], [-0.13836638268346113, 50.82678444028228], [-0.13976740002593266, 50.830671509590694], [-0.16523988983178853, 50.82550837839054], [-0.1541458987787279, 50.842853164516704], [-0.07127602539520848, 50.83826668958224], [-0.1470049379066287, 50.84518370787048], [-0.15710663294655672, 50.8431088280078], [-0.15507241265994365, 50.84835035770212], [-0.14512602792408524, 50.8473802039127], [-0.15860355391796555, 50.85458661919309], [-0.14719180100274945, 50.85165367327501], [-0.08226888889284063, 50.83668950364974], [-0.06490073343400923, 50.831788644975504], [-0.21067754046477774, 50.84141841897066], [-0.21332559373895793, 50.844659752151884], [-0.20912033985866324, 50.83381821430973], [-0.21488412497133563, 50.83368286705304], [-0.13658589021898626, 50.834890992293474], [-0.2207561690852315, 50.83878689101863], [-0.13180556089914922, 50.83608134639778], [-0.1276909146042563, 50.83543175901762], [-0.2167958508937541, 50.83760451122914], [-0.1826228150721126, 50.83795592893849], [-0.03314876914313422, 50.8106163637634], [-0.09747639385128438, 50.81215377012625], [-0.1538395486126238, 50.82369601528257], [-0.15102553259903334, 50.82304610152032], [-0.14407110422243075, 50.82203777681994], [-0.1498098597853527, 50.82613760910196], [-0.14923588240998484, 50.82846975142959], [-0.15201365161116284, 50.82732802479011], [-0.0414115135472561, 50.80835103080172], [-0.05018363226526975, 50.80459403277461], [-0.19929997052537266, 50.84648434983594], [-0.19362474649421155, 50.84811057116212], [-0.18919111627132676, 50.84810596589646], [-0.2027911637068509, 50.85113061699807], [-0.19667231146543004, 50.85253880137066], [-0.20109216750445794, 50.837787636953465], [-0.20007399386610988, 50.84101644942148], [-0.1235595937846924, 50.8334577846224], [-0.18860295777704653, 50.84370153729166], [-0.20145524120533262, 50.83379028804791], [-0.22494475331372493, 50.85439772552727], [-0.18737808391420763, 50.83533997516628], [-0.09689997606037115, 50.85645725742448], [-0.19289785984690608, 50.829743640978904], [-0.10502126697851809, 50.855039142997335], [-0.20607731873540647, 50.83103878204193], [-0.12045162915958503, 50.83900523613201], [-0.19402011405488123, 50.834791752779175], [-0.11572816373268986, 50.83919950975929], [-0.19984255061159545, 50.83031251299731], [-0.10861409970949898, 50.83964576640172], [-0.18052998912682677, 50.83371232148406], [-0.10300706900458345, 50.8413040862398], [-0.18087222834260502, 50.835218432648546], [-0.22804642218966026, 50.85090148176861], [-0.16749696305231418, 50.85875352556211], [-0.2125704583424967, 50.848689873904426], [-0.15958602593600418, 50.860218296290725], [-0.1522095361040432, 50.83091175861888], [-0.15712269909513552, 50.82863707305795], [-0.16185567328040282, 50.83158202772631], [-0.1536076433241225, 50.83295041951072], [-0.17409365307199323, 50.833107709797915], [-0.17118678987193864, 50.83388974720125], [-0.1615981234090788, 50.834367074501536], [-0.16757520950966337, 50.83205311227117], [-0.16897371372585, 50.8366789880835], [-0.19442343822678076, 50.84212541092397], [-0.13075822516255037, 50.83371069624895], [-0.14508837802001426, 50.830545916493584], [-0.13627164976828943, 50.831433871997056], [-0.06930394672138267, 50.81603184836857], [-0.1086372179189491, 50.81650429326761], [-0.038047624123997176, 50.803033758905315], [-0.14480656160477587, 50.828193057007276], [-0.14160291691485832, 50.82542830359792], [-0.168009968317264, 50.82877126910706], [-0.1773142548216743, 50.826228459697255], [-0.15665452413268832, 50.82639904292135], [-0.17154629986708017, 50.82938260986213], [-0.1598564230473934, 50.82675855881046], [-0.1635688622682595, 50.82799041870145], [-0.15681699404823815, 50.82413221338321], [-0.1606505763941083, 50.824573930908855], [-0.17434501313128775, 50.826482755868454], [-0.1698931054952474, 50.825644796237015], [-0.12429761878745428, 50.8323333636199], [-0.10617957465183359, 50.829518888937386], [-0.18876303149867757, 50.85162688392382], [-0.14765029084568077, 50.83373193254114], [-0.23091080420813107, 50.8536760009853], [-0.05824225196323413, 50.80743951288308]]\n\n\n\n\n25.4.2 Site locations\nThen, I’ll want a series of site locations that I need to know the travel time to. We might have addresses or postcodes of these, but we need these in lat/long format.\nIn this case, I used Google Maps to find the Lat/Long of my sites of interest.\nIf you right click on a location, the coordinates will be given.\n\nClick on them and they will be copied to your clipboard so you can paste them into your code.\n\n\n\n\n\n\nTip\n\n\n\nIf we instead had a large number of locations in postcode format, we could use the postcodes.io API to programmatically return the Lat/Long.\n\n\nIn this case, I’ve copied my locations from Google maps and formatted them as a list of lists.\n\nlocations = [\n    [50.84510657697442, -0.19543939173180552],\n    [50.844345428338784, -0.13365357930540253],\n    [50.833469545267626, -0.10763304889918592],\n    [50.83075017843111, -0.17652193515449327],\n    [50.865971443211656, -0.11961372476967412],\n    [50.85758221272246, -0.17259077588448932]\n    ]\n\nHowever, when I copy them in, they will be in the order latitude/longitude - which is the wrong way around for Routingpy.\nI could manually swap the order of each, or I could use another list comprehension to do this automatically. This is much more scalable.\n\nlocations_long_lat = [\n    [  x[1], x[0]  ]\n    for x\n    in locations]\n\nprint(locations_long_lat)\n\n[[-0.19543939173180552, 50.84510657697442], [-0.13365357930540253, 50.844345428338784], [-0.10763304889918592, 50.833469545267626], [-0.17652193515449327, 50.83075017843111], [-0.11961372476967412, 50.865971443211656], [-0.17259077588448932, 50.85758221272246]]\n\n\nNow we just need to\n\njoin our two lists into one\nspecify which pairs are\n\nsources (where our people are)\nand which are destinations (where our people are going - the sites)\n\n\n\n\n25.4.3 Joining our source and destination lists into one\n\n# Create an empty list\nall_coordinates = []\n\n# Put our sources (our LSOA centre points) into the list\nall_coordinates.extend(source_coord_pairs_list)\n\n# Put our destinations (our potential sites) into the list\nall_coordinates.extend(locations_long_lat)\n\n\n\n25.4.4 Specifying which pairs are sources and which are destinations\n\n25.4.4.1 Sources\n\nsources_indices = [i for i in range(len(source_coord_pairs_list))]\n\nprint(sources_indices)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164]\n\n\n\n\n25.4.4.2 Destinations\n\ndestinations_indices = [i for i in\n                        range(\n                            # first number in list of indices\n                            # this will be 1 more than the number of sources (which were first in our\n                            # full list of coordinates)\n                            len(source_coord_pairs_list),\n                            # last number in list of indices (remember the last number won't\n                            # actually be included)\n                            len(all_coordinates))\n                            ]\n\nprint(destinations_indices)\n\n[165, 166, 167, 168, 169, 170]\n\n\n\n\n\n25.4.5 Make the call to the ORS API via the routingpy library\nAnd this is our final call to the API!\n\nlocation_matrix = ors_api.matrix(\n\n    locations = all_coordinates, # remember this is sources first, then destinations\n\n    profile = 'driving-car',\n\n    sources = sources_indices,\n\n    destinations = destinations_indices,\n\n    metrics=[\"distance\", \"duration\"]\n\n    )\n\n\n\n25.4.6 Exploring the travel matrix outputs\nThis is the duration output we get.\n\n\n\n25.4.7 Converting the outputs into a dataframe\nAnd then we can convert this to a dataframe like our previous matrices.\n\n\n\n\n\n\n\nClick here for a copyable code example\n\n\n\n\n\n\nbrighton_travel_matrix = pd.DataFrame(\n    location_matrix.durations,\n    columns=[f\"Site {i+1}\" for i in range(len(destinations_indices))],\n    index=brighton_lsoas_with_coords.name\n    )\n\nbrighton_travel_matrix\n\n                         Site 1   Site 2   Site 3   Site 4  Site 5  Site 6\nname                                                                      \nBrighton and Hove 031E   977.70   712.47   322.69   620.28  792.32  818.77\nBrighton and Hove 030B   935.00   660.77   343.71   577.58  740.62  767.07\nBrighton and Hove 031C   994.05   663.40   294.78   636.88  743.25  769.70\nBrighton and Hove 031D  1078.25   642.41   185.75   771.88  722.26  864.58\nBrighton and Hove 010E   694.25   205.64   407.75   619.50  284.52  469.89\n...                         ...      ...      ...      ...     ...     ...\nBrighton and Hove 025A  1089.28   714.34   280.57  1100.54  794.20  875.62\nBrighton and Hove 006D   217.98   703.21   926.92   454.12  444.53  251.57\nBrighton and Hove 024A   555.77   432.37   436.69   380.93  507.96  331.42\nBrighton and Hove 005A   571.01   883.03  1106.73   666.56  624.35  446.13\nBrighton and Hove 033D  1110.69  1020.09   586.31  1208.32  828.12  897.03\n\n[165 rows x 6 columns]\n\n\n\n\n\nWe need to create a column to calculate the shortest possible travel time to any of the locations we have retrieved data.\nNote that if the LSOA names are a column instead of an index, we will get an error as it will try to include the LSOA names when doing the minimum calculation.\nThis is why we set the LSOA names as the index in the previous step.\n\nbrighton_travel_matrix['shortest'] = brighton_travel_matrix.min(axis=1)\n\nWe then need to modify this to join it to the geographic information (our LSOA boundaries) and convert it from seconds to minutes.\n\n\n\n\n\n\nNote\n\n\n\nWe could convert the whole dataset to minutes instead by dividing all of the numeric columns in the dataframe by 60, not just a single column.\n\n\n\n\n\n\n\n\nTip\n\n\n\nRemember - the output format of the df (geodataframe or standard pandas dataframe) will be determined by the type of the dataframe in the ‘left’ position.\n\n\n\nnearest_site_travel_brighton_gdf = pd.merge(\n    left=lsoa_boundaries,\n    # We use the 'reset_index' method here to make the LSOA names a column again instead of an index\n    # This just makes it a bit easier to do the join\n    right=brighton_travel_matrix.reset_index(),\n    left_on = \"LSOA11NM\",\n    right_on = \"name\"\n)\nnearest_site_travel_brighton_gdf[\"shortest_minutes\"] = nearest_site_travel_brighton_gdf[\"shortest\"] / 60\n\nnearest_site_travel_brighton_gdf.head()\n\n     FID   LSOA11CD                LSOA11NM  ...  Site 6  shortest  shortest_minutes\n0  16356  E01016849  Brighton and Hove 026A  ...  638.60    232.54          3.875667\n1  16357  E01016850  Brighton and Hove 029A  ...  616.75    294.41          4.906833\n2  16358  E01016851  Brighton and Hove 029B  ...  601.17    268.51          4.475167\n3  16359  E01016852  Brighton and Hove 026B  ...  579.76    256.04          4.267333\n4  16360  E01016853  Brighton and Hove 026C  ...  609.58    211.12          3.518667\n\n[5 rows x 19 columns]\n\n\n\n\n25.4.8 Creating a map of the output\n\n25.4.8.1 Creating a geodataframe of our sites\nYou might want to create a geodataframe of your sites\nThis will make it easy to then plot them\n\nbrighton_sites = geopandas.GeoDataFrame(\n    [f\"Site {i+1}\" for i in range(len(destinations_indices))],\n    geometry = geopandas.points_from_xy(\n        [i[1] for i in locations],\n        [i[0] for i in locations]\n        ),\n    crs = 'EPSG:4326' # as our current dataset is in BNG (northings/eastings)\n    )\n\nbrighton_sites\n\n        0                   geometry\n0  Site 1  POINT (-0.19544 50.84511)\n1  Site 2  POINT (-0.13365 50.84435)\n2  Site 3  POINT (-0.10763 50.83347)\n3  Site 4  POINT (-0.17652 50.83075)\n4  Site 5  POINT (-0.11961 50.86597)\n5  Site 6  POINT (-0.17259 50.85758)\n\n\n\n\n25.4.8.2 Making the map\n\nnearest_site_travel_brighton_gdf[\"shortest_minutes\"] = nearest_site_travel_brighton_gdf[\"shortest\"] / 60\n\nax = nearest_site_travel_brighton_gdf.plot(\n    \"shortest_minutes\",\n    legend=True,\n    cmap=\"Blues\",\n    alpha=0.7,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    figsize=(12,6)\n    )\nhospital_points = (brighton_sites.to_crs('EPSG:27700')).plot(ax=ax, color='magenta', markersize=60)\n\ncx.add_basemap(ax, crs=nearest_site_travel_brighton_gdf.crs.to_string(), zoom=14)\n\nfor x, y, label in zip(brighton_sites.to_crs('EPSG:27700').geometry.x,\n                      brighton_sites.to_crs('EPSG:27700').geometry.y,\n                      brighton_sites.to_crs('EPSG:27700')[0]):\n    ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\nax = ax.axis('off')\n\nplt.title(\"Travel Time (minutes - driving) to nearest proposed site in Brighton\")",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#getting-different-modes-of-transport-with-routingpy",
    "href": "mtt_travel_time_apis.html#getting-different-modes-of-transport-with-routingpy",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.5 Getting different modes of transport with routingpy",
    "text": "25.5 Getting different modes of transport with routingpy\nBy changing the ‘profile’ parameter, we can pull back travel matrices for different modes of transport.\n\nlocation_matrix = ors_api.matrix(\n    locations = all_coordinates, # remember this is sources first, then destinations\n    profile = 'foot-walking',\n    sources = sources_indices,\n    destinations = destinations_indices,\n    metrics=[\"distance\", \"duration\"]\n    )\n\n\n\n\n\n\n\nTip\n\n\n\nYou can look in the documentation to see the available travel methods. You will need to head to the ‘matrix’ section of the ORS documentation.\nNote that the profile names - or the name of the relevant parameter - may vary if you are using a different service (like Google maps) through routingpy.\n\n\nHere is the same map as before, but produced using the cycling profile.\n\n\n\n\n\n\nTip\n\n\n\nYou could consider writing a function so you don’t duplicate large amounts of code when changing the profile.\n\n\n\nlocation_matrix = ors_api.matrix(\n    locations = all_coordinates, # remember this is sources first, then destinations\n    profile = 'cycling-regular',\n    sources = sources_indices,\n    destinations = destinations_indices,\n    metrics=[\"distance\", \"duration\"]\n    )\n\nbrighton_travel_matrix = pd.DataFrame(\n    location_matrix.durations,\n    columns=[f\"Site {i+1}\" for i in range(len(destinations_indices))],\n    index=brighton_lsoas_with_coords.name\n    )\n\nbrighton_travel_matrix['shortest'] = brighton_travel_matrix.min(axis=1)\n\nnearest_site_travel_brighton_gdf = pd.merge(\n    lsoa_boundaries,\n    brighton_travel_matrix.reset_index(),\n    left_on = \"LSOA11NM\",\n    right_on = \"name\"\n)\nnearest_site_travel_brighton_gdf[\"shortest_minutes\"] = nearest_site_travel_brighton_gdf[\"shortest\"] / 60\n\nax = nearest_site_travel_brighton_gdf.plot(\n    \"shortest_minutes\",\n    legend=True,\n    cmap=\"Blues\",\n    alpha=0.7,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    figsize=(12,6)\n    )\n\nhospital_points = (brighton_sites.to_crs('EPSG:27700')).plot(ax=ax, color='magenta', markersize=60)\n\ncx.add_basemap(ax, crs=nearest_site_travel_brighton_gdf.crs.to_string(), zoom=14)\n\nfor x, y, label in zip(brighton_sites.to_crs('EPSG:27700').geometry.x,\n                      brighton_sites.to_crs('EPSG:27700').geometry.y,\n                      brighton_sites.to_crs('EPSG:27700')[0]):\n    ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\nax = ax.axis('off')\n\nplt.title(\"Travel Time (minutes - cycling) to nearest proposed site in Brighton\")",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#things-to-know-about-routingpy",
    "href": "mtt_travel_time_apis.html#things-to-know-about-routingpy",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.6 Things to know about routingpy",
    "text": "25.6 Things to know about routingpy\n\nIf you want to use a different routing service via routingpy, the process will be similar but the parameters may be slightly different. Check the docs for the service you’re interested in! https://routingpy.readthedocs.io/en/latest/?badge=latest#module-routingpy.routers\nRoutingpy is in the process of dropping support for ‘HereMaps’, which is another service with a free tier - and may drop support for more routing services that aren’t open source in the future… If something isn’t working, take a look at their github issues to see if it’s a known problem!\nDifferent routing services will often report different figures for the same journeys…\nORS doesn’t have support for traffic data at present - so this can limit the accuracy of your outputs, particularly in urban areas. In comparison, Google Maps allows you to set the departure time, whether the traffic model is pessimistic, optimistic, etc.\nThe Valhalla provider has some level of support for public transport data via the ‘multimodal’ profile But it seems to lack rail data, and more investigation is needed to confirm how accurate it is overall.\nOne additional plus of routingpy is that you can link it into a local install (i.e. on your machine, or on a server within your organisation) and still use a similar syntax again",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#full-code-example",
    "href": "mtt_travel_time_apis.html#full-code-example",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.7 Full code example",
    "text": "25.7 Full code example\nThe full start-to-finish code for this section is given below, allowing you to modify it for your own use.\n\n\n\n\n\n\nWarning\n\n\n\nIf you need to request more than 2500 combinations (e.g. 250 LSOAs * 10 sites, or 100 LSOAs * 25 sites) then you will need to split your requests out into multiple requests to the ORS before rejoining the outputs into a single dataframe.\n\n\n\nimport pandas as pd\nimport geopandas\nimport routingpy as rp\nimport contextily as cx\nimport matplotlib.pyplot as plt\n\n# This line imports an API key from a .txt file in the same folder as the code that is being run\n# You could instead hard-code the API key by running\n# ors_api_key = \"myapikey\"\n# replacing this with your actual key, but you should not commit this to version control like Github\nwith open(\"routingpy_api_key.txt\", \"r\") as file:\n    ors_api_key = file.read().replace(\"\\n\", \"\")\n\nors_api = rp.ORS(api_key=ors_api_key)\n\nlsoa_boundaries = geopandas.read_file(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson\")\n\nlsoa_centroids = pd.read_csv(\"https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/england_lsoa_2011_centroids.csv\")\n\n# filter lsoa centroid file to just those with 'Brighton and Hove' in the name\nbrighton_lsoas_with_coords = lsoa_centroids[lsoa_centroids[\"name\"].str.contains(\"Brighton and Hove\")]\n\n# Turn this into a geodataframe\nbrighton_lsoas_with_coords_gdf = geopandas.GeoDataFrame(\n    brighton_lsoas_with_coords,\n    geometry = geopandas.points_from_xy(\n        brighton_lsoas_with_coords['x'],\n        brighton_lsoas_with_coords['y']\n        ),\n    crs = 'EPSG:27700' # as our current dataset is in BNG (northings/eastings)\n    )\n\n# Convert to lat/long from northings/eastings\nbrighton_lsoas_with_coords_gdf = brighton_lsoas_with_coords_gdf.to_crs('EPSG:4326')\n\nsource_coord_pairs = list(zip(\n   brighton_lsoas_with_coords_gdf.geometry.x,\n   brighton_lsoas_with_coords_gdf.geometry.y\n   ))\n\nsource_coord_pairs_list = [list(coord_tuple) for coord_tuple in source_coord_pairs]\n\n# Define site locations\nlocations = [\n    [50.84510657697442, -0.19543939173180552],\n    [50.844345428338784, -0.13365357930540253],\n    [50.833469545267626, -0.10763304889918592],\n    [50.83075017843111, -0.17652193515449327],\n    [50.865971443211656, -0.11961372476967412],\n    [50.85758221272246, -0.17259077588448932]\n    ]\n\n# Swap site locations into order expected by ORS/routingpy service\nlocations_long_lat = [\n    [  x[1], x[0]  ]\n    for x\n    in locations]\n\n# Create empty list to store all source and destination coordinates\nall_coordinates = []\n\n# Put our sources (our LSOA centre points) into the list\nall_coordinates.extend(source_coord_pairs_list)\n\n# Put our destinations (our potential sites) into the list\nall_coordinates.extend(locations_long_lat)\n\nsources_indices = [i for i in range(len(source_coord_pairs_list))]\n\ndestinations_indices = [i for i in\n                        range(\n                            # first number in list of indices\n                            # this will be 1 more than the number of sources (which were first in our\n                            # full list of coordinates)\n                            len(source_coord_pairs_list),\n                            # last number in list of indices (remember the last number won't\n                            # actually be included)\n                            len(all_coordinates))\n                            ]\n\n# Request the travel times\nlocation_matrix = ors_api.matrix(\n    locations = all_coordinates, # remember this is sources first, then destinations\n    profile = 'driving-car',\n    sources = sources_indices,\n    destinations = destinations_indices,\n    metrics=[\"distance\", \"duration\"]\n    )\n\n# turn the output into a dataframe\nbrighton_travel_matrix = pd.DataFrame(\n    location_matrix.durations,\n    columns=[f\"Site {i+1}\" for i in range(len(destinations_indices))],\n    index=brighton_lsoas_with_coords.name\n    )\n\n# calculate the shortest travel time\nbrighton_travel_matrix['shortest'] = brighton_travel_matrix.min(axis=1)\n\n# join travel data to geometry data\nnearest_site_travel_brighton_gdf = pd.merge(\n    left=lsoa_boundaries,\n    right=brighton_travel_matrix.reset_index(),\n    left_on = \"LSOA11NM\",\n    right_on = \"name\"\n)\n\n# create column with shortest travel time in minutes (converted from seconds)\nnearest_site_travel_brighton_gdf[\"shortest_minutes\"] = nearest_site_travel_brighton_gdf[\"shortest\"] / 60\n\n# create geodataframe of site locations for plotting\nbrighton_sites = geopandas.GeoDataFrame(\n    [f\"Site {i+1}\" for i in range(len(destinations_indices))],\n    geometry = geopandas.points_from_xy(\n        [i[1] for i in locations],\n        [i[0] for i in locations]\n        ),\n    crs = 'EPSG:4326' # as our current dataset is in BNG (northings/eastings)\n    )\n\n# plot travel times as choropleth\nax = nearest_site_travel_brighton_gdf.plot(\n    \"shortest_minutes\",\n    legend=True,\n    cmap=\"Blues\",\n    alpha=0.7,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    figsize=(12,6)\n    )\n\n# plot potential hospitals/sites as point layer\nhospital_points = (brighton_sites.to_crs('EPSG:27700')).plot(ax=ax, color='magenta', markersize=60)\n\n# add basemap\ncx.add_basemap(ax, crs=nearest_site_travel_brighton_gdf.crs.to_string(), zoom=14)\n\n# Add site labels\nfor x, y, label in zip(brighton_sites.to_crs('EPSG:27700').geometry.x,\n                      brighton_sites.to_crs('EPSG:27700').geometry.y,\n                      brighton_sites.to_crs('EPSG:27700')[0]):\n    ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\n# Turn off axis coordinate markings\nax = ax.axis('off')\n\n# Add title to whole plot\nplt.title(\"Travel Time (minutes - driving) to nearest proposed site in Brighton\")",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "mtt_travel_time_apis.html#references",
    "href": "mtt_travel_time_apis.html#references",
    "title": "25  Lookup Up Travel Times Using APIs",
    "section": "25.8 References",
    "text": "25.8 References\nRouting and isochrone images from https://openrouteservice.org/services/",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Lookup Up Travel Times Using APIs</span>"
    ]
  },
  {
    "objectID": "valhalla_api_isochrones.html",
    "href": "valhalla_api_isochrones.html",
    "title": "26  Using Other APIs with RoutingPy - Valhalla",
    "section": "",
    "text": "26.1 Car\n# auto = car in this api, not 'automatic' choice of routing\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"auto\",\n    basemap_zoom=12\n    )\nValhalla instances can have traffic data integrated into it - though only for ‘routes’ and isochrones, and seemingly not via their web service (i.e. it has to be done with a local Valhalla instance).\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"auto\",\n    basemap_zoom=12\n    )",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Using Other APIs with RoutingPy - Valhalla</span>"
    ]
  },
  {
    "objectID": "valhalla_api_isochrones.html#bicycle",
    "href": "valhalla_api_isochrones.html#bicycle",
    "title": "26  Using Other APIs with RoutingPy - Valhalla",
    "section": "26.2 Bicycle",
    "text": "26.2 Bicycle\n\n# bike\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"bicycle\",\n    basemap_zoom=12\n    )",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Using Other APIs with RoutingPy - Valhalla</span>"
    ]
  },
  {
    "objectID": "valhalla_api_isochrones.html#public-transit",
    "href": "valhalla_api_isochrones.html#public-transit",
    "title": "26  Using Other APIs with RoutingPy - Valhalla",
    "section": "26.3 Public Transit",
    "text": "26.3 Public Transit\nSome level of public transport service seemes to be available in the service.\nIt appears that it may be through a partnership with Transitland: see https://www.transit.land/places/United%20Kingdom\n\n# 'bus' profile doesn't appear to work correctly - repeats car map\n# same seems to be true on their demo site (https://valhalla.openstreetmap.de/)\n# use 'multimodal' instead for public transport - see below\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"bus\",\n    basemap_zoom=12\n    )\n\n\n\n\n\n\n\n\n\n# multimodal is effectively a mix of pedestrian + transit\n# I believe transit data comes from the gtfs service (general transit feed specification)\n# some detail about what gtfs data is held for the uk can be found here: https://gtfs.pro/en/uk\n# gtfs is a google project - don't know if it's what powers google map's transit services (at least partly) or not\n\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"multimodal\",\n    basemap_zoom=15\n    )\n\n\n\n\n\n\n\n\n\n26.3.1 Look at options relating to public transit\nAPI suggests we can set preference for bus vs rail and how willing users are to make use of transfers.\nhttps://valhalla.github.io/valhalla/api/turn-by-turn/api-reference/#transit-costing-options\nWe can set the parameter ‘dry run’ to see what will be send to the API and check that the formatting matches the examples given in the docs.\n\nvalhalla_api.isochrones(\n        locations=[-3.5127907292783873,50.72593717697725],\n        profile=\"multimodal\",\n        intervals=[10*60,20*60,30*60],\n        options={\"use_bus\": 0.0, \"use_rail\": 1.0,\"use_transfers\":0.3},\n        dry_run=True\n    )\n\nurl:\nhttps://valhalla1.openstreetmap.de/isochrone\nParameters:\n{\n  \"headers\": {\n    \"User-Agent\": \"routingpy/v1.2.1\",\n    \"Content-Type\": \"application/json\"\n  },\n  \"timeout\": 60,\n  \"json\": {\n    \"locations\": [\n      {\n        \"lon\": -3.5127907292783873,\n        \"lat\": 50.72593717697725\n      }\n    ],\n    \"costing\": \"multimodal\",\n    \"contours\": [\n      {\n        \"time\": 10.0\n      },\n      {\n        \"time\": 20.0\n      },\n      {\n        \"time\": 30.0\n      }\n    ],\n    \"costing_options\": {\n      \"transit\": {\n        \"use_bus\": 0.0,\n        \"use_rail\": 1.0,\n        \"use_transfers\": 0.3\n      }\n    }\n  }\n}\n\n\nIsochrones(None, None)\n\n\n\n# Let's look at preferring bus usage\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"multimodal\",\n    basemap_zoom=15,\n    options_dict={\"use_bus\": \"1.0\", \"use_rail\": \"0.0\",\"use_transfers\":\"0.3\"}\n    )\n\n\n\n\n\n\n\n\n\n# Now at preferring rail usage\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"multimodal\",\n    basemap_zoom=15,\n    options_dict={\"use_bus\": \"0.0\", \"use_rail\": \"1.0\",\"use_transfers\":\"0.3\"}\n    )\n\n\n\n\n\n\n\n\nWe can see that the output is no different. My theory is that current gtfs data for the uk does not include rail data. Downloading the geojson from this page and overlaying it in QGIS with the google maps hybrid map shows stops only on bus stops, not train stations. https://gtfs.pro/en/uk/Department-for-Transport-UK/dft-gtfs\nMore investigation needed!\nTrying it again in European countries still doesn’t seem to yield different results - but uncertain which do and don’t have rail data in this form.\n\nget_isochrone(\n    long_lat_pair= [7.458000835300172, 46.96831183806674],\n    profile=\"multimodal\",\n    basemap_zoom=14,\n    intervals=[15*60,30*60,45*60],\n    options_dict={\"use_bus\": \"0.0\", \"use_rail\": \"1.0\"}\n    )\n\n\n\n\n\n\n\n\n\nget_isochrone(\n    long_lat_pair= [7.458000835300172, 46.96831183806674],\n    profile=\"multimodal\",\n    basemap_zoom=14,\n    intervals=[15*60,30*60,45*60],\n    options_dict={\"use_bus\": \"1.0\", \"use_rail\": \"0.0\"}\n    )",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Using Other APIs with RoutingPy - Valhalla</span>"
    ]
  },
  {
    "objectID": "valhalla_api_isochrones.html#impact-of-walking-speed",
    "href": "valhalla_api_isochrones.html#impact-of-walking-speed",
    "title": "26  Using Other APIs with RoutingPy - Valhalla",
    "section": "26.4 Impact of walking speed",
    "text": "26.4 Impact of walking speed\nWe can see that changing the walking speed does have an impact on the results, so the options dict is definitely working.\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"pedestrian\",\n    basemap_zoom=15,\n    options_dict={\"walking_speed\": \"4.1\"}\n    )\n\n\n\n\n\n\n\n\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"pedestrian\",\n    basemap_zoom=15,\n    options_dict={\"walking_speed\": \"2.5\"}\n    )\n\n\n\n\n\n\n\n\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"pedestrian\",\n    basemap_zoom=15,\n    options_dict={\"walking_speed\": \"5.5\"}\n    )\n\n\n\n\n\n\n\n\nExperiment with impact of changing how comfortable users are with using cycle lanes vs on-road\nhttps://valhalla.github.io/valhalla/api/turn-by-turn/api-reference/#bicycle-costing-options\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"bicycle\",\n    basemap_zoom=12,\n    options_dict={\"use_roads\":\"1.0\"}\n    )\n\n\n\n\n\n\n\n\n\nget_isochrone(\n    long_lat_pair= [-3.5280937949744335,50.72494617349739],\n    profile=\"bicycle\",\n    basemap_zoom=12,\n    options_dict={\"use_roads\":\"0.1\"}\n    )\n\n\n\n\n\n\n\n\n   Created in Deepnote",
    "crumbs": [
      "Part 4 - Working with Travel Times",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Using Other APIs with RoutingPy - Valhalla</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html",
    "href": "intro_facility_location.html",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "",
    "text": "27.1 An example: sexual health clinics in Hampshire\nMeskarian R, Penn ML, Williams S, Monks T (2017) A facility location model for analysis of current and future demand for sexual health services. PLoS ONE 12(8): e0183942.\nhttps://doi.org/10.1371/journal.pone.0183942\nThe project aimed to assist in planning the sexual health service provision in Hampshire.\nThe project aimed to reduce the number of clinics while maintaining/improving service access\nThere were 278 ‘demand points’ where people could be coming from - these were all of the postcode sectors.",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#an-example-sexual-health-clinics-in-hampshire",
    "href": "intro_facility_location.html#an-example-sexual-health-clinics-in-hampshire",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "",
    "text": "They forecast future demand for different aspects of the service over the next 3–5 years, based on population age and gender projections published by the council.\nThey performed a facility location analysis based on the current and forecasted demand to identify an optimal number of clinics and their geographic location.\n\n\n\n\n\n\n\n27.1.1 Findings\nThe clinic locations could be reduced from 28 to 20 and still keep 90% of all patient journeys by public transport (e.g. by bus or train) to a clinic within 30 minutes.\nThe number of clinics could be further reduced to 8 if the travel time is based on car travel times within 15 minutes.\n\n\n27.1.2 Limitations\nThe public transport analysis assumed everyone would travel by public transport - but this is unrealistic (and census data showed over 85% of the population across the county having access to 1+ cars)\n\n\n27.1.3 Diminishing returns",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#formulating-location-allocation-problems",
    "href": "intro_facility_location.html#formulating-location-allocation-problems",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "27.2 Formulating location allocation problems",
    "text": "27.2 Formulating location allocation problems\n\n27.2.1 Discrete vs continuous models\nIn discrete models, it is assumed that demands can be aggregated to a finite number of discrete points.\nTo achieve this, a region could be split up into a series of points (e.g. the central point of postcodes or LSOAs)\nThey also assume that there is a finite set of candidate locations where facilities will be placed.\n\nThe alternative is continuous models, where locations could be anywhere within a range - we don’t cover this!\n\n\n\n27.2.2 Types of location allocation problem",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#p-median-problems",
    "href": "intro_facility_location.html#p-median-problems",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "27.3 p-median problems",
    "text": "27.3 p-median problems\nA p-median problem is basically just one where we care about\nlocating p services (so p could be 1, 2, 3, 5, 25 - whatever!)\nin such a way that the weighted average travel time (or distance) of users is minimized\n\n27.3.1 Understanding how p-median problems work\nFirst, let’s imagine we have a single hospital site.\n\n\n27.3.1.1 Simple averages\n\n\n\n\n27.3.1.2 Why weighted averages?\n\n\n\n27.3.1.3 Calculating weighted averages\n\nBut what if the demand was distributed differently?\n\nIf this was the demand distribution instead, then this might not be such a good location for the hospital\n\n\n27.3.1.4 The impact of weighted averages\nCompare our unweighted average\n\nTo the weighted averages\n\n\n\n\n27.3.2 Limitations of p-median problems\nHowever - one problem with this approach is that it doesn’t look at the maximum travel time.\nFor certain services, like accident and emergency, stroke units, or anything else where being able to get to a service within a certain length of time is crucial, then you may be less concerned about minimizing the average length.\nInstead, you may care more about ensuring that everyone in your catchment area isn’t more than a certain number of miles or minutes away.\n\n\n\n\n\n\n\nWarning\n\n\n\nJust focussing on the weighted average time can lead to an inequitable solution.",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#other-problem-types",
    "href": "intro_facility_location.html#other-problem-types",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "27.4 Other problem types",
    "text": "27.4 Other problem types\n\n\n\n\n\n\nTip\n\n\n\nWe focus on the p-median problem in the course - but it’s useful to know what the other types are.\n\n\n\n27.4.1 Location set covering problem\nWhat is the minimum number of facilities (and their locations) so that all people have at least one facility within a given maximum distance (or time)\n\n\n27.4.2 Maximal covering location problem\nHow can we locate the facilities in such a way that as few people as possible don’t have a service within the target distance (or time)\n\n\n\n\n\n\nTip\n\n\n\nIf we cannot cover all demands because it’s too expensive to do so, the model leans towards covering areas that generate lots of demand rather than those that generate less.",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#presenting-outputs",
    "href": "intro_facility_location.html#presenting-outputs",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "27.5 Presenting outputs",
    "text": "27.5 Presenting outputs\nIn reality, you might care about all of these to some extent!\nYou might find that your best solution to the p-median problem has a really long maximum travel time…\nBut your second best solution actually has a much more reasonable maximum travel time.\n\nMake sure you’re not omitting this information when presenting the output to stakeholders!\nIt can be crucial to help them make an informed, fair and safe decision.\nYou could even consider ranking possible combinations by multiple methods and then seeing which has the lowest overall rank (indicating the best performance against multiple objectives)",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "intro_facility_location.html#references",
    "href": "intro_facility_location.html#references",
    "title": "27  An Introduction to Facility Location Problems",
    "section": "27.6 References",
    "text": "27.6 References\nCar icons created by fjstudio - Flaticon (https://www.flaticon.com/free-icons/car)",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>An Introduction to Facility Location Problems</span>"
    ]
  },
  {
    "objectID": "fl_site_combinations.html",
    "href": "fl_site_combinations.html",
    "title": "28  Calculating combinations of sites",
    "section": "",
    "text": "28.1 Representing possible combinations of sites\nWe then need to be able to represent these as an integer array\nLet’s say we currently have four locations we deliver routine health screenings from.\nDue to constraints, we’re going to have to cut it down to three.",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Calculating combinations of sites</span>"
    ]
  },
  {
    "objectID": "fl_site_combinations.html#representing-possible-combinations-of-sites",
    "href": "fl_site_combinations.html#representing-possible-combinations-of-sites",
    "title": "28  Calculating combinations of sites",
    "section": "",
    "text": "28.1.1 Translating the problem for a computer\n\nIn our code, we will write this as a list of lists.\n\n\n\n28.1.2 Using the itertools package for calculating combinations\nAnd in fact, we won’t actually write it ourselves at all…\nWe’ll get the combinations function from the itertools package to do that for us - via a custom function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nn_facilities is the number of candidate locations where you could place facilities (e.g. clinics).\np is the number of clinics to place. This must be less than n_facilities.\nThis will return all possible combinations of clinic indices.\n\n28.1.2.1 How is this function working?\n\n\n\n\n\n\n28.1.3 Larger problems\nIt turns out someone forgot to tell us about one of the practices!\nBut they are still just looking to drop it down to 3 practices.\nSo how many combinations can we get now?\n\nWell, these are all of the possibilities.\n\nLet’s add numeric indices to these for ease.\n\nThat was a bit of a pain to work out… so you can see why it’s really useful to have a function that will work this out for us when we get to bigger numbers of combinations!\nBut just how big can the number of combinations get?",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Calculating combinations of sites</span>"
    ]
  },
  {
    "objectID": "fl_site_combinations.html#calculating-the-number-of-combinations",
    "href": "fl_site_combinations.html#calculating-the-number-of-combinations",
    "title": "28  Calculating combinations of sites",
    "section": "28.2 Calculating the number of combinations",
    "text": "28.2 Calculating the number of combinations\nWe can use the formula below to work out the total number of possible combinations in a scenario where the order of options doesn’t matter and you can’t repeat options in an answer.\n\n\n\n\n\n\n\nTip\n\n\n\nThe ! isn’t just emphasising things here.\nIt is the mathematical symbol for factorial.\nSo if we have 5 options, the top of our fraction is 5!, or 5 factorial.\nThis is 5 x 4 x 3 x 2 x 1\n2! = 2 x 1\n3! = 3 x 2 x 1\n10! = 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Calculating combinations of sites</span>"
    ]
  },
  {
    "objectID": "fl_site_combinations.html#limitations-of-brute-force-problems",
    "href": "fl_site_combinations.html#limitations-of-brute-force-problems",
    "title": "28  Calculating combinations of sites",
    "section": "28.3 Limitations of brute-force problems",
    "text": "28.3 Limitations of brute-force problems\nThe key thing to note is that the number of combinations can get out of hand very quickly…\nIf you’re working at the level of a single trust, or with some fairly centralised services for an ICB, you’ll probably be ok.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThere are ways to deal with situations where there are too many possibilities to ‘brute force’ - but it’s quite a tricky area to wrap your head around!\nWe’ll briefly cover this concept a bit later today, but we won’t cover how to do it in code or go into much detail about the process.\nHowever, - we will link additional materials if you want to dive into this further - there are some members of the HSMA community with experience in this area if this is a route you need to go down for your HSMA project",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Calculating combinations of sites</span>"
    ]
  },
  {
    "objectID": "fl_site_combinations.html#references",
    "href": "fl_site_combinations.html#references",
    "title": "28  Calculating combinations of sites",
    "section": "28.4 References",
    "text": "28.4 References\nIcons created by Pixel perfect - Flaticon: https://www.flaticon.com/packs/nature-46",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Calculating combinations of sites</span>"
    ]
  },
  {
    "objectID": "fl_problems_coding.html",
    "href": "fl_problems_coding.html",
    "title": "29  Using code to solve facility location problems",
    "section": "",
    "text": "29.1 Demand data\nChances are your demand isn’t spread evenly across your potential service user catchment area.\nYour demand data can be formatted quite simply!\nYou just want to make sure that you’re using the same level of location data as in your travel matrix (e.g. they need to both use LSOA, or both use postcode sectors - not a mixture)",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Using code to solve facility location problems</span>"
    ]
  },
  {
    "objectID": "fl_problems_coding.html#demand-data",
    "href": "fl_problems_coding.html#demand-data",
    "title": "29  Using code to solve facility location problems",
    "section": "",
    "text": "Maybe certain LSOAs have more people of childbearing age, so maternity and paediatric services will get more demand from those areas\nMaybe certain LSOAs have an older population, so stroke services are more centred around there\nMaybe other LSOAs have a higher incidence of obesity, so you might expect more demand for type 2 diabetes services and retinopathy clinics\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nYou might use historic demand figures as your starting point.\nBut always consider…\n\nIf you seem to have areas with no historic demand, is this actually a pattern, or is it just that the historic numbers are small and there’s an element of chance?\nIs there some preexisting bias or issue with access that you might be perpetuating by using the historic figures?\n\nHow can you deal with these issues?\nIf you’re using historic data, can you bring in more years?\nAlternatively, you could explore what happens when you just weight demand by the number of people in each LSOA.\nIf your service only covers a certain age range, you can find LSOA-level figures estimating the proportion of the population in that age group.\n\nYou might also just make predictions of demand based off something else. - Number of people in a target age demographic or of a particular gender in your LSOAs, multiplied by some factor - (e.g. 20% of women aged 18-34)\nJust always consider whether what you’re doing is\n\nappropriate\nsensible\ntransparent\njustifiable\n\nMake it clear what data you have used and why!\nMake the limitations of your conclusions explicit.",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Using code to solve facility location problems</span>"
    ]
  },
  {
    "objectID": "fl_problems_coding.html#evaluating-the-weighted-average-travel-time",
    "href": "fl_problems_coding.html#evaluating-the-weighted-average-travel-time",
    "title": "29  Using code to solve facility location problems",
    "section": "29.2 Evaluating the weighted average travel time",
    "text": "29.2 Evaluating the weighted average travel time\nRight! We’ve got everything we need - except a way to evaluate the weighted average travel time…\nCast your mind back many many slides - when we present our options, we want to give more weight to the travel times from areas that have higher demand.\n\nLet’s write some code to do this.\nIt’s something we’re going to want to reuse quite a lot - so we can turn it into a class with…\nAttributes\n\nour travel dataframe\nour demand dataframe\n\nMethods\n\nEvaluate a solution\n\nLimit the travel dataframe to a subset of candidate locations\nWork out the smallest value per location (the ‘minimum cost’)\nReturn a dataframe with demand and min cost per region\n\nReturn the weighted average for the solution\nReturn the unweighted average for the solution\nReturn the maximum travel time for any locations in the solution\n\n\nThe FacilityLocationObjective code is modified from the Metapy library created by Tom Monks\nhttps://github.com/health-data-science-OR/healthcare-logistics/tree/master/optimisation/metapy\n\n\n29.2.0.1 The init method\n\nclass FacilityLocationObjective:\n    def __init__(self, demand, travel_matrix, merge_col, demand_col):\n        '''\n        Store the demand and travel times\n\n        Args:\n            demand: pd.DataFrame:\n\n            travel_matrix: pd.DataFrame:\n        '''\n        self.demand = demand.set_index(merge_col)\n        self.travel_matrix = travel_matrix.set_index(merge_col)\n        self.demand_col = demand_col\n\ndemand is our dataframe containing demand sources (e.g. LSOAs) as rows and the demand (e.g. yearly patients coming from that LSOA) as the single column\nmerge_col is the name of the column that is consistent between our demand and travel dataframes\ntravel_matrix is the dataframe with demand sources as rows and potential service locations as columns, with the travel cost (time) as the values in the cells\ndemand_col is a string referring to the column that contains the demand value in the demand dataframe\n\n\n29.2.0.2 The evaluate_solution method\nThis method, given a list of sites in the form of their column indices (e.g. [1, 4, 5] for sites 2, 5 and 6), will return a dataframe with the demand and minimum travel time per row for this potential solution.\n\n    def evaluate_solution(self, site_list):\n        '''\n        Args:\n            site_list: list: column indices of solution to evaluate\n                            (to apply to travel matrix)\n\n        Returns:\n            Pandas dataframe to pass to evaluation functions\n\n        '''\n\n        active_facilities = self.travel_matrix.iloc[:, site_list].copy()\n\n        # Assume travel to closest facility\n        # Need to drop the column that contains\n        active_facilities['min_cost'] = active_facilities.min(axis=1)\n\n\n        # Merge demand and travel times into a single DataFrame\n        problem = self.demand.merge(active_facilities,\n                                    left_index=True, right_index=True,\n                                    how='inner')\n\n        return problem.reset_index()\n\n\n\n29.2.0.3 The generate_solution_metrics method\nThis method, given a list of sites in the form of their column indices (e.g. [1, 4, 5] for sites 2, 5 and 6) - Runs the evaluate_solution method - Returns a range of metrics relating to the\n\n    def generate_solution_metrics(self, site_list):\n        '''\n        Calculates the weighted average travel time for selected sites\n\n        Args:\n            site_list: list or np.array: A list of site IDs as a list or array (e.g. [0, 3, 4])\n            merge_col: string: The column name to use for merging the data.\n            n_patients_or_referrals_col: string: The column name to use for the number of patients or referrals.\n\n        Returns:\n            A tuple containing the problem and the maximum travel time.\n        '''\n        problem = self.evaluate_solution(site_list)\n\n        # Return weighted average\n        weighted_average = np.average(problem['min_cost'], weights=problem[self.demand_col])\n        unweighted_average = np.average(problem['min_cost'])\n        max_travel = np.max(problem['min_cost'])\n\n        return {\n            'site_indices': site_list,\n            'site_names': \", \".join(self.travel_matrix.columns[site_list].tolist()),\n            'weighted_average': weighted_average,\n            'unweighted_average': unweighted_average,\n            'max': max_travel,\n            'problem_df': problem\n        }\n\n:::{.callout-tip collapse=“True”} ### Click here to view the whole class\n\n# Tweaked WeightedAverageObjective from Metapy package\n# https://github.com/health-data-science-OR/healthcare-logistics/tree/master/optimisation/metapy\n# Credit: Tom Monks\n\nclass FacilityLocationObjective:\n    '''\n    Encapsulates logic for calculation of\n    metrics in a simple facility location problem\n\n    Demand and travel matrices must have a common column\n\n    demand: pd.dataframe:  Two column dataframe. One column should be labels for the\n    demand locations (e.g. LSOA identifiers, postcodes). Second column should contain\n    demand figures of some kind (e.g. number of historical cases)\n    If demand assumed to be equal, all values in this column could be 1.\n\n    travel_matrix: pd.dataframe: dataframe with columns representing sites\n    and rows representing locations demand will come from.\n    One column should be labels for the demand locations (e.g. LSOA identifiers, postcodes).\n    All other values will be either distance or time in float form.\n    No additional columns of information must be included or they will be used as part of the\n    calculation of the lowest-cost solution, which may lead to incorrect results.\n    '''\n    def __init__(self, demand, travel_matrix, merge_col, demand_col):\n        '''\n        Store the demand and travel times\n\n        Args:\n            demand: pd.DataFrame:\n\n            travel_matrix: pd.DataFrame:\n        '''\n        self.demand = demand.set_index(merge_col)\n        self.travel_matrix = travel_matrix.set_index(merge_col)\n        self.demand_col = demand_col\n\n\n    def evaluate_solution(self, site_list):\n        '''\n        Calculates the\n\n        Args:\n            site_list: list: column indices of solution to evaluate\n                            (to apply to travel matrix)\n\n        Returns:\n            Pandas dataframe to pass to evaluation functions\n\n        '''\n\n        active_facilities = self.travel_matrix.iloc[:, site_list].copy()\n\n        # Assume travel to closest facility\n        # Need to drop the column that contains\n        active_facilities['min_cost'] = active_facilities.min(axis=1)\n\n\n        # Merge demand and travel times into a single DataFrame\n        problem = self.demand.merge(active_facilities,\n                                    left_index=True, right_index=True,\n                                    how='inner')\n\n        return problem.reset_index()\n\n\n    def generate_solution_metrics(self, site_list):\n        '''\n        Calculates the weighted average travel time for selected sites\n\n        Args:\n            site_list: list or np.array: A list of site IDs as a list or array (e.g. [0, 3, 4])\n            merge_col: string: The column name to use for merging the data.\n            n_patients_or_referrals_col: string: The column name to use for the number of patients or referrals.\n\n        Returns:\n            A tuple containing the problem and the maximum travel time.\n        '''\n        problem = self.evaluate_solution(site_list)\n\n        # Return weighted average\n        weighted_average = np.average(problem['min_cost'], weights=problem[self.demand_col])\n        unweighted_average = np.average(problem['min_cost'])\n        max_travel = np.max(problem['min_cost'])\n\n        return {\n            'site_indices': site_list,\n            'site_names': \", \".join(self.travel_matrix.columns[site_list].tolist()),\n            'weighted_average': weighted_average,\n            'unweighted_average': unweighted_average,\n            'max': max_travel,\n            'problem_df': problem\n        }\n\n\n\n29.2.1 Setting up an instance of this class\nLet’s first import the packages we will need throughout this section.\n\nimport pandas as pd\nimport geopandas\nimport contextily as cx\nimport matplotlib.pyplot as plt\n\nWe need to - import a dataset of demand - import (or create) a geodataframe of site locations - and import (or create) a travel matrix for this combination of sites and demand sources\n\nbrighton_demand = pd.read_csv(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_demand.csv\").drop(columns=[\"Unnamed: 0\"])\nbrighton_demand.head()\n\n\n\n\n\n\n\n\n\nLSOA\ndemand\n\n\n\n\n0\nBrighton and Hove 027E\n3627\n\n\n1\nBrighton and Hove 027F\n2323\n\n\n2\nBrighton and Hove 027A\n2596\n\n\n3\nBrighton and Hove 029E\n3132\n\n\n4\nBrighton and Hove 029D\n2883\n\n\n\n\n\n\n\n\n\nbrighton_sites = geopandas.read_file(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_sites.geojson\")\nbrighton_sites.head()\n\n\n\n\n\n\n\n\n\nsite\ngeometry\n\n\n\n\n0\nSite 1\nPOINT (-0.19544 50.84511)\n\n\n1\nSite 2\nPOINT (-0.13365 50.84435)\n\n\n2\nSite 3\nPOINT (-0.10763 50.83347)\n\n\n3\nSite 4\nPOINT (-0.17652 50.83075)\n\n\n4\nSite 5\nPOINT (-0.11961 50.86597)\n\n\n\n\n\n\n\n\n\nbrighton_travel = pd.read_csv(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_travel_matrix_driving.csv\").drop(columns=[\"Unnamed: 0\"])\nbrighton_travel.head()\n\n\n\n\n\n\n\n\n\nLSOA\nSite 1\nSite 2\nSite 3\nSite 4\nSite 5\nSite 6\n\n\n\n\n0\nBrighton and Hove 027E\n773.93\n527.69\n444.29\n491.85\n607.54\n554.91\n\n\n1\nBrighton and Hove 027F\n757.39\n499.11\n517.57\n561.07\n578.97\n538.37\n\n\n2\nBrighton and Hove 027A\n763.24\n601.38\n517.98\n410.40\n681.23\n557.35\n\n\n3\nBrighton and Hove 029E\n743.62\n651.72\n660.36\n379.72\n731.58\n557.58\n\n\n4\nBrighton and Hove 029D\n665.85\n664.65\n658.20\n313.00\n744.50\n570.51\n\n\n\n\n\n\n\n\nFinally, we bring in our LSOA boundaries for plotting later.\n\nlsoa_boundaries = geopandas.read_file(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson\")\nlsoa_boundaries.head()\n\n\n\n\n\n\n\n\n\nFID\nLSOA11CD\nLSOA11NM\nLSOA11NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\ngeometry\n\n\n\n\n0\n1\nE01000001\nCity of London 001A\nCity of London 001A\n532123\n181632\n-0.097140\n51.51816\na758442e-7679-45d0-95a8-ed4c968ecdaa\nPOLYGON ((532282.629 181906.496, 532248.250 18...\n\n\n1\n2\nE01000002\nCity of London 001B\nCity of London 001B\n532480\n181715\n-0.091970\n51.51882\n861dbb53-dfaf-4f57-be96-4527e2ec511f\nPOLYGON ((532746.814 181786.892, 532248.250 18...\n\n\n2\n3\nE01000003\nCity of London 001C\nCity of London 001C\n532239\n182033\n-0.095320\n51.52174\n9f765b55-2061-484a-862b-fa0325991616\nPOLYGON ((532293.068 182068.422, 532419.592 18...\n\n\n3\n4\nE01000005\nCity of London 001E\nCity of London 001E\n533581\n181283\n-0.076270\n51.51468\na55c4c31-ef1c-42fc-bfa9-07c8f2025928\nPOLYGON ((533604.245 181418.129, 533743.689 18...\n\n\n4\n5\nE01000006\nBarking and Dagenham 016A\nBarking and Dagenham 016A\n544994\n184274\n0.089317\n51.53875\n9cdabaa8-d9bd-4a94-bb3b-98a933ceedad\nPOLYGON ((545271.918 184183.948, 545296.314 18...\n\n\n\n\n\n\n\n\nWe will then pass the travel and demand datasets into our FacilityLocationObjective; the site df will be used afterwards.\n\nlocation_problem_brighton = FacilityLocationObjective(\n    demand=brighton_demand,\n    travel_matrix=brighton_travel,\n    merge_col=\"LSOA\",\n    demand_col=\"demand\"\n    )\n\n\n\n\n29.2.2 Outputs\n\n29.2.2.1 evaluate_solution\nThis is the output of the evaluate_solution method.\n\nAnd now we can easily pass in a range of solutions - including with different numbers of sites.\nNote the column names changing to reflect the site indices we are passing in.\n\nNow we bring in our code from an earlier chapter to calculate every possible combination of a certain number of facilities.\n\nfrom itertools import combinations\nimport numpy as np\n\ndef all_combinations(n_facilities, p):\n    facility = np.arange(n_facilities, dtype=np.uint8)\n    return [np.array(a) for a in combinations(facility, p)]\n\nWe could even loop through this to find every combination with every possible number of facilities…\n\npossible_combinations_brighton = all_combinations(\n    len(location_problem_brighton.travel_matrix.columns),\n    4\n    )\n\npossible_combinations_brighton\n\n[array([0, 1, 2, 3], dtype=uint8),\n array([0, 1, 2, 4], dtype=uint8),\n array([0, 1, 2, 5], dtype=uint8),\n array([0, 1, 3, 4], dtype=uint8),\n array([0, 1, 3, 5], dtype=uint8),\n array([0, 1, 4, 5], dtype=uint8),\n array([0, 2, 3, 4], dtype=uint8),\n array([0, 2, 3, 5], dtype=uint8),\n array([0, 2, 4, 5], dtype=uint8),\n array([0, 3, 4, 5], dtype=uint8),\n array([1, 2, 3, 4], dtype=uint8),\n array([1, 2, 3, 5], dtype=uint8),\n array([1, 2, 4, 5], dtype=uint8),\n array([1, 3, 4, 5], dtype=uint8),\n array([2, 3, 4, 5], dtype=uint8)]\n\n\n\n\n\n29.2.3 Obtaining solution metrics in a loop\nNow we can loop through every possible combination and save the outputs.\n\noutputs = []\n\nfor possible_solution in possible_combinations_brighton:\n    outputs.append(\n        location_problem_brighton.generate_solution_metrics(\n        possible_solution\n    )\n)\n\nAnd easily turn our list of dictionaries into a dataframe!\n\npd.DataFrame(outputs)\n\n\n\n\n\n\n\n\n\nsite_indices\nsite_names\nweighted_average\nunweighted_average\nmax\nproblem_df\n\n\n\n\n0\n[0, 1, 2, 3]\nSite 1, Site 2, Site 3, Site 4\n313.257086\n312.565758\n1001.33\nLSOA demand Site 1 S...\n\n\n1\n[0, 1, 2, 4]\nSite 1, Site 2, Site 3, Site 5\n374.295378\n370.452061\n1001.33\nLSOA demand Site 1 S...\n\n\n2\n[0, 1, 2, 5]\nSite 1, Site 2, Site 3, Site 6\n368.551505\n355.460000\n1001.33\nLSOA demand Site 1 S...\n\n\n3\n[0, 1, 3, 4]\nSite 1, Site 2, Site 4, Site 5\n397.907659\n385.938061\n1302.58\nLSOA demand Site 1 S...\n\n\n4\n[0, 1, 3, 5]\nSite 1, Site 2, Site 4, Site 6\n410.033802\n388.522909\n1371.46\nLSOA demand Site 1 S...\n\n\n5\n[0, 1, 4, 5]\nSite 1, Site 2, Site 5, Site 6\n460.215392\n436.115273\n1302.58\nLSOA demand Site 1 S...\n\n\n6\n[0, 2, 3, 4]\nSite 1, Site 3, Site 4, Site 5\n304.810704\n306.939576\n1001.33\nLSOA demand Site 1 ...\n\n\n7\n[0, 2, 3, 5]\nSite 1, Site 3, Site 4, Site 6\n313.630625\n311.418303\n1001.33\nLSOA demand Site 1 ...\n\n\n8\n[0, 2, 4, 5]\nSite 1, Site 3, Site 5, Site 6\n363.242023\n354.221818\n1001.33\nLSOA demand Site 1 ...\n\n\n9\n[0, 3, 4, 5]\nSite 1, Site 4, Site 5, Site 6\n414.657901\n393.878606\n1302.58\nLSOA demand Site 1 S...\n\n\n10\n[1, 2, 3, 4]\nSite 2, Site 3, Site 4, Site 5\n316.865395\n319.753939\n1001.33\nLSOA demand Site 2 ...\n\n\n11\n[1, 2, 3, 5]\nSite 2, Site 3, Site 4, Site 6\n311.756166\n304.151576\n1001.33\nLSOA demand Site 2 ...\n\n\n12\n[1, 2, 4, 5]\nSite 2, Site 3, Site 5, Site 6\n379.697853\n370.415455\n1001.33\nLSOA demand Site 2 ...\n\n\n13\n[1, 3, 4, 5]\nSite 2, Site 4, Site 5, Site 6\n399.681921\n382.101333\n1302.58\nLSOA demand Site 2 S...\n\n\n14\n[2, 3, 4, 5]\nSite 3, Site 4, Site 5, Site 6\n306.446684\n302.913394\n1001.33\nLSOA demand Site 3 ...\n\n\n\n\n\n\n\n\nThen it’s easy to find the best combinations and tidy up the output table.\n\npd.DataFrame(outputs).sort_values('weighted_average').round(1)\n\n\n\n\n\n\n\n\n\nsite_indices\nsite_names\nweighted_average\nunweighted_average\nmax\nproblem_df\n\n\n\n\n6\n[0, 2, 3, 4]\nSite 1, Site 3, Site 4, Site 5\n304.8\n306.9\n1001.3\nLSOA demand Site 1 ...\n\n\n14\n[2, 3, 4, 5]\nSite 3, Site 4, Site 5, Site 6\n306.4\n302.9\n1001.3\nLSOA demand Site 3 ...\n\n\n11\n[1, 2, 3, 5]\nSite 2, Site 3, Site 4, Site 6\n311.8\n304.2\n1001.3\nLSOA demand Site 2 ...\n\n\n0\n[0, 1, 2, 3]\nSite 1, Site 2, Site 3, Site 4\n313.3\n312.6\n1001.3\nLSOA demand Site 1 S...\n\n\n7\n[0, 2, 3, 5]\nSite 1, Site 3, Site 4, Site 6\n313.6\n311.4\n1001.3\nLSOA demand Site 1 ...\n\n\n10\n[1, 2, 3, 4]\nSite 2, Site 3, Site 4, Site 5\n316.9\n319.8\n1001.3\nLSOA demand Site 2 ...\n\n\n8\n[0, 2, 4, 5]\nSite 1, Site 3, Site 5, Site 6\n363.2\n354.2\n1001.3\nLSOA demand Site 1 ...\n\n\n2\n[0, 1, 2, 5]\nSite 1, Site 2, Site 3, Site 6\n368.6\n355.5\n1001.3\nLSOA demand Site 1 S...\n\n\n1\n[0, 1, 2, 4]\nSite 1, Site 2, Site 3, Site 5\n374.3\n370.5\n1001.3\nLSOA demand Site 1 S...\n\n\n12\n[1, 2, 4, 5]\nSite 2, Site 3, Site 5, Site 6\n379.7\n370.4\n1001.3\nLSOA demand Site 2 ...\n\n\n3\n[0, 1, 3, 4]\nSite 1, Site 2, Site 4, Site 5\n397.9\n385.9\n1302.6\nLSOA demand Site 1 S...\n\n\n13\n[1, 3, 4, 5]\nSite 2, Site 4, Site 5, Site 6\n399.7\n382.1\n1302.6\nLSOA demand Site 2 S...\n\n\n4\n[0, 1, 3, 5]\nSite 1, Site 2, Site 4, Site 6\n410.0\n388.5\n1371.5\nLSOA demand Site 1 S...\n\n\n9\n[0, 3, 4, 5]\nSite 1, Site 4, Site 5, Site 6\n414.7\n393.9\n1302.6\nLSOA demand Site 1 S...\n\n\n5\n[0, 1, 4, 5]\nSite 1, Site 2, Site 5, Site 6\n460.2\n436.1\n1302.6\nLSOA demand Site 1 S...\n\n\n\n\n\n\n\n\nAnd, since we stored the combinations in our dataframe too, we can easily pull this out by chaining together a few steps.\n\npd.DataFrame(outputs).sort_values('weighted_average').head(1)['site_names'].values\n\narray(['Site 1, Site 3, Site 4, Site 5'], dtype=object)\n\n\n\n\n29.2.4 Plotting the best solution\nWe can now put this all together with the map plotting skills we’ve learned over the last few sessions.\nWhen plotting our sites as well, we can ensure we are only plotting the sites included in our solution - see the highlighted sections of the code below.\n\n\nLet’s explore what the output of the first line of code is:\n\nbest_solution = pd.DataFrame(outputs).sort_values('weighted_average').head(1)\nbest_solution_df = best_solution['problem_df'].values[0]\n\nbest_solution_df\n\n\n\n\n\n\n\n\n\nLSOA\ndemand\nSite 1\nSite 3\nSite 4\nSite 5\nmin_cost\n\n\n\n\n0\nBrighton and Hove 027E\n3627\n773.93\n444.29\n491.85\n607.54\n444.29\n\n\n1\nBrighton and Hove 027F\n2323\n757.39\n517.57\n561.07\n578.97\n517.57\n\n\n2\nBrighton and Hove 027A\n2596\n763.24\n517.98\n410.40\n681.23\n410.40\n\n\n3\nBrighton and Hove 029E\n3132\n743.62\n660.36\n379.72\n731.58\n379.72\n\n\n4\nBrighton and Hove 029D\n2883\n665.85\n658.20\n313.00\n744.50\n313.00\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n160\nBrighton and Hove 012A\n2497\n446.54\n1108.11\n519.16\n626.02\n446.54\n\n\n161\nBrighton and Hove 005C\n2570\n469.80\n1008.24\n569.40\n526.15\n469.80\n\n\n162\nBrighton and Hove 012B\n2051\n464.53\n1132.60\n537.15\n650.51\n464.53\n\n\n163\nBrighton and Hove 005A\n1164\n567.49\n1105.93\n664.11\n623.84\n567.49\n\n\n164\nBrighton and Hove 005B\n1097\n495.50\n1033.94\n595.10\n551.85\n495.50\n\n\n\n\n165 rows × 7 columns\n\n\n\n\nThis line then ensures we’re just pulling out the site indices for the best sites, and filtering our site dataframe to just those.\n\nbrighton_sites_bng = brighton_sites.to_crs('EPSG:27700').iloc[best_solution[\"site_indices\"].values[0]]\n\nbrighton_sites_bng\n\n\n\n\n\n\n\n\n\nsite\ngeometry\n\n\n\n\n0\nSite 1\nPOINT (527142.275 106616.053)\n\n\n2\nSite 3\nPOINT (533356.778 105476.782)\n\n\n3\nSite 4\nPOINT (528513.424 105052.430)\n\n\n4\nSite 5\nPOINT (532421.163 109069.196)\n\n\n\n\n\n\n\n\n\nNow let’s do the plotting.\n\nbest_solution_df = pd.DataFrame(outputs).sort_values('weighted_average').head(1)['problem_df'].values[0]\n\nnearest_site_travel_brighton_gdf = pd.merge(\n    lsoa_boundaries,\n    best_solution_df,\n    right_on = \"LSOA\",\n    left_on = \"LSOA11NM\"\n)\n\nnearest_site_travel_brighton_gdf[\"min_cost_minutes\"] = nearest_site_travel_brighton_gdf[\"min_cost\"] / 60\n\nax = nearest_site_travel_brighton_gdf.plot(\n    \"min_cost_minutes\",\n    legend=True,\n    cmap=\"Blues\",\n    alpha=0.7,\n    edgecolor=\"black\",\n    linewidth=0.5,\n    figsize=(12,6)\n    )\n\nbrighton_sites_bng = brighton_sites.to_crs('EPSG:27700').iloc[best_solution[\"site_indices\"].values[0]]\n\nhospital_points = brighton_sites_bng.plot(ax=ax, color='magenta', markersize=60)\n\ncx.add_basemap(ax, crs=nearest_site_travel_brighton_gdf.crs.to_string(), zoom=14)\n\nfor x, y, label in zip(brighton_sites_bng.geometry.x,\n                      brighton_sites_bng.geometry.y,\n                      brighton_sites_bng.site):\n    ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\nax.axis('off')\n\nplt.title(\"Travel Time (driving - minutes) for best sites in Brighton\")\n\nText(0.5, 1.0, 'Travel Time (driving - minutes) for best sites in Brighton')\n\n\n\n\n\n\n\n\n\n\n\n29.2.5 Plotting all solutions\nAnd then it doesn’t take much effort to create a map showing weighted average travel times for every possible solution!\nThe key thing is that we just iterate through our dataframe of all solutions - pulling one row out at a time.\nIf we order them by weighted average first, the map in the top left is the best solution.\nThen it’s just our usual plot code - making sure to specify the axis we are plotting on to.\nAnother benefit of saving all these different things is that we can then easily add the weighted average travel time to the title of each plot!\n\nfig, axs = plt.subplots(3, 5, figsize=(30, 15))\n\nfor i, ax in enumerate(fig.axes):\n\n    solution = pd.DataFrame(outputs).sort_values('weighted_average').iloc[[i]]\n    solution_df = solution['problem_df'].values[0]\n\n    nearest_site_travel_brighton_gdf = pd.merge(\n        lsoa_boundaries,\n        solution_df,\n        right_on = \"LSOA\",\n        left_on = \"LSOA11NM\"\n    )\n\n    nearest_site_travel_brighton_gdf[\"min_cost_minutes\"] = nearest_site_travel_brighton_gdf[\"min_cost\"] / 60\n\n    ax = nearest_site_travel_brighton_gdf.plot(\n        \"min_cost_minutes\",\n        legend=True,\n        cmap=\"Blues\",\n        alpha=0.7,\n        edgecolor=\"black\",\n        linewidth=0.5,\n        figsize=(12,6),\n        ax=ax\n        )\n\n    brighton_sites_bng = brighton_sites.to_crs('EPSG:27700').iloc[solution[\"site_indices\"].values[0]]\n\n    hospital_points = brighton_sites_bng.plot(ax=ax, color='magenta', markersize=60)\n\n    for x, y, label in zip(brighton_sites_bng.geometry.x,\n                        brighton_sites_bng.geometry.y,\n                        brighton_sites_bng.site):\n        ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\n    ax.axis('off')\n\n    weighted_travel_time_solution = solution[\"weighted_average\"].values[0]\n    weighted_travel_time_solution_minutes = (weighted_travel_time_solution / 60).round(2)\n\n    ax.set_title(f\"Weighted Average:\\n{weighted_travel_time_solution_minutes} minutes\")\n\n\n\n\n\n\n\n\n\n\n29.2.6 Other ways to display the output\nConsider other ways to display the outputs too.\n\nimport plotly.express as px\n\noutputs_df = pd.DataFrame(outputs)\noutputs_df['weighted_average_minutes'] = (outputs_df['weighted_average']/60).round(2)\n\npx.bar(\n    data_frame=outputs_df.sort_values(\"weighted_average_minutes\", ascending=False),\n    y=\"site_names\",\n    x=\"weighted_average_minutes\",\n    title=\"Possible Site Combinations\"\n)",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Using code to solve facility location problems</span>"
    ]
  },
  {
    "objectID": "fl_problems_coding.html#full-code-example",
    "href": "fl_problems_coding.html#full-code-example",
    "title": "29  Using code to solve facility location problems",
    "section": "29.3 Full Code Example",
    "text": "29.3 Full Code Example\nFinally, here is a full copyable code example for this section.\n\nfrom itertools import combinations\nimport numpy as np\nimport pandas as pd\nimport geopandas\nimport contextily as cx\nimport matplotlib.pyplot as plt\n\n# Tweaked WeightedAverageObjective from Metapy package\n# https://github.com/health-data-science-OR/healthcare-logistics/tree/master/optimisation/metapy\n# Credit: Tom Monks\n\nclass FacilityLocationObjective:\n    '''\n    Encapsulates logic for calculation of\n    metrics in a simple facility location problem\n\n    Demand and travel matrices must have a common column\n\n    demand: pd.dataframe:  Two column dataframe. One column should be labels for the\n    demand locations (e.g. LSOA identifiers, postcodes). Second column should contain\n    demand figures of some kind (e.g. number of historical cases)\n    If demand assumed to be equal, all values in this column could be 1.\n\n    travel_matrix: pd.dataframe: dataframe with columns representing sites\n    and rows representing locations demand will come from.\n    One column should be labels for the demand locations (e.g. LSOA identifiers, postcodes).\n    All other values will be either distance or time in float form.\n    No additional columns of information must be included or they will be used as part of the\n    calculation of the lowest-cost solution, which may lead to incorrect results.\n    '''\n    def __init__(self, demand, travel_matrix, merge_col, demand_col):\n        '''\n        Store the demand and travel times\n\n        Args:\n            demand: pd.DataFrame:\n\n            travel_matrix: pd.DataFrame:\n        '''\n        self.demand = demand.set_index(merge_col)\n        self.travel_matrix = travel_matrix.set_index(merge_col)\n        self.demand_col = demand_col\n\n\n    def evaluate_solution(self, site_list):\n        '''\n        Calculates the\n\n        Args:\n            site_list: list: column indices of solution to evaluate\n                            (to apply to travel matrix)\n\n        Returns:\n            Pandas dataframe to pass to evaluation functions\n\n        '''\n\n        active_facilities = self.travel_matrix.iloc[:, site_list].copy()\n\n        # Assume travel to closest facility\n        # Need to drop the column that contains\n        active_facilities['min_cost'] = active_facilities.min(axis=1)\n\n\n        # Merge demand and travel times into a single DataFrame\n        problem = self.demand.merge(active_facilities,\n                                    left_index=True, right_index=True,\n                                    how='inner')\n\n        return problem.reset_index()\n\n\n    def generate_solution_metrics(self, site_list):\n        '''\n        Calculates the weighted average travel time for selected sites\n\n        Args:\n            site_list: list or np.array: A list of site IDs as a list or array (e.g. [0, 3, 4])\n            merge_col: string: The column name to use for merging the data.\n            n_patients_or_referrals_col: string: The column name to use for the number of patients or referrals.\n\n        Returns:\n            A tuple containing the problem and the maximum travel time.\n        '''\n        problem = self.evaluate_solution(site_list)\n\n        # Return weighted average\n        weighted_average = np.average(problem['min_cost'], weights=problem[self.demand_col])\n        unweighted_average = np.average(problem['min_cost'])\n        max_travel = np.max(problem['min_cost'])\n\n        return {\n            'site_indices': site_list,\n            'site_names': \", \".join(self.travel_matrix.columns[site_list].tolist()),\n            'weighted_average': weighted_average,\n            'unweighted_average': unweighted_average,\n            'max': max_travel,\n            'problem_df': problem\n        }\n\ndef all_combinations(n_facilities, p):\n    facility = np.arange(n_facilities, dtype=np.uint8)\n    return [np.array(a) for a in combinations(facility, p)]\n\nbrighton_demand = pd.read_csv(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_demand.csv\").drop(columns=[\"Unnamed: 0\"])\n\nbrighton_sites = geopandas.read_file(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_sites.geojson\")\n\nbrighton_travel = pd.read_csv(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/brighton_travel_matrix_driving.csv\").drop(columns=[\"Unnamed: 0\"])\n\nlsoa_boundaries = geopandas.read_file(\"https://raw.githubusercontent.com/hsma-programme/h6_3d_facility_location_problems/main/h6_3d_facility_location_problems/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson\")\n\nlocation_problem_brighton = FacilityLocationObjective(\n    demand=brighton_demand,\n    travel_matrix=brighton_travel,\n    merge_col=\"LSOA\",\n    demand_col=\"demand\"\n    )\n\npossible_combinations_brighton = all_combinations(\n    len(location_problem_brighton.travel_matrix.columns),\n    4\n    )\n\noutputs = []\n\nfor possible_solution in possible_combinations_brighton:\n    outputs.append(\n        location_problem_brighton.generate_solution_metrics(\n        possible_solution\n    )\n)\n\nbest_solution = pd.DataFrame(outputs).sort_values('weighted_average').head(1)\nbest_solution_df = best_solution['problem_df'].values[0]\n\nfig, axs = plt.subplots(3, 5, figsize=(30, 15))\n\nfor i, ax in enumerate(fig.axes):\n\n    solution = pd.DataFrame(outputs).sort_values('weighted_average').iloc[[i]]\n    solution_df = solution['problem_df'].values[0]\n\n    nearest_site_travel_brighton_gdf = pd.merge(\n        lsoa_boundaries,\n        solution_df,\n        right_on = \"LSOA\",\n        left_on = \"LSOA11NM\"\n    )\n\n    nearest_site_travel_brighton_gdf[\"min_cost_minutes\"] = nearest_site_travel_brighton_gdf[\"min_cost\"] / 60\n\n    ax = nearest_site_travel_brighton_gdf.plot(\n        \"min_cost_minutes\",\n        legend=True,\n        cmap=\"Blues\",\n        alpha=0.7,\n        edgecolor=\"black\",\n        linewidth=0.5,\n        figsize=(12,6),\n        ax=ax\n        )\n\n    brighton_sites_bng = brighton_sites.to_crs('EPSG:27700').iloc[solution[\"site_indices\"].values[0]]\n\n    hospital_points = brighton_sites_bng.plot(ax=ax, color='magenta', markersize=60)\n\n    for x, y, label in zip(brighton_sites_bng.geometry.x,\n                        brighton_sites_bng.geometry.y,\n                        brighton_sites_bng.site):\n        ax.annotate(label, xy=(x,y), xytext=(10,3), textcoords=\"offset points\", bbox=dict(facecolor='white'))\n\n    ax.axis('off')\n\n    weighted_travel_time_solution = solution[\"weighted_average\"].values[0]\n    weighted_travel_time_solution_minutes = (weighted_travel_time_solution / 60).round(2)\n\n    ax.set_title(f\"Weighted Average:\\n{weighted_travel_time_solution_minutes} minutes\")",
    "crumbs": [
      "Part 5 - Facility Location Problems",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Using code to solve facility location problems</span>"
    ]
  },
  {
    "objectID": "boundary_redrawing_problems_intro.html",
    "href": "boundary_redrawing_problems_intro.html",
    "title": "30  Boundary Problems - An Initial Exploration",
    "section": "",
    "text": "30.1 The problem statement\nIn this case, we will take an example of an ambulance service that is loking to manage the dispatching of a series of resources.\nThere are two dispatch centres responsible for the overall control of their respective fleets of ambulances.\nWithin each dispatch centre, there are a series of dispatchers. Each dispatcher role (which will be fulfilled by multiple dispatchers to give 24/7 coverage) is responsible for a number of ambulances that they are responsible for controlling. For ease, we will just refer to this as a single ‘dispatcher’.\nIn our example, the existing boundaries were drawn some time ago. Over time, as the area has evolved, the number of ambulances - and the number of allocations of these ambulances - each dispatcher is responsible for has begun to vary significantly.\nTo begin with, we will explore - how to load in and visualise our historical data and boundaries - how we can vary the boundaries manually and evaluate a simple solution with one objective - how we could manage additional objectives in our solution finding - how we can start to vary the boundaries automatically and evaluate the solutions gemerated - how we can move from evaluating a series of random solutions to using genetic algorithms to improve our progress towards finding solutions nearer the optimum - how we can start to limit the possible boundaries to avoid certain features or configurations - how to deal with split boundaries",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Boundary Problems - An Initial Exploration</span>"
    ]
  },
  {
    "objectID": "boundary_redrawing_problems_intro.html#the-problem-statement",
    "href": "boundary_redrawing_problems_intro.html#the-problem-statement",
    "title": "30  Boundary Problems - An Initial Exploration",
    "section": "",
    "text": "Tip\n\n\n\nFor the early stages of our problem, we will make the assumption that a boundary cannot split a district. In our example, we will be using lower level super output areas (LSOAs), but the principles applied in these chapters would work for any similar kind of area splits, such as postcodes, postcode areas, MSOAs, or something else.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Boundary Problems - An Initial Exploration</span>"
    ]
  },
  {
    "objectID": "boundary_problems_visualising_historical_boundaries.html",
    "href": "boundary_problems_visualising_historical_boundaries.html",
    "title": "31  Loading and Visualising the Historical Boundaries",
    "section": "",
    "text": "31.1 Our region\nWe’re going to work with our Birmingham region again. We first worked with this in the section of the book covering travel times; we may return to this travel time data in a later chapter of this part.\nTo start with, let’s just visualise our wider region.\nimport geopandas\n\nlsoa_geojson_path = 'https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson'\n\nlsoa_boundaries = geopandas.read_file(lsoa_geojson_path)\nLet’s now filter this down to just our region.\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nbham_region = lsoa_boundaries.cx[xmin:xmax, ymin:ymax]\n\nbham_region.plot(\n    figsize=(10,7),\n    edgecolor='black',\n    color=\"cyan\"\n    )\nStraight away we can see that there are a very large number of LSOAs in our problem, with a lot of variation in the area of each LSOA.\nWe’ll start with the split of our LSOAs by their overarching dispatch center.\nWe’ve been told that our dispatch centres are split based on the wider region name. Here, we’d visualised these names.\nimport matplotlib.pyplot as plt\n\nbham_region.head()\n\nbham_region[\"region\"] = bham_region[\"LSOA11NM\"].str[:-5]\n\nfig, ax = plt.subplots(figsize=(10,7))\n\nax = bham_region.plot(\n    ax=ax,\n    edgecolor='black',\n    column=\"region\",\n    legend=True,\n    cmap=\"tab20\",\n    legend_kwds={'loc':'center left', 'bbox_to_anchor':(1.2, 0.5)}\n    )\n\n# Add a dark background to our plotted region\nax.set_facecolor('black')\nfig.patch.set_facecolor('black')\n\n# Add a label per region for easier crossreferencing\n# particularly where colours aren't very distinct\none_row_per_region = bham_region.groupby('region').head(1)\n\nfor x, y, label in zip(one_row_per_region.geometry.centroid.x, one_row_per_region.geometry.centroid.y, one_row_per_region.region):\n    ax.annotate(label, xy=(x, y), xytext=(0, 0), textcoords=\"offset points\", color=\"white\",\n    fontweight=\"bold\")\n\nax.axis('off')\n\n/home/sammi/.local/lib/python3.10/site-packages/geopandas/geodataframe.py:1528: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\nWe’ve been told that the regions are as follows:\nCentre 1\nCentre 2\nThis information has been given to us in a dataframe; let’s import and inspect this, then join it to our other data.\nimport pandas as pd\n\nboundary_allocations_df = pd.read_csv(\"boundary_allocations.csv\")\nboundary_allocations_df.head()\n\n\n\n\n\n\n\n\n\nRegion\nCentre\nDispatcher\n\n\n\n\n0\nTelford and Wrekin\nCentre 1\n1\n\n\n1\nShropshire\nCentre 1\n1\n\n\n2\nCannock Chase\nCentre 1\n2\n\n\n3\nLichfield\nCentre 1\n2\n\n\n4\nTamworth\nCentre 1\n2\nIf we join this to our boundary data, with the geodataframe on the left of the merge, we can then access the data about the dispatchers and centers as variables we can plot.\nFirst, let’s do the join and view the resulting dataframer which will have the additional columns. As the original dataframe only contains separate columns for center and dispatcher, we will first create an additional column that joins the two together.\nbham_region = pd.merge(\n    bham_region,\n    boundary_allocations_df,\n    left_on=\"region\",\n    right_on=\"Region\",\n    how=\"left\"\n)\n\nbham_region[\"centre_dispatcher\"] = bham_region[\"Centre\"].astype(\"str\") + '-' + bham_region[\"Dispatcher\"].astype(\"str\")\n\nbham_region.head()\n\n\n\n\n\n\n\n\n\nFID\nLSOA11CD\nLSOA11NM\nLSOA11NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\ngeometry\nregion\nRegion\nCentre\nDispatcher\ncentre_dispatcher\n\n\n\n\n0\n8649\nE01008881\nBirmingham 067A\nBirmingham 067A\n412690\n285438\n-1.81463\n52.46675\nf79cd8fb-0cf2-4c84-b07c-55bffcf379bb\nPOLYGON ((413040.413 285809.794, 413145.440 28...\nBirmingham\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n1\n8650\nE01008882\nBirmingham 066A\nBirmingham 066A\n411772\n285390\n-1.82814\n52.46634\ne7835311-f105-4c92-acae-ecd5255ce534\nPOLYGON ((412233.657 285480.231, 412255.373 28...\nBirmingham\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2\n8651\nE01008883\nBirmingham 078A\nBirmingham 078A\n412121\n285001\n-1.82302\n52.46283\n29dbcbc2-4a29-4bb1-addb-42b37d91c647\nPOLYGON ((412775.838 285204.808, 412575.845 28...\nBirmingham\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n3\n8652\nE01008884\nBirmingham 078B\nBirmingham 078B\n411241\n284712\n-1.83598\n52.46025\ndf5a2350-a102-4ecc-b028-5a0bbeded198\nPOLYGON ((411803.096 284902.674, 411563.054 28...\nBirmingham\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n4\n8653\nE01008885\nBirmingham 076A\nBirmingham 076A\n413207\n284818\n-1.80704\n52.46116\n13a855fc-fa09-42a5-a05e-947fcd141ce4\nPOLYGON ((413417.353 284803.764, 413034.282 28...\nBirmingham\nBirmingham\nCentre 1\n6\nCentre 1-6\nLet’s first just visualise the split across our dispatching centres by plotting the center column.\nax = bham_region.plot(\n    edgecolor='black',\n    column=\"Centre\",\n    legend=True,\n    legend_kwds={'loc':'center left', 'bbox_to_anchor':(1.2, 0.5)}\n    )\n\nax.axis('off')\nThen we’ll visualise the split per dispatcher, using our new column to avoid issues with dispatcher numbers being duplicated across centres.\nax = bham_region.plot(\n    edgecolor='black',\n    column=\"centre_dispatcher\",\n    legend=True,\n    cmap=\"tab20\",\n    legend_kwds={'loc':'center left', 'bbox_to_anchor':(1.2, 0.5)}\n    )\n\nax.axis('off')\nFinally, let’s demonstrate how we could overlay the plot by dispatcher with something that highlights the per-centre boundary as well.\nTo do this, we will have to merge all of the polygons into a single large polygon. This will give us a brand new dataframe with just two rows referencing the two large polygons; we will view this at the end.\nGenAI Alert - This code was modified from a suggested approach provided by ChatGPT\n# Group by the specified column\ngrouped_centre_gdf = bham_region.groupby('Centre')\n\n# Create a new GeoDataFrame for the boundaries of each group\nboundary_list = []\n\nfor group_name, group in grouped_centre_gdf:\n    # Combine the polygons in each group into one geometry\n    combined_geometry = group.unary_union\n\n    # Get the boundary of the combined geometry\n    boundary = combined_geometry.boundary\n\n    # Add the boundary geometry and the group name to the list\n    boundary_list.append({'group': group_name, 'boundary': boundary})\n\n# Create a GeoDataFrame from the list of boundaries\ngrouped_centre_gdf_boundary = geopandas.GeoDataFrame(boundary_list, geometry='boundary', crs=bham_region.crs)\n\ngrouped_centre_gdf_boundary.head()\n\n\n\n\n\n\n\n\n\ngroup\nboundary\n\n\n\n\n0\nCentre 1\nMULTILINESTRING ((366838.095 273147.999, 36728...\n\n\n1\nCentre 2\nMULTILINESTRING ((376328.508 242672.351, 37647...\nFinally, we’ll repeat our per-dispatcher\nax = bham_region.plot(\n    edgecolor='black',\n    column=\"centre_dispatcher\",\n    legend=True,\n    cmap=\"tab20\",\n    legend_kwds={'loc':'center left', 'bbox_to_anchor':(1.2, 0.5)}\n    )\n\ngrouped_centre_gdf_boundary.plot(\n    edgecolor='red',\n    ax=ax,\n    linewidth=2\n)\n\nax.axis('off')",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Loading and Visualising the Historical Boundaries</span>"
    ]
  },
  {
    "objectID": "boundary_problems_visualising_historical_boundaries.html#our-region",
    "href": "boundary_problems_visualising_historical_boundaries.html#our-region",
    "title": "31  Loading and Visualising the Historical Boundaries",
    "section": "",
    "text": "Tip\n\n\n\nThere are other ways you could conduct this initial filtering - for example, using a list of LSOAs you need to cover, or a filter\n\n\n\n\n\n\n\n\n\nDispatcher 1: Telford and Wrekin; Shropshire\nDispatcher 2: Cannock Chase; Lichfield; Tamworth\nDispatcher 3: South Staffordshire; Walsall\nDispatcher 4: Wolverhampton\nDispatcher 5: Dudley; Sandwell\nDispatcher 6: Birmingham\nDispatcher 7: Solihull; North Warwickshire\n\n\n\nDispatcher 1: Bromsgrove\nDispatcher 2: Wyre Forest\nDispatcher 3: Wychavon; Worcester\nDispatcher 4: Malvern Hills; Herefordshire\nDispatcher 5: Redditch; Stratford-on-Avon; Warwick",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Loading and Visualising the Historical Boundaries</span>"
    ]
  },
  {
    "objectID": "boundary_problems_visualising_historical_boundaries.html#bringing-in-historical-demand-data",
    "href": "boundary_problems_visualising_historical_boundaries.html#bringing-in-historical-demand-data",
    "title": "31  Loading and Visualising the Historical Boundaries",
    "section": "31.2 Bringing in historical demand data",
    "text": "31.2 Bringing in historical demand data\nFinally, let’s bring in some historical demand data to see if we can spot any obvious issues.\nFirst, so we can overlay both the centre boundaries and the per-dispatcher boundaries, we’ll repeat our earlier process to create a geodataframe with a single row and a single polygon per dispatcher.\n\n# Group by the specified column\ngrouped_dispatcher_gdf = bham_region.groupby(\"centre_dispatcher\")\n\n# Create a new GeoDataFrame for the boundaries of each group\nboundary_list = []\n\nfor group_name, group in grouped_dispatcher_gdf:\n    # Combine the polygons in each group into one geometry\n    combined_geometry = group.unary_union\n\n    # Get the boundary of the combined geometry\n    boundary = combined_geometry.boundary\n\n    # Add the boundary geometry and the group name to the list\n    boundary_list.append({'group': group_name, 'boundary': boundary})\n\n# Create a GeoDataFrame from the list of boundaries\ngrouped_dispatcher_gdf_boundary = geopandas.GeoDataFrame(boundary_list, geometry='boundary', crs=bham_region.crs)\n\ngrouped_dispatcher_gdf_boundary.head()\n\n\n\n\n\n\n\n\n\ngroup\nboundary\n\n\n\n\n0\nCentre 1-1\nMULTILINESTRING ((368935.969 274516.594, 36824...\n\n\n1\nCentre 1-2\nLINESTRING (412258.535 300984.197, 411756.668 ...\n\n\n2\nCentre 1-3\nLINESTRING (381775.908 282326.500, 380577.001 ...\n\n\n3\nCentre 1-4\nLINESTRING (388885.341 295185.385, 388630.406 ...\n\n\n4\nCentre 1-5\nLINESTRING (388258.095 285110.427, 388666.258 ...\n\n\n\n\n\n\n\n\n\ndemand = pd.read_csv(\"demand_pop_bham.csv\")\n\nbham_region = bham_region.merge(demand, on=\"LSOA11CD\")\n\nax = bham_region.plot(\n    edgecolor='black',\n    column=\"demand\",\n    cmap=\"Blues\",\n    legend=True,\n    linewidth=0.3\n    )\n\ngrouped_dispatcher_gdf_boundary.plot(\n    edgecolor='purple',\n    ax=ax,\n    linewidth=1.5\n)\n\ngrouped_centre_gdf_boundary.plot(\n    edgecolor='red',\n    ax=ax,\n    linewidth=2.5\n)\n\nax.axis('off')",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Loading and Visualising the Historical Boundaries</span>"
    ]
  },
  {
    "objectID": "boundary_problems_varying_evaluating_simple.html",
    "href": "boundary_problems_varying_evaluating_simple.html",
    "title": "32  (WIP) Boundary Problems - Creating and Evaluating Simple Solutions",
    "section": "",
    "text": "32.1 Generating and representing new boundaries\nWhen we come to modifying our existing boundaries, we are going to generate a large set of random new boundaries and test them.\nFirst, we will define the LSOAs that each LSOA has a continuous boundary with. These will form part of a possible series of solutions. To do this, we’ll be using the .touches method in geopandas.\nIn this case, a solution must meet a criteria\nAt this point, we are not trying to do anything to balance our objectives like equalising the number of calls they are going to; instead, we are simply coming up with possibilities. We’ll actually test them out in the next chapter.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>(WIP) Boundary Problems - Creating and Evaluating Simple Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_varying_evaluating_simple.html#generating-and-representing-new-boundaries",
    "href": "boundary_problems_varying_evaluating_simple.html#generating-and-representing-new-boundaries",
    "title": "32  (WIP) Boundary Problems - Creating and Evaluating Simple Solutions",
    "section": "",
    "text": "Note\n\n\n\nRemember - in our problem statement, we specified that boundaries in our problem cannot cross through the middle of an LSOA. You would need to apply a different approach if this is not true in your case.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf you have a series of pre-selected solutions to try, the code in the following sections can be adapted to use those solutions rather than the randomly-generated solutions.\n\n\n\n\n\nevery polygon must be assigned to a dispatcher\nno polygon can be assigned to more than one dispatcher\ndispatcher boundaries must be continuous; regions belonging to a dispatcher cannot be entirely separated from the rest of their dispatch area\n\n\n\n32.1.1 The Process\nTo create a solution that scales well to any number of dispatchers, we will have the dispatchers start with a single randomly-selected patch from their existing location.\nThen, on each ‘turn’, they will randomly choose another patch from the patches that share a boundary with the first patch. There is a small (adjustable) possibility on each turn that they will not opt to take a turn; this will be part of our strategy to ensure that not every dispatcher ends up with solutions containing exactly the same number\nOn each subsequent turn, they will randomly select another region that touches any part of their existing region. If the region that is selected is a region that they already have in their ‘patch’, then\n\n\n\n\n\n\nTip\n\n\n\nAgain, this is not the only way we can start to generate solutions here!\nThis is one of many approaches you could take.\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen we come to apply a evolutionary or genetic algorithm approach to this problem in a later chapter, we will need to change how we represent our solutions; for now, however, we can just put together lists of LSOAs that will belong to each dispatcher.\n\n\nLet’s write and apply this function to generate a series of randomly generated solutions for our problem, which we will subsequently move on to evaluating.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>(WIP) Boundary Problems - Creating and Evaluating Simple Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_visualising_historical_boundaries.html#looking-at-the-current-balance-of-incidents-across-the-region",
    "href": "boundary_problems_visualising_historical_boundaries.html#looking-at-the-current-balance-of-incidents-across-the-region",
    "title": "31  Loading and Visualising the Historical Boundaries",
    "section": "31.3 Looking at the current balance of incidents across the region",
    "text": "31.3 Looking at the current balance of incidents across the region\nThe demand dataset provided gives us the total number of incidents our dispatchers have dealt with per region per year. Let’s do a bit of merging and exploratory data analysis to see how this varied historically, and so we can start to think about what would be a target level of demand for each region.\nFirst let’s look at the per-centre rates.\n\ngrouped_by_centre = bham_region.groupby('Centre')[['demand']].sum()\ngrouped_by_centre['difference_from_average'] = (grouped_by_centre['demand'] - grouped_by_centre['demand'].mean()).astype('int')\ngrouped_by_centre\n\n\n\n\n\n\n\n\n\ndemand\ndifference_from_average\n\n\nCentre\n\n\n\n\n\n\nCentre 1\n277146\n110663\n\n\nCentre 2\n55820\n-110663\n\n\n\n\n\n\n\n\nAnd now by dispatcher\n\ngrouped_by_dispatcher = bham_region.groupby('centre_dispatcher')[['demand']].sum()\nmean_demand = grouped_by_dispatcher['demand'].mean()\nprint(f\"The demand, averaged across {len(bham_region['centre_dispatcher'].unique())} regions, is {mean_demand:.0f} incidents per year\")\n\nThe demand, averaged across 12 regions, is 27747 incidents per year\n\n\n\ngrouped_by_dispatcher['difference_from_mean'] = (grouped_by_dispatcher['demand'] - mean_demand).astype('int')\ngrouped_by_dispatcher\n\n\n\n\n\n\n\n\n\ndemand\ndifference_from_mean\n\n\ncentre_dispatcher\n\n\n\n\n\n\nCentre 1-1\n7600\n-20147\n\n\nCentre 1-2\n12825\n-14922\n\n\nCentre 1-3\n36084\n8336\n\n\nCentre 1-4\n26690\n-1057\n\n\nCentre 1-5\n63379\n35631\n\n\nCentre 1-6\n109387\n81639\n\n\nCentre 1-7\n21181\n-6566\n\n\nCentre 2-1\n9630\n-18117\n\n\nCentre 2-2\n9429\n-18318\n\n\nCentre 2-3\n16699\n-11048\n\n\nCentre 2-4\n4217\n-23530\n\n\nCentre 2-5\n15845\n-11902\n\n\n\n\n\n\n\n\n\nimport plotly.express as px\n\npx.bar(grouped_by_dispatcher.reset_index(), x=\"centre_dispatcher\", y=\"difference_from_mean\")\n\n                                                \n\n\nNo wonder our dispatchers are struggling - there are huge discrepancies in the demand they have been responsible for.\nSo what are we going to do about it?\nUnlike in our travel time location work in the location allocation chapter, where we initially focussed on minimize the average travel time or population-weighted travel time, here we instead want to minimize the difference between the demand for each region going forward - so let’s move onto the next chapter and explore how we will do that.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Loading and Visualising the Historical Boundaries</span>"
    ]
  }
]