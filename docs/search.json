[
  {
    "objectID": "boundary_problems_varying_evaluating_simple.html",
    "href": "boundary_problems_varying_evaluating_simple.html",
    "title": "32  Boundary Problems - Creating and Evaluating Simple Solutions",
    "section": "",
    "text": "32.1 Generating and representing new boundaries\nWhen we come to modifying our existing boundaries, we are going to generate a large set of random new boundaries and test them.\nFirst, we will define the LSOAs that each LSOA has a continuous boundary with. These will form part of a possible series of solutions. To do this, we’ll be using the .touches method in geopandas.\nIn this case, a solution must meet a criteria\nAt this point, we are not trying to do anything to balance our objectives like equalising the number of calls they are going to; instead, we are simply coming up with possibilities. We’ll actually test them out in the next chapter.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Boundary Problems - Creating and Evaluating Simple Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_varying_evaluating_simple.html#generating-and-representing-new-boundaries",
    "href": "boundary_problems_varying_evaluating_simple.html#generating-and-representing-new-boundaries",
    "title": "32  Boundary Problems - Creating and Evaluating Simple Solutions",
    "section": "",
    "text": "Note\n\n\n\nRemember - in our problem statement, we specified that boundaries in our problem cannot cross through the middle of an LSOA. You would need to apply a different approach if this is not true in your case.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf you have a series of pre-selected solutions to try, the code in the following sections can be adapted to use those solutions rather than the randomly-generated solutions.\n\n\n\n\n\nevery polygon must be assigned to a dispatcher\nno polygon can be assigned to more than one dispatcher\ndispatcher boundaries must be continuous; regions belonging to a dispatcher cannot be entirely separated from the rest of their dispatch area\n\n\n\n32.1.1 The Process\nTo create a solution that scales well to any number of dispatchers, we will have the dispatchers start with a single randomly-selected patch from their existing location (though we will also code in an option to always start from a single specified point).\nThen, on each ‘turn’, they will randomly choose another patch from the patches that share a boundary with the first patch. There is a small (adjustable) possibility on each turn that they will not opt to take a turn; this will be part of our strategy to ensure that not every dispatcher ends up with solutions containing exactly the same number\nOn each subsequent turn, they will randomly select another region that touches any part of their existing region. If the region that is selected is a region that they already have in their ‘patch’, then\nHere’s an example of one of our ‘walks’ building up. This only shows the first few steps, but eventually it would continue until the whole patch was covered, following the same pattern.\n\nThis just showed us building up two patches, but more patches could be built with a larger number of ‘players’.\n\n\n\n\n\n\n\nTip\n\n\n\nRemember - due to the randomness we will introduce, each generated solution will be slightly different.\n\n\n\n\n\n\n\n\nTip\n\n\n\nAgain, this is not the only way we can start to generate solutions here!\nThis is one of many approaches you could take.\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen we come to apply a evolutionary or genetic algorithm approach to this problem in a later chapter, we will need to change how we represent our solutions; for now, however, we can just put together lists of LSOAs that will belong to each dispatcher.\n\n\nLet’s write and apply this function to generate a series of randomly generated solutions for our problem, which we will subsequently move on to evaluating.\n\n\n32.1.2 Our starting dataframe\nTo start with, let’s load our boundary data back in. Head back to the previous chapter if any of this feels unfamiliar!\n\nimport pandas as pd\nimport geopandas\n\nlsoa_geojson_path = 'https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson'\n\nlsoa_boundaries = geopandas.read_file(lsoa_geojson_path)\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nbham_region = lsoa_boundaries.cx[xmin:xmax, ymin:ymax]\n\nbham_region[\"region\"] = bham_region[\"LSOA11NM\"].str[:-5]\n\nbham_region.plot(\n    figsize=(10,7),\n    edgecolor='black',\n    color=\"cyan\"\n    )\n\n/home/sammi/.local/lib/python3.10/site-packages/geopandas/geodataframe.py:1528: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\n\n\n\n\n\n\n\n32.1.3 Getting the Neighbours\nBefore we start worrying about the allocations, we first want to generate a column that contains a list of all of the neighbours of a given cell. This will be a lot more efficient than trying to calculate the neighbours from scratch each time we want to pick a new one - and it’s not like the neighbours will change.\nGenAI Alert - This code was modified from a suggested approach provided by ChatGPT\n\ndef add_neighbors_column(gdf):\n    \"\"\"\n    Adds a column to the GeoDataFrame containing lists of indices of neighboring polygons\n    based on the 'touches' method.\n    \"\"\"\n    gdf = gdf.copy()\n    neighbors = []\n    for idx, geom in gdf.geometry.items():\n        touching = gdf[gdf.geometry.touches(geom)][\"LSOA11CD\"].tolist()\n        neighbors.append(touching)\n\n    gdf[\"neighbors\"] = neighbors\n    return gdf\n\nbham_region = add_neighbors_column(bham_region)\n\nbham_region[['LSOA11CD', 'LSOA11NM', 'LSOA11NMW', 'geometry', 'neighbors']].head()\n\n\n\n\n\n\n\n\n\nLSOA11CD\nLSOA11NM\nLSOA11NMW\ngeometry\nneighbors\n\n\n\n\n8648\nE01008881\nBirmingham 067A\nBirmingham 067A\nPOLYGON ((413040.413 285809.794, 413145.440 28...\n[E01008882, E01008883, E01008885, E01008886, E...\n\n\n8649\nE01008882\nBirmingham 066A\nBirmingham 066A\nPOLYGON ((412233.657 285480.231, 412255.373 28...\n[E01008881, E01008883, E01008884, E01008898, E...\n\n\n8650\nE01008883\nBirmingham 078A\nBirmingham 078A\nPOLYGON ((412775.838 285204.808, 412575.845 28...\n[E01008881, E01008882, E01008884, E01008886, E...\n\n\n8651\nE01008884\nBirmingham 078B\nBirmingham 078B\nPOLYGON ((411803.096 284902.674, 411563.054 28...\n[E01008882, E01008883, E01008887, E01008889, E...\n\n\n8652\nE01008885\nBirmingham 076A\nBirmingham 076A\nPOLYGON ((413417.353 284803.764, 413034.282 28...\n[E01008881, E01008886, E01008888, E01009521]\n\n\n\n\n\n\n\n\n\nboundary_allocations_df = pd.read_csv(\"boundary_allocations.csv\")\nboundary_allocations_df.head()\n\n\nbham_region = pd.merge(\n    bham_region,\n    boundary_allocations_df,\n    left_on=\"region\",\n    right_on=\"Region\",\n    how=\"left\"\n)\n\nbham_region[\"centre_dispatcher\"] = bham_region[\"Centre\"].astype(\"str\") + '-' + bham_region[\"Dispatcher\"].astype(\"str\")\n\nbham_region\n\n\n\n\n\n\n\n\n\nFID\nLSOA11CD\nLSOA11NM\nLSOA11NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\ngeometry\nregion\nneighbors\nRegion\nCentre\nDispatcher\ncentre_dispatcher\n\n\n\n\n0\n8649\nE01008881\nBirmingham 067A\nBirmingham 067A\n412690\n285438\n-1.81463\n52.46675\nf79cd8fb-0cf2-4c84-b07c-55bffcf379bb\nPOLYGON ((413040.413 285809.794, 413145.440 28...\nBirmingham\n[E01008882, E01008883, E01008885, E01008886, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n1\n8650\nE01008882\nBirmingham 066A\nBirmingham 066A\n411772\n285390\n-1.82814\n52.46634\ne7835311-f105-4c92-acae-ecd5255ce534\nPOLYGON ((412233.657 285480.231, 412255.373 28...\nBirmingham\n[E01008881, E01008883, E01008884, E01008898, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2\n8651\nE01008883\nBirmingham 078A\nBirmingham 078A\n412121\n285001\n-1.82302\n52.46283\n29dbcbc2-4a29-4bb1-addb-42b37d91c647\nPOLYGON ((412775.838 285204.808, 412575.845 28...\nBirmingham\n[E01008881, E01008882, E01008884, E01008886, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n3\n8652\nE01008884\nBirmingham 078B\nBirmingham 078B\n411241\n284712\n-1.83598\n52.46025\ndf5a2350-a102-4ecc-b028-5a0bbeded198\nPOLYGON ((411803.096 284902.674, 411563.054 28...\nBirmingham\n[E01008882, E01008883, E01008887, E01008889, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n4\n8653\nE01008885\nBirmingham 076A\nBirmingham 076A\n413207\n284818\n-1.80704\n52.46116\n13a855fc-fa09-42a5-a05e-947fcd141ce4\nPOLYGON ((413417.353 284803.764, 413034.282 28...\nBirmingham\n[E01008881, E01008886, E01008888, E01009521]\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2006\n32722\nE01033646\nBirmingham 031I\nBirmingham 031I\n410257\n291057\n-1.85027\n52.51731\nc7a17445-f800-41bc-86fb-cbeb9cde5d3f\nPOLYGON ((410651.278 291571.301, 410562.002 29...\nBirmingham\n[E01009000, E01009007, E01009013, E01009401, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2007\n32723\nE01033647\nBirmingham 058E\nBirmingham 058E\n410473\n286828\n-1.84722\n52.47929\n7d745c12-8e35-404d-b96d-f2b3c3e92896\nPOLYGON ((410665.117 286998.178, 410753.991 28...\nBirmingham\n[E01009194, E01009197, E01009198, E01009331, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2008\n32724\nE01033648\nBirmingham 084F\nBirmingham 084F\n408315\n283740\n-1.87907\n52.45157\ned410ea7-fc12-42bd-8604-4a54fab04b9f\nPOLYGON ((408199.966 283979.204, 408378.884 28...\nBirmingham\n[E01009376, E01009377, E01009383, E01009384, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2009\n32725\nE01033649\nBirmingham 058F\nBirmingham 058F\n410530\n287142\n-1.84637\n52.48211\na8880f7b-a92b-43da-bf8d-b673ed85c526\nPOLYGON ((410728.297 287314.945, 410665.117 28...\nBirmingham\n[E01009194, E01009195, E01009197, E01033647]\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n2010\n32726\nE01033650\nBirmingham 077F\nBirmingham 077F\n409357\n284898\n-1.86370\n52.46196\n2868f08d-b3bd-4e47-b985-ce8484e582f3\nPOLYGON ((409575.733 284753.232, 409442.619 28...\nBirmingham\n[E01009339, E01009363, E01009368, E01009371, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\n\n\n2011 rows × 16 columns\n\n\n\n\n\n\n32.1.4 Making a dictionary of the existing allocations\nFirst, let’s make ourselves a dictionary. In this dictionary, the keys will be the centre/dispatcher, and the values will be a list of all LSOAs that currently belong to that dispatcher.\n\n# Get a list of the unique dispatchers\ndispatchers = bham_region['centre_dispatcher'].unique()\ndispatchers.sort()\n\ndispatcher_starting_allocation_dict = {}\n\nfor dispatcher in dispatchers:\n    dispatcher_allocation = bham_region[bham_region[\"centre_dispatcher\"] == dispatcher]\n\n    dispatcher_starting_allocation_dict[dispatcher] = dispatcher_allocation[\"LSOA11CD\"].unique()\n\nLet’s look at what that looks like for one of the dispatchers. Using this, we can access a full list of their LSOAs whenever we need it.\n\ndispatcher_starting_allocation_dict['Centre 2-3']\n\narray(['E01032279', 'E01032280', 'E01032281', 'E01032282', 'E01032283',\n       'E01032284', 'E01032285', 'E01032286', 'E01032287', 'E01032288',\n       'E01032289', 'E01032290', 'E01032292', 'E01032294', 'E01032295',\n       'E01032296', 'E01032297', 'E01032298', 'E01032299', 'E01032300',\n       'E01032301', 'E01032302', 'E01032303', 'E01032304', 'E01032305',\n       'E01032306', 'E01032307', 'E01032308', 'E01032309', 'E01032310',\n       'E01032311', 'E01032312', 'E01032313', 'E01032314', 'E01032315',\n       'E01032316', 'E01032317', 'E01032318', 'E01032319', 'E01032320',\n       'E01032321', 'E01032322', 'E01032323', 'E01032324', 'E01032325',\n       'E01032326', 'E01032327', 'E01032328', 'E01032329', 'E01032330',\n       'E01032331', 'E01032332', 'E01032333', 'E01032334', 'E01032335',\n       'E01032336', 'E01032337', 'E01032338', 'E01032339', 'E01032345',\n       'E01032346', 'E01032354', 'E01032355', 'E01032357', 'E01032358',\n       'E01032359', 'E01032360', 'E01032361', 'E01032362', 'E01032363',\n       'E01032364', 'E01032365', 'E01032366', 'E01032367', 'E01032368',\n       'E01032369', 'E01032370', 'E01032371', 'E01032386', 'E01032387',\n       'E01032388', 'E01032389', 'E01032390', 'E01032392', 'E01032393',\n       'E01032394', 'E01032395', 'E01032399', 'E01032400', 'E01032401',\n       'E01032402', 'E01032403', 'E01032404', 'E01032410', 'E01032411',\n       'E01032414', 'E01032416', 'E01032417', 'E01033246', 'E01033247',\n       'E01033248', 'E01033249'], dtype=object)\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo start with, let’s build up our random walk algorithm step-by-step. At the end of this section, we’ll turn it into a reusable functions with some parameters to make it easier to use. After that, we’ll work on building a reusable function to help us quickly evaluate each solution we generate.\n\n\n\n\n32.1.5 Generating starting allocations\nThe first step will be to generate an initial starting point for each dispatcher.\nThere are a couple of different approaches we could take here - and maybe we’ll give our eventual algorithm the option to pick from several options.\n\nOption 1 - Use our new dictionary to select a random starting LSOA for each of our dispatchers from within their existing territories.\nOption 2 - Start with the most central region of the existing regions for each dispatcher.\nOption 3 - Provide each dispatcher with an entirely random starting point, regardless of the historical boundaries.\n\nThis could work nicely if we try to avoid\n\n\nOption 1\nWe could use our new dictionary to select a random starting LSOA for each of our dispatchers from within their existing territories. This will give us plenty of randomness - but we may find ourselves with walks that start very near the edge of our original patch, giving us very different boundaries to what existed before.\n\nimport random\n\nrandom_solution_starting_dict = {}\n\nfor key, value in dispatcher_starting_allocation_dict.items():\n\n    random_solution_starting_dict[key] = random.choice(value)\n\nrandom_solution_starting_dict\n\n{'Centre 1-1': 'E01028844',\n 'Centre 1-2': 'E01029475',\n 'Centre 1-3': 'E01010395',\n 'Centre 1-4': 'E01010475',\n 'Centre 1-5': 'E01009807',\n 'Centre 1-6': 'E01008933',\n 'Centre 1-7': 'E01010193',\n 'Centre 2-1': 'E01032138',\n 'Centre 2-2': 'E01032449',\n 'Centre 2-3': 'E01032417',\n 'Centre 2-4': 'E01032207',\n 'Centre 2-5': 'E01032233'}\n\n\nLet’s turn this into a reusable function, then visualise its functioning.\n\ndef create_random_starting_dict(input_dictionary):\n    random_solution_starting_dict = {}\n\n    for key, value in dispatcher_starting_allocation_dict.items():\n\n        random_solution_starting_dict[key] = random.choice(value)\n\n    return random_solution_starting_dict\n\ncreate_random_starting_dict(dispatcher_starting_allocation_dict)\n\n{'Centre 1-1': 'E01014110',\n 'Centre 1-2': 'E01029366',\n 'Centre 1-3': 'E01010279',\n 'Centre 1-4': 'E01010449',\n 'Centre 1-5': 'E01010106',\n 'Centre 1-6': 'E01009017',\n 'Centre 1-7': 'E01010123',\n 'Centre 2-1': 'E01032143',\n 'Centre 2-2': 'E01032478',\n 'Centre 2-3': 'E01032338',\n 'Centre 2-4': 'E01032212',\n 'Centre 2-5': 'E01031235'}\n\n\nNow, let’s generate some solutions and plot them.\nWe’ll also be using a dataframe from the previous chapter - the code for this can be found in the expander if you want to revisit this.\n\n\n\n\n\n\nClick here to see the code for generating our dispatch boundaries dataframe\n\n\n\n\n\n\n# Group by the specified column\ngrouped_dispatcher_gdf = bham_region.groupby(\"centre_dispatcher\")\n\n# Create a new GeoDataFrame for the boundaries of each group\nboundary_list = []\n\nfor group_name, group in grouped_dispatcher_gdf:\n    # Combine the polygons in each group into one geometry\n    combined_geometry = group.unary_union\n\n    # Get the boundary of the combined geometry\n    boundary = combined_geometry.boundary\n\n    # Add the boundary geometry and the group name to the list\n    boundary_list.append({'group': group_name, 'boundary': boundary})\n\n# Create a GeoDataFrame from the list of boundaries\ngrouped_dispatcher_gdf_boundary = geopandas.GeoDataFrame(boundary_list, geometry='boundary', crs=bham_region.crs)\n\ngrouped_dispatcher_gdf_boundary.head()\n\n\n\n\n\n\n\n\n\ngroup\nboundary\n\n\n\n\n0\nCentre 1-1\nMULTILINESTRING ((368935.969 274516.594, 36824...\n\n\n1\nCentre 1-2\nLINESTRING (412258.535 300984.197, 411756.668 ...\n\n\n2\nCentre 1-3\nLINESTRING (381775.908 282326.500, 380577.001 ...\n\n\n3\nCentre 1-4\nLINESTRING (388885.341 295185.385, 388630.406 ...\n\n\n4\nCentre 1-5\nLINESTRING (388258.095 285110.427, 388666.258 ...\n\n\n\n\n\n\n\n\n\n\n\nSome of the regions are quite small, so it may be hard to see them all!\n\n# First, let's plot the outline of our entire region\nax = bham_region.plot(\n    figsize=(10,7),\n    edgecolor='black',\n    linewidth=0.5,\n    color=\"white\"\n    )\n\n# Let's use our new function to generate a series of random starting patches\nsol = create_random_starting_dict(dispatcher_starting_allocation_dict)\n\n# We can filter our existing dataframe of allocations to just the starting patches\nrandom_solution_start = bham_region[bham_region['LSOA11CD'].isin(sol.values())]\n\n# Finally, we plot those on the same plot, colouring by centre-dispatcher combo\nrandom_solution_start.plot(\n    ax=ax,\n    column=\"centre_dispatcher\",\n    legend=True\n)\n\n# Let's also visualise the historical boundaries\ngrouped_dispatcher_gdf_boundary.plot(\n    ax=ax,\n    linewidth=2,\n    edgecolor=\"green\"\n)\n\n\n\n\n\n\n\n\nOption 2\nAnother alternative is to start with the most central region of the existing regions for each dispatcher.\n\nfrom shapely.geometry import Point\n\ndef find_most_central_polygon(gdf):\n    \"\"\"\n    Finds the most central polygon in a GeoDataFrame based on centroid proximity to the mean centroid.\n    \"\"\"\n    # Compute centroids of individual polygons\n    gdf[\"centroid\"] = gdf.geometry.centroid\n\n    # Calculate the mean centroid (central point)\n    mean_centroid = gdf.geometry.unary_union.centroid\n\n    # Compute distances from each centroid to the mean centroid\n    gdf[\"distance_to_mean\"] = gdf[\"centroid\"].distance(mean_centroid)\n\n    # Find the polygon with the minimum distance\n    central_polygon = gdf.loc[gdf[\"distance_to_mean\"].idxmin()]\n\n    return central_polygon\n\ndef get_central_polygon_per_group(gdf, grouping_col):\n    return gdf.groupby(grouping_col, group_keys=False).apply(find_most_central_polygon).drop(columns=[\"centroid\", \"distance_to_mean\"])\n\nmost_central = get_central_polygon_per_group(bham_region, \"centre_dispatcher\")\nmost_central\n\n\n\n\n\n\n\n\n\nFID\nLSOA11CD\nLSOA11NM\nLSOA11NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\ngeometry\nregion\nneighbors\nRegion\nCentre\nDispatcher\ncentre_dispatcher\n\n\ncentre_dispatcher\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCentre 1-1\n28095\nE01028832\nShropshire 033A\nShropshire 033A\n372082\n293080\n-2.41300\n52.53487\n945b5cd8-45bd-4f3a-8834-88082caa2473\nPOLYGON ((372799.246 293568.354, 372202.351 29...\nShropshire\n[E01028828, E01028830, E01028833, E01028834, E...\nShropshire\nCentre 1\n1\nCentre 1-1\n\n\nCentre 1-2\n28764\nE01029518\nLichfield 007D\nLichfield 007D\n411232\n307750\n-1.83534\n52.66736\n421455c3-c4b7-4505-880d-8412aa14c957\nPOLYGON ((412402.657 308666.999, 412311.329 30...\nLichfield\n[E01029488, E01029512, E01029519, E01029520, E...\nLichfield\nCentre 1\n2\nCentre 1-2\n\n\nCentre 1-3\n28875\nE01029631\nSouth Staffordshire 009E\nSouth Staffordshire 009E\n388142\n301842\n-2.17656\n52.61423\n6d0e4c4c-bf69-4f68-a086-46d1a80854d9\nPOLYGON ((387776.111 302749.666, 388831.796 30...\nSouth Staffordshire\n[E01010544, E01010546, E01029613, E01029615, E...\nSouth Staffordshire\nCentre 1\n3\nCentre 1-3\n\n\nCentre 1-4\n10215\nE01010521\nWolverhampton 020F\nWolverhampton 020F\n391688\n299252\n-2.12412\n52.59101\n5966f7f1-af15-4226-9d1e-6316101606b5\nPOLYGON ((391805.204 300349.956, 392207.285 29...\nWolverhampton\n[E01010426, E01010443, E01010463, E01010464, E...\nWolverhampton\nCentre 1\n4\nCentre 1-4\n\n\nCentre 1-5\n9743\nE01010043\nSandwell 025B\nSandwell 025B\n395995\n288750\n-2.06041\n52.49665\n3be670e2-fde7-4251-ad24-56335b4c30df\nPOLYGON ((396648.514 288801.684, 396670.147 28...\nSandwell\n[E01009843, E01009871, E01009888, E01009890, E...\nSandwell\nCentre 1\n5\nCentre 1-5\n\n\nCentre 1-6\n8940\nE01009204\nBirmingham 052E\nBirmingham 052E\n408607\n287498\n-1.87467\n52.48535\ne1aaf4f1-f7a4-4e98-9d74-855033a27584\nPOLYGON ((409131.178 287204.736, 408353.160 28...\nBirmingham\n[E01009199, E01009201, E01009203, E01033561, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\n\n\nCentre 1-7\n9809\nE01010109\nSolihull 009A\nSolihull 009A\n418665\n283710\n-1.72677\n52.45104\nd03080c8-368a-46af-9fed-b27cc051518e\nPOLYGON ((419807.904 285425.582, 419899.498 28...\nSolihull\n[E01009318, E01009320, E01010108, E01010110, E...\nSolihull\nCentre 1\n7\nCentre 1-7\n\n\nCentre 2-1\n31345\nE01032149\nBromsgrove 006D\nBromsgrove 006D\n399455\n274007\n-2.00941\n52.36413\n3b13e41d-e470-47c0-9830-cd654e36a32e\nPOLYGON ((399816.607 273656.656, 400092.197 27...\nBromsgrove\n[E01032143, E01032144, E01032148, E01032150, E...\nBromsgrove\nCentre 2\n1\nCentre 2-1\n\n\nCentre 2-2\n31667\nE01032477\nWyre Forest 008D\nWyre Forest 008D\n381330\n275610\n-2.27568\n52.37821\n4f0cf516-7c4b-4b61-a4da-da4423304f43\nPOLYGON ((381780.507 275809.361, 381793.089 27...\nWyre Forest\n[E01032451, E01032470, E01032471, E01032476, E...\nWyre Forest\nCentre 2\n2\nCentre 2-2\n\n\nCentre 2-3\n31535\nE01032345\nWychavon 007A\nWychavon 007A\n393387\n259105\n-2.09823\n52.23011\nb7f03ca0-aac0-4e29-b86c-95dd4a796fce\nPOLYGON ((396864.091 258452.893, 396188.712 25...\nWychavon\n[E01032346, E01032360, E01032361, E01032362, E...\nWychavon\nCentre 2\n3\nCentre 2-3\n\n\nCentre 2-4\n31391\nE01032199\nMalvern Hills 002C\nMalvern Hills 002C\n376434\n260160\n-2.34652\n52.23913\nc4525de8-e8d8-4d8b-9610-d887d58dbabb\nPOLYGON ((378353.003 262294.903, 378414.904 26...\nMalvern Hills\n[E01014001, E01032179, E01032181, E01032182, E...\nMalvern Hills\nCentre 2\n4\nCentre 2-4\n\n\nCentre 2-5\n30398\nE01031187\nStratford-on-Avon 007A\nStratford-on-Avon 007A\n414464\n258742\n-1.78965\n52.22670\n679c1798-8095-4712-a9b9-c495cca9dadd\nPOLYGON ((416799.690 260453.800, 416633.500 25...\nStratford-on-Avon\n[E01031188, E01031195, E01031204, E01031208, E...\nStratford-on-Avon\nCentre 2\n5\nCentre 2-5\n\n\n\n\n\n\n\n\nLet’s plot this.\n\n# First, let's plot the outline of our entire region\nax = bham_region.plot(\n    figsize=(10,7),\n    edgecolor='black',\n    linewidth=0.5,\n    color=\"white\"\n    )\n\n# Plot those on the same plot, colouring by centre-dispatcher combo\nmost_central.plot(\n    ax=ax,\n    column=\"centre_dispatcher\",\n    legend=True\n)\n\n# Let's also visualise the historical boundaries\ngrouped_dispatcher_gdf_boundary.plot(\n    ax=ax,\n    linewidth=2,\n    edgecolor=\"green\"\n)\n\n\n\n\n\n\n\n\nYou can see that in some regions the most central point can still be on a boundary, even\n\n\n32.1.6 Generating our new regions\nAs a recap, what we want to do now is introduce a number of ‘players’ who will play a territory-grabbing game. Our ‘players’ - the dispatchers - will each have a single turn, pass control to the next dispatcher, and so on.\nOn each turn, they will be presented with a long list of the regions that share a boundary with any of their existing territories. They will then choose a territory at random from that list.\nHowever, this doesn’t mean their territory will expand on every turn.\n\nThe territory that they choose could be one of their existing territories (as we are checking for a boundary with any of their existing territories on a per-territory basis - not the outer boundary of their entire territory)\nThere will also be a random chance introduced that they just don’t take a go\nThey may also try to take a territory that is already owned by a different dispatcher, in which case they will not gain anything on the turn - though we could always add in an option like them ‘battling’ for the territory\n\nSo let’s start coding this!\nFirst, let’s work on the logic for selecting a territory from their existing list. We’ll just do this with a single dispatcher for now.\nWe’ll filter down to this and remind ourselves what the available data on neighbouring territory looks like.\n\n# We'll start with dispatcher 5 from centre 2, and we'll use the most central point of their existing territory\n\ndispatcher = \"Centre 2-5\"\n\nstarting_point = most_central[most_central[\"centre_dispatcher\"] == dispatcher]\n\nstarting_point['neighbors']\n\ncentre_dispatcher\nCentre 2-5    [E01031188, E01031195, E01031204, E01031208, E...\nName: neighbors, dtype: object\n\n\nLet’s now pick a random neighbour, and work out a way to store the new allocations so we can ensure we know who owns what territory, and we don’t end up with a situation where two dispatchers own the same territory.\n\nowned_territory_dict = {}\n\nowned_territory_dict[dispatcher] = [starting_point['LSOA11CD'].values[0]]\n\nowned_territory_dict\n\n{'Centre 2-5': ['E01031187']}\n\n\n\nselected_territory = random.choice(starting_point['neighbors'].values[0])\n\nselected_territory\n\n'E01031218'\n\n\n\nowned_territory_dict[dispatcher].append(selected_territory)\n\nowned_territory_dict\n\n{'Centre 2-5': ['E01031187', 'E01031218']}\n\n\nFantastic! We now have a simple way to get and store this.\nLet’s have a go at giving another dispatcher a turn to grab territory.\n\ndispatcher = \"Centre 1-1\"\n\nstarting_point = most_central[most_central[\"centre_dispatcher\"] == dispatcher]\n\n# This time we add to the existing dict rather than setting it up anew\nowned_territory_dict[dispatcher] = [starting_point['LSOA11CD'].values[0]]\n\n# Now we do our random selection\nselected_territory = random.choice(starting_point['neighbors'].values[0])\n\nowned_territory_dict[dispatcher].append(selected_territory)\n\nowned_territory_dict\n\n{'Centre 2-5': ['E01031187', 'E01031218'],\n 'Centre 1-1': ['E01028832', 'E01028834']}\n\n\nThis is a good step, and for now we’re unlikely to run into the issue of different dispatchers owning the same territory - though it’s not impossible! So let’s add in another dispatcher, but this time we’ll check first that it’s not owned by anyone.\nFirst, let’s pull back the full list of owned territories from our dict.\n\nlist(owned_territory_dict.values())\n\n[['E01031187', 'E01031218'], ['E01028832', 'E01028834']]\n\n\nWe’ll need to convert this into a single list. We could use a for loop, or a list comprehension.\n\nterritory_list = [element for sub_list in list(owned_territory_dict.values()) for element in sub_list]\n\n# By using set, then list on the result of that, we get a list of unique values\nterritory_list = list(set(territory_list))\n\nterritory_list\n\n['E01031218', 'E01028832', 'E01028834', 'E01031187']\n\n\nNow we can use this in our checks.\n\ndispatcher = \"Centre 1-5\"\n\nstarting_point = most_central[most_central[\"centre_dispatcher\"] == dispatcher]\n\nowned_territory_dict[dispatcher] = [starting_point['LSOA11CD'].values[0]]\n\nselected_territory = random.choice(starting_point['neighbors'].values[0])\n\n# Only add the territory if it's not already in the list of owned territory\nif selected_territory not in territory_list:\n    owned_territory_dict[dispatcher].append(selected_territory)\n\nowned_territory_dict\n\n{'Centre 2-5': ['E01031187', 'E01031218'],\n 'Centre 1-1': ['E01028832', 'E01028834'],\n 'Centre 1-5': ['E01010043', 'E01010044']}\n\n\n\n\n32.1.7 Writing the function\nThat’s most of the key elements of our function written now - so let’s actually turn it into a function that will continue to run until all of the territory has been allocated.\nFor clarity and ease of use, we’ll set up our defaults to relate to our current objects - but for a more reusable function, it may be better to avoid defaults but be very clear in the docstring what is expected as an input, and add in some error handling to manage cases that don’t match.\n\ndef generate_random_territory_allocation(\n    gdf=bham_region,\n    territory_unit_column=\"LSOA11CD\",\n    player_list=bham_region[\"centre_dispatcher\"].unique(),\n    player_column=\"centre_dispatcher\",\n    starting_territories=most_central,\n    neighbor_column='neighbors',\n    skipgo_chance=0.03,\n    return_df=True\n    ):\n\n    # Initialise the territory list as the starting territories\n    owned_territory_list = list(starting_territories[territory_unit_column].unique())\n\n    # Set up the starting territory for each individual and have each player have their first go\n    for player in player_list:\n        starting_point = starting_territories[starting_territories[player_column] == player]\n\n        owned_territory_dict[player] = [starting_point[territory_unit_column].values[0]]\n\n        selected_territory = random.choice(starting_point['neighbors'].values[0])\n\n        # Only add the territory if it's not already in the list of owned territory\n        if selected_territory not in owned_territory_list:\n            owned_territory_dict[player].append(selected_territory)\n            # As we're now going to be iterating and checking throughout, we can just\n            # maintain the owned territory list as we go along, which is a bit easier and\n            # more efficient than generating it from the territory dict each time\n            owned_territory_list.append(selected_territory)\n\n    # Keep going through the following process until all territory has been allocated\n    while len(owned_territory_list) &lt; len(gdf[territory_unit_column].unique()):\n        # Go around all individuals\n        for player in player_list:\n            if random.random() &gt; skipgo_chance:\n                # Select a random existing territory from the list of owned territories\n                chosen_owned_territory = random.choice(owned_territory_dict[player])\n                # Then find the neighbours\n                neighbors = gdf[gdf[territory_unit_column] == chosen_owned_territory][neighbor_column].values[0]\n                # Choose a random neighbour and update the list of owned territories...\n                selected_territory = random.choice(neighbors)\n\n                #... if not already owned\n                if selected_territory not in owned_territory_list:\n                    owned_territory_dict[player].append(selected_territory)\n                    owned_territory_list.append(selected_territory)\n\n\n    if return_df:\n        owned_territory_df = pd.DataFrame(\n            [(key, value) for key, values in owned_territory_dict.items() for value in values],\n            columns=[f\"{player_column}_NEW\", territory_unit_column])\n        return pd.merge(gdf, owned_territory_df, on=territory_unit_column, how=\"left\")\n    else:\n        return owned_territory_dict\n\nLet’s try our new function out and see what it returns.\n\nrandom_allocation_test = generate_random_territory_allocation()\n\nrandom_allocation_test\n\n\n\n\n\n\n\n\n\nFID\nLSOA11CD\nLSOA11NM\nLSOA11NMW\nBNG_E\nBNG_N\nLONG\nLAT\nGlobalID\ngeometry\nregion\nneighbors\nRegion\nCentre\nDispatcher\ncentre_dispatcher\ncentre_dispatcher_NEW\n\n\n\n\n0\n8649\nE01008881\nBirmingham 067A\nBirmingham 067A\n412690\n285438\n-1.81463\n52.46675\nf79cd8fb-0cf2-4c84-b07c-55bffcf379bb\nPOLYGON ((413040.413 285809.794, 413145.440 28...\nBirmingham\n[E01008882, E01008883, E01008885, E01008886, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-7\n\n\n1\n8650\nE01008882\nBirmingham 066A\nBirmingham 066A\n411772\n285390\n-1.82814\n52.46634\ne7835311-f105-4c92-acae-ecd5255ce534\nPOLYGON ((412233.657 285480.231, 412255.373 28...\nBirmingham\n[E01008881, E01008883, E01008884, E01008898, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-7\n\n\n2\n8651\nE01008883\nBirmingham 078A\nBirmingham 078A\n412121\n285001\n-1.82302\n52.46283\n29dbcbc2-4a29-4bb1-addb-42b37d91c647\nPOLYGON ((412775.838 285204.808, 412575.845 28...\nBirmingham\n[E01008881, E01008882, E01008884, E01008886, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-7\n\n\n3\n8652\nE01008884\nBirmingham 078B\nBirmingham 078B\n411241\n284712\n-1.83598\n52.46025\ndf5a2350-a102-4ecc-b028-5a0bbeded198\nPOLYGON ((411803.096 284902.674, 411563.054 28...\nBirmingham\n[E01008882, E01008883, E01008887, E01008889, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n4\n8653\nE01008885\nBirmingham 076A\nBirmingham 076A\n413207\n284818\n-1.80704\n52.46116\n13a855fc-fa09-42a5-a05e-947fcd141ce4\nPOLYGON ((413417.353 284803.764, 413034.282 28...\nBirmingham\n[E01008881, E01008886, E01008888, E01009521]\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-7\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2006\n32722\nE01033646\nBirmingham 031I\nBirmingham 031I\n410257\n291057\n-1.85027\n52.51731\nc7a17445-f800-41bc-86fb-cbeb9cde5d3f\nPOLYGON ((410651.278 291571.301, 410562.002 29...\nBirmingham\n[E01009000, E01009007, E01009013, E01009401, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n2007\n32723\nE01033647\nBirmingham 058E\nBirmingham 058E\n410473\n286828\n-1.84722\n52.47929\n7d745c12-8e35-404d-b96d-f2b3c3e92896\nPOLYGON ((410665.117 286998.178, 410753.991 28...\nBirmingham\n[E01009194, E01009197, E01009198, E01009331, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n2008\n32724\nE01033648\nBirmingham 084F\nBirmingham 084F\n408315\n283740\n-1.87907\n52.45157\ned410ea7-fc12-42bd-8604-4a54fab04b9f\nPOLYGON ((408199.966 283979.204, 408378.884 28...\nBirmingham\n[E01009376, E01009377, E01009383, E01009384, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n2009\n32725\nE01033649\nBirmingham 058F\nBirmingham 058F\n410530\n287142\n-1.84637\n52.48211\na8880f7b-a92b-43da-bf8d-b673ed85c526\nPOLYGON ((410728.297 287314.945, 410665.117 28...\nBirmingham\n[E01009194, E01009195, E01009197, E01033647]\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n2010\n32726\nE01033650\nBirmingham 077F\nBirmingham 077F\n409357\n284898\n-1.86370\n52.46196\n2868f08d-b3bd-4e47-b985-ce8484e582f3\nPOLYGON ((409575.733 284753.232, 409442.619 28...\nBirmingham\n[E01009339, E01009363, E01009368, E01009371, E...\nBirmingham\nCentre 1\n6\nCentre 1-6\nCentre 1-6\n\n\n\n\n2011 rows × 17 columns\n\n\n\n\nLet’s see how much this differs from the original allocation.\n\n# Plot the new boundaries using colours\nax = random_allocation_test.plot(\n    column=\"centre_dispatcher_NEW\"\n)\n\n# Visualise the historical boundaries\ngrouped_dispatcher_gdf_boundary.plot(\n    ax=ax,\n    linewidth=2,\n    edgecolor=\"black\"\n)\n\n\n\n\n\n\n\n\n\n\n32.1.8 Comparing a new solution to the current allocation\nFor now, we’re going to judge a solution on a single criteria - the average absolute difference in demand across\nThis is calculated by calculating the difference in total demand experiences by one dispatcher from the average across all dispatchers. We then take the absolute value - i.e. if the difference is negative (the dispatcher received fewer calls than the average), we will turn it into a postive. Finally, we take the average across these values.\nWe’ll create a function to do this.\n\ndef evaluate_solution(gdf, allocation_column='centre_dispatcher_NEW', demand_column=\"demand\"):\n    grouped_by_dispatcher = gdf.groupby(allocation_column)[[demand_column]].sum()\n    mean_demand = grouped_by_dispatcher['demand'].mean()\n\n    grouped_by_dispatcher['difference_from_mean'] = (grouped_by_dispatcher['demand'] - mean_demand).astype('int')\n\n    return abs(grouped_by_dispatcher['difference_from_mean']).mean().round(1)\n\nAnd now let’s try this out on our original and new solutions\n\ndemand = pd.read_csv(\"demand_pop_bham.csv\")\n\nrandom_allocation_test = random_allocation_test.merge(demand, on=\"LSOA11CD\")\n\noriginal_result = evaluate_solution(random_allocation_test, allocation_column='centre_dispatcher')\nnew_result = evaluate_solution(random_allocation_test, allocation_column='centre_dispatcher_NEW')\n\nprint(f\"Original Allocation: {original_result}\")\nprint(f\"Random Solution 1: {new_result}\")\n\nif original_result &gt; new_result:\n    print(\"The randomly generated solution gives a more even allocation of events than the original dispatcher allocations\")\nelse:\n    print(\"The randomly generated solution is worse than the original dispatcher allocations\")\n\nOriginal Allocation: 20934.4\nRandom Solution 1: 12557.9\nThe randomly generated solution gives a more even allocation of events than the original dispatcher allocations",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Boundary Problems - Creating and Evaluating Simple Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_varying_evaluating_simple.html#trying-this-out-for-more-solutions",
    "href": "boundary_problems_varying_evaluating_simple.html#trying-this-out-for-more-solutions",
    "title": "32  Boundary Problems - Creating and Evaluating Simple Solutions",
    "section": "32.2 Trying this out for more solutions",
    "text": "32.2 Trying this out for more solutions\nLet’s now run this for 20 different solutions and store the results.\n\ndef evaluate_solution_dict(solution_dict, gdf, allocation_column='centre_dispatcher', demand_column=\"demand\", territory_unit_column=\"LSOA11CD\"):\n\n    owned_territory_df = pd.DataFrame(\n            [(key, value) for key, values in solution_dict.items() for value in values],\n            columns=[f\"{allocation_column}_NEW\", territory_unit_column])\n    gdf = pd.merge(gdf, owned_territory_df, on=territory_unit_column, how=\"left\")\n\n    grouped_by_dispatcher = gdf.groupby(f\"{allocation_column}_NEW\")[[demand_column]].sum()\n    mean_demand = grouped_by_dispatcher['demand'].mean()\n\n    grouped_by_dispatcher['difference_from_mean'] = (grouped_by_dispatcher['demand'] - mean_demand).astype('int')\n\n    return abs(grouped_by_dispatcher['difference_from_mean']).mean().round(1)\n\n\n# Ensure our dataframe has the demand column\nimport copy\n\nbham_region = bham_region.merge(demand, on=\"LSOA11CD\")\n\nsolutions = []\n\nfor i in range(20):\n    allocations = generate_random_territory_allocation(return_df=False)\n    allocation_evaluation = evaluate_solution_dict(solution_dict=allocations, gdf=bham_region)\n    solutions.append({\n        'solution': i+1,\n        # We can't just pass the dictionary here due to the way python handles dictionaries\n        # We need to explicitly take a copy of the dictionary\n        'allocations': copy.deepcopy(allocations),\n        'result': allocation_evaluation\n    })\n\nsolution_df = pd.DataFrame(solutions)\nsolution_df['rank'] = solution_df['result'].rank(method='max')\n\nsolution_df.to_pickle('solutions_example.pkl')\n\nsolution_df.sort_values('rank', ascending=True)\n\n\n\n\n\n\n\n\n\n\n\nsolution\nallocations\nresult\nrank\n\n\n\n\n0\n1\n{'Centre 2-5': ['E01031187', 'E01031204', 'E01...\n14735.8\n20.0\n\n\n1\n2\n{'Centre 2-5': ['E01031187', 'E01031204', 'E01...\n12226.2\n9.0\n\n\n2\n3\n{'Centre 2-5': ['E01031187', 'E01031195', 'E01...\n12418.8\n11.0\n\n\n3\n4\n{'Centre 2-5': ['E01031187', 'E01031188', 'E01...\n12567.1\n12.0\n\n\n4\n5\n{'Centre 2-5': ['E01031187', 'E01031204', 'E01...\n12399.0\n10.0\n\n\n5\n6\n{'Centre 2-5': ['E01031187', 'E01031218', 'E01...\n9842.8\n2.0\n\n\n6\n7\n{'Centre 2-5': ['E01031187', 'E01031218', 'E01...\n10869.2\n4.0\n\n\n7\n8\n{'Centre 2-5': ['E01031187', 'E01031218', 'E01...\n12088.3\n8.0\n\n\n8\n9\n{'Centre 2-5': ['E01031187', 'E01031208', 'E01...\n11218.6\n6.0\n\n\n9\n10\n{'Centre 2-5': ['E01031187', 'E01031195', 'E01...\n9651.1\n1.0\n\n\n10\n11\n{'Centre 2-5': ['E01031187', 'E01031204', 'E01...\n11043.4\n5.0\n\n\n11\n12\n{'Centre 2-5': ['E01031187', 'E01031188', 'E01...\n13632.6\n18.0\n\n\n12\n13\n{'Centre 2-5': ['E01031187', 'E01031204', 'E01...\n13954.4\n19.0\n\n\n13\n14\n{'Centre 2-5': ['E01031187', 'E01031218', 'E01...\n13443.9\n17.0\n\n\n14\n15\n{'Centre 2-5': ['E01031187', 'E01031208', 'E01...\n10811.3\n3.0\n\n\n15\n16\n{'Centre 2-5': ['E01031187', 'E01031188', 'E01...\n12831.8\n13.0\n\n\n16\n17\n{'Centre 2-5': ['E01031187', 'E01031208', 'E01...\n13103.8\n14.0\n\n\n17\n18\n{'Centre 2-5': ['E01031187', 'E01031195', 'E01...\n11401.2\n7.0\n\n\n18\n19\n{'Centre 2-5': ['E01031187', 'E01031213', 'E01...\n13196.2\n16.0\n\n\n19\n20\n{'Centre 2-5': ['E01031187', 'E01031195', 'E01...\n13126.5\n15.0",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Boundary Problems - Creating and Evaluating Simple Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_refining_solutions.html",
    "href": "boundary_problems_refining_solutions.html",
    "title": "33  (WIP) Boundary Problems - Refining Solutions",
    "section": "",
    "text": "33.0.1 Evolving a solution\nThe sheer number of possible solutions makes this a tricky problem to solve!\nWe could keep generating a very large number of random solutions, and this may work to eventually find a near-optimal solution, but could be extremely time-consuming and resource-intensive, requiring many hours of compute power.\nInstead, let’s try taking some inspiration from the natural world and evolving our solutions until they are as good as can be.\n\n\n\n\n\n\nTip\n\n\n\nThis is a big part of the field of operational research, with certain algorithms like NSGA-II being well-known and defined, and implemented in libraries that you can reuse. However, you can also create your own genetic algorithms or modify approaches like NSGA-II, as done in Allen et al. and their work on hyperacute stroke unit modelling.\n\n\n\n\n\n\n\n\nNote\n\n\n\nDue to the requirements for solutions to follow certain rules, evolving our solutions is somewhat more complex than in the case of our location allocation problem, where any combination of centres was theoretically ‘valid’. In that instance, we could randomly permute or mix solutions with no concerns surrounding what the output looked like beyond not being an exact duplicate of an already-evaluated solution. Here, with a need to generate a solution that conforms to rules like the dispatcher’s patch being continuous,\n\n\nSo what will the process look like in this case?\n\nWe will generate a new random solution using our function from the previous\nWe will evaluate that solution\nIf this solution is worse than the current status quo, we will generate a new random solution (and keep doing so until we find a solution that performs ‘better’ than the current status quo)\nIf this solution is better than the current status quo, we will then start to evolve this solution\n\nfor each ‘player’ (in this case, our dispatchers), we will randomly add or remove one of their regions and allocate it to one of the other players for whom it would be valid territory (i.e. they share a boundary with the territory in question)\n\nwe will then assess the performance of this solution\n\nwe will continue this until there has been no improvement for several rounds of attempts (which will be a parameter we can vary)\n\nas the evaluation of solutions is much quicker than generating brand new solutions with the method we developed in the previous round, we should see much faster movement towards a ‘good’ solution\n\n\nWe will then store the performance of this solution, then start with a new random solution and continue\n\nTo start with, let’s load our random solutions from the last chapter back in.\n\nimport pandas as pd\n\ninitial_solution_df = pd.read_pickle('solutions_example.pkl')\n\ninitial_solution_df.to_csv('solutions_example.csv')\n\nLet’s write a quick function to pull out the allocations from our solutions file, and turn that back into a dataframe we can work with.\n\ndef extract_allocation_df_from_solution_df(df, solution_rank, allocation_col_name, territory_col_name):\n    row_of_interest = df[df['rank'] == solution_rank]\n    owned_territory_dict = row_of_interest['allocations'].values[0]\n\n    owned_territory_df = pd.DataFrame(\n            [(key, value) for key, values in owned_territory_dict.items() for value in values],\n            columns=[allocation_col_name, territory_col_name])\n    return owned_territory_df\n\nLet’s now try this out to pull back and visualise our best solution.\n\nbest_solution = extract_allocation_df_from_solution_df(\n    initial_solution_df,\n    solution_rank=1,\n    allocation_col_name=\"centre_dispatcher_NEW\",\n    territory_col_name=\"LSOA11CD\"\n    )\n\nbest_solution\n\n\n\n\n\n\n\n\n\ncentre_dispatcher_NEW\nLSOA11CD\n\n\n\n\n0\nCentre 2-5\nE01031187\n\n\n1\nCentre 2-5\nE01031195\n\n\n2\nCentre 2-5\nE01031217\n\n\n3\nCentre 2-5\nE01031204\n\n\n4\nCentre 2-5\nE01031213\n\n\n...\n...\n...\n\n\n2006\nCentre 2-2\nE01009724\n\n\n2007\nCentre 2-2\nE01009720\n\n\n2008\nCentre 2-2\nE01009723\n\n\n2009\nCentre 2-2\nE01009725\n\n\n2010\nCentre 2-2\nE01009730\n\n\n\n\n2011 rows × 2 columns\n\n\n\n\n\n\n\n\n\n\nClick here to view code from previous chapters for importing our historical boundary and demand data\n\n\n\n\n\n\nimport geopandas\n\nlsoa_geojson_path = 'https://github.com/hsma-programme/h6_3c_interactive_plots_travel/raw/main/h6_3c_interactive_plots_travel/example_code/LSOA_2011_Boundaries_Super_Generalised_Clipped_BSC_EW_V4.geojson'\n\nlsoa_boundaries = geopandas.read_file(lsoa_geojson_path)\n\nxmin, xmax = 370000, 420000\nymin, ymax = 250000, 310000\n\nbham_region = lsoa_boundaries.cx[xmin:xmax, ymin:ymax]\n\nbham_region[\"region\"] = bham_region[\"LSOA11NM\"].str[:-5]\n\nboundary_allocations_df = pd.read_csv(\"boundary_allocations.csv\")\n\nbham_region = pd.merge(\n    bham_region,\n    boundary_allocations_df,\n    left_on=\"region\",\n    right_on=\"Region\",\n    how=\"left\"\n)\n\nbham_region[\"centre_dispatcher\"] = bham_region[\"Centre\"].astype(\"str\") + '-' + bham_region[\"Dispatcher\"].astype(\"str\")\n\ndemand = pd.read_csv(\"demand_pop_bham.csv\")\n\nbham_region = bham_region.merge(demand, on=\"LSOA11CD\")\n\n# Create df of original boundaries\ngrouped_dispatcher_gdf = bham_region.groupby(\"centre_dispatcher\")\n\n# Create a new GeoDataFrame for the boundaries of each group\nboundary_list = []\n\nfor group_name, group in grouped_dispatcher_gdf:\n    # Combine the polygons in each group into one geometry\n    combined_geometry = group.unary_union\n\n    # Get the boundary of the combined geometry\n    boundary = combined_geometry.boundary\n\n    # Add the boundary geometry and the group name to the list\n    boundary_list.append({'group': group_name, 'boundary': boundary})\n\n# Create a GeoDataFrame from the list of boundaries\ngrouped_dispatcher_gdf_boundary = geopandas.GeoDataFrame(boundary_list, geometry='boundary', crs=bham_region.crs)\n\n/home/sammi/.local/lib/python3.10/site-packages/geopandas/geodataframe.py:1528: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\n\n\nax=bham_region.merge(best_solution, on=\"LSOA11CD\").plot(column=\"centre_dispatcher_NEW\")\n\n# Visualise the historical boundaries\ngrouped_dispatcher_gdf_boundary.plot(\n    ax=ax,\n    linewidth=2,\n    edgecolor=\"black\"\n)\n\n\n\n\n\n\n\n\nAnd let’s compare this with our worst-performing solution.\n\n\n\n\n\n\nClick here to see the code\n\n\n\n\n\n\nworst_solution = extract_allocation_df_from_solution_df(\n    initial_solution_df,\n    solution_rank=20,\n    allocation_col_name=\"centre_dispatcher_NEW\",\n    territory_col_name=\"LSOA11CD\"\n    )\n\nax=bham_region.merge(worst_solution, on=\"LSOA11CD\").plot(column=\"centre_dispatcher_NEW\")\n\n# Visualise the historical boundaries\ngrouped_dispatcher_gdf_boundary.plot(\n    ax=ax,\n    linewidth=2,\n    edgecolor=\"black\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nCode coming soon!",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>(WIP) Boundary Problems - Refining Solutions</span>"
    ]
  },
  {
    "objectID": "boundary_problems_multiobjective_optimisation.html",
    "href": "boundary_problems_multiobjective_optimisation.html",
    "title": "34  (WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics",
    "section": "",
    "text": "34.1 Defining a score function\nLet’s start building ourselves an adaptable function that we can build on to gradually add more objectives to.",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>(WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics</span>"
    ]
  },
  {
    "objectID": "boundary_problems_multiobjective_optimisation.html#defining-a-score-function",
    "href": "boundary_problems_multiobjective_optimisation.html#defining-a-score-function",
    "title": "34  (WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics",
    "section": "",
    "text": "Note\n\n\n\nThis approach is inspired by the work undertaken here by Mike Allen, Kerry Pearn, Emma Villeneuve, Thomas Monks, Ken Stein and Martin James\n\n\n\n\n\n\n\n\nTip\n\n\n\nNote that here we’ve defined some scores that are specifically applicable to the problem we are targeting. However, the function could be adapted to use as many or as few of these, or as many other scoring criteria, as you wish. Take a look at the example linked above to see how you could bring some other criteria in, such as travel times.\n\n\n\n34.1.1 Determining whether a solution is better or worse than another solution.\nIt’s also worth mentioning at this point the criteria that we will be using for determining whether a solution is ‘better’ than another as we progressively test multiple solutions.\nThis is a bit more complex to define than with a single-objective problem, where we could simply define whether a higher or lower score was better in the given context.\nInstead, here we will use the idea of ‘dominance’.\nLet’s visualise our scores as a list of numbers, with each number representing the. In this example, we’ll assume a higher score is always better.\nSolution 1: [1   6   8]\nSolution 2: [2   6   9]\n\n\n\n\n\n\nNote\n\n\n\nThe technical definition of dominance in this context is\n\n“A vector a of the objective space dominates another vector b if all criteria of a are better or equal to criteria of b and a≠b”1\n\nThis simply means that\n\nthe outputs are not identical\nevery score has to be better than or at least equal to the solution we are comparing against\n\nA solution is non-dominated if - the score for one criteria is better than at least one score in another solution - all remaining scores are at least equal to the other scores\nAfter evaluating multiple solutions, you will end up with a series of non-dominated solutions that form the Pareto Front.\n\n\nSo in this case, solution 2 would be better than solution 1 as it is no worse than solution 1 in any respect, and better in some respects.\n\n\n34.1.2 Trade-offs\nIt’s also worth considering that when we start to look at solutions to multi-objective problems, we will generally be unable to find a single ‘best’ solution that performs optimally across every single objective.\nThere will usually be some level of trade-off to be had, with some solutions performing better in one aspect than in others. Generating, evaluating and capturing a wide range of solutions and their scores can help us to start understanding - and visualising - what this trade-off looks like.\n\n\n34.1.3 Code for the scoring function\n\n\n\n\n\n\nTip\n\n\n\nOptimizing on every score at once can be slow; it’s a good idea to build the ability into your function to turn the scoring of objectives on and off.\n\n\n\nimport numpy as np\n\ndef score(dispatcher_allocations, pareto_include, weighting=None, calc_all=False):\n    \"\"\"\n    Evaluates a population of proposed boundaries based on multiple performance metrics.\n\n    This function calculates a variety of metrics related to.\n\n    Parameters that are scored on are:\n    1. Total number of calls per dispatcher\n        (minimise DIFFERENCE between total calls per dispatcher across all dispatchers in the solution)\n    2. Maximum number of calls controlled by a single dispatcher\n        (minimise - we want no individual dispatchers to be receiving an unusually low number of calls compared to other dispatchers)\n    3. Minimum number of calls controlled by a single dispatcher\n        (maximise - we want no individual dispatchers to be receiving an unusually high number of calls compared to other dispatchers)\n    4. Total number of resources controlled per dispatcher\n        (minimise DIFFERENCE between the number of resources controlled by each dispatcher in the solution)\n\n    It supports Pareto-based evaluation, computing only the necessary metrics unless CALC_ALL is set to True, in which case all metrics are calculated.\n\n\n    Parameters\n    ----------\n    dispatcher_allocations: dict\n\n    pareto_include: list\n        List of booleans relating to the objectives\n        e.g. evaluating objectives 1 and 4 only would require the list [True, False, False, True]\n\n    weighting: opt, list\n        List of weights for the objectives. Weights should be positive.\n        If None, it will be assumed that all objectives are equally important (have equal weighting).\n        If passed, length must be equal to the number of pareto objectives.\n\n    calc_all: boolean\n        If true, pareto_include will be ignored and all metrics will be used for calculations\n    \"\"\"\n\n    # CODER HERE TO CALCULATE THE\n\n    return (score_matrix, call_matrix, resource_allocation_matrix)\n\n\n\n\ndef normalise_score(score_matrix, norm_matrix):\n    \"\"\"\n    Normalises a 'score matrix' with reference to 'norm matrix' which gives scores that produce zero or one\n\n    Notes\n    -----\n\n    Based on the approach in [GitHub Link](https://github.com/MichaelAllen1966/stroke_unit_location/blob/master/pyf_ga05_functions_170406.py)\n    The referenced code is licensed under Apache 2.0.\n    \"\"\"\n\n    norm_score=np.zeros(np.shape(score_matrix)) # create normlaises score matrix with same dimensions as original scores\n    number_of_scores=len(score_matrix[0,:]) # number of different scores\n    for col in range(number_of_scores): # normaise for each score in turn\n        score_zero=norm_matrix[col,0]\n        score_one=norm_matrix[col,1]\n        score_range=score_one-score_zero\n        norm_score[:,col]=(score_matrix[:,col]-score_zero)/score_range\n    return norm_score\n\ndef pareto(scores):\n    \"\"\"\n    This function takes an array or list of 'scores' and returns a Boolean numpy array identifying which rows of the array 'scores' are non-dominated (the Pareto front).\n\n    Scores should be normalised so that higher values dominate lower values.\n\n    The method is based on assuming everything starts on Pareto front, and then dominated points are recorded\n\n    Parameters\n    ----------\n    scores: list or numpy array\n\n    Returns\n    -------\n    numpy array\n        returns a Boolean numpy array identifying which rows of the array 'scores' are non-dominated (the Pareto front). Dominated scores are identified with a 0.\n\n    Notes\n    -----\n\n    Based on the approach in [GitHub Link](https://github.com/MichaelAllen1966/stroke_unit_location/blob/master/pyf_ga05_functions_170406.py)\n    The referenced code is licensed under Apache 2.0.\n    \"\"\"\n    if isinstance(scores, np.ndarray):\n        pop_size=len(scores[:,0])\n    elif type(scores) == 'list':\n        pop_size=len(scores)\n\n    pareto_front=np.ones(pop_size, dtype=bool)\n\n    for i in range(pop_size):\n        for j in range(pop_size):\n            if all (scores[j]&gt;=scores[i]) and any (scores[j]&gt;scores[i]):\n                # j dominates i\n                pareto_front[i]=0\n                break\n\n    return pareto_front",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>(WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics</span>"
    ]
  },
  {
    "objectID": "boundary_problems_multiobjective_optimisation.html#footnotes",
    "href": "boundary_problems_multiobjective_optimisation.html#footnotes",
    "title": "34  (WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics",
    "section": "",
    "text": "Zhou A, Qu B-Y, Li H, et al. Multiobjective evolutionary algorithms: A survey of the state of the art. Swarm Evol Comput 2011;1:32–49. doi:10.1016/j.swevo.2011.03.001↩︎",
    "crumbs": [
      "Part 6 - Working with Boundaries",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>(WIP) Boundary Problems - Evaluating Solutions on Multiple Metrics</span>"
    ]
  }
]